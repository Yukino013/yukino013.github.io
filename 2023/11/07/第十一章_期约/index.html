<!DOCTYPE html>
<html lang="cn">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="黑板擦">





<title>第十一章_期约 | 我在看着你</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js%20/js/sakura.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">黑板擦&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">生活</a>
                
                    <a class="menu-item" href="/bangumis/">Bangumis</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">黑板擦&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">生活</a>
                
                    <a class="menu-item" href="/bangumis/">Bangumis</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">第十一章_期约</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">黑板擦</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 7, 2023&nbsp;&nbsp;21:53:31</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/JavaScript/">JavaScript</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析 程序在执行到代码任意位置时的状态（比如变量的值）。</p>
<p>异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必 要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问 一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。 异步操作的例子可以是在定时回调中执行一次简单的数学计算：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> x = <span class="number">3</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> x = x + <span class="number">4</span>, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure>



<h2 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h2><p>在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。</p>
<p>1.异步返回值</p>
<p>2.失败处理</p>
<p>3.嵌套异步回调</p>
<p>如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。 嵌套回调的代码维护起来就是噩梦</p>
<h2 id="期约（promise）"><a href="#期约（promise）" class="headerlink" title="期约（promise）"></a>期约（promise）</h2><h3 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h3><p>ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入 执行器（executor）函数作为参数</p>
<p>下面的例子使用了一个空函数对象来应付一下解释器： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;  </span></span><br></pre></td></tr></table></figure>

<p>之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 SyntaxError。</p>
<h4 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h4><p>期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<p>待定（pending）  </p>
<p>兑现（fulfilled），有时候也称为“解决”，resolved） </p>
<p>拒绝（rejected）</p>
<p>1.在待定状态下，期约可以落定为代表成功的兑现 （fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。</p>
<p>2.不能保证期约必然会脱离待定状态。</p>
<p>3.要组织合理的代码，无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。</p>
<h4 id="期约两大用途"><a href="#期约两大用途" class="headerlink" title="期约两大用途"></a>期约两大用途</h4><p>1.抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定” 表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。</p>
<p>假设期约要向服务器发送一个 HTTP 请求。请求返回 200-299 范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在 200-299 这个范围内， 那么就会把期约状态切换为“拒绝“。</p>
<p>2.期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。</p>
<p>假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON。如果请求返回范围在 200-299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。类似地，如果请求返回的状态码不在 200-299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Error 对象，包含着 HTTP 状态码及相关错误消息</p>
<h4 id="通过执行函数控制期约状态"><a href="#通过执行函数控制期约状态" class="headerlink" title="通过执行函数控制期约状态"></a>通过执行函数控制期约状态</h4><p>1.期约的状态是私有的，所以只能在内部进行操作</p>
<p>2.执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。</p>
<p>3.控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>Promise.resolve() 期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 Promise.resolve()静态方法，可以实例化一个解决的期约。</p>
<p>这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());  <span class="comment">// Promise : undefined  setTimeout(console.log, 0, Promise.resolve(3)); // Promise : 3</span></span><br></pre></td></tr></table></figure>

<p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此， Promise.resolve()可以说是一个幂等方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); </span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p))); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个幂等性会保留传入期约的状态。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p> Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误 （这个错误不能通过 try&#x2F;catch 捕获，而只能通过拒绝处理程序捕获）。</p>
<p>下面的两个期约实例实际上是一样的： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br></pre></td></tr></table></figure>



<p><strong>关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期 约对象，则这个期约会成为它返回的拒绝期约的理由：</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>())); </span><br><span class="line"></span><br><span class="line"> <span class="comment">// Promise : Promise  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="同步-异步执行的二元性"><a href="#同步-异步执行的二元性" class="headerlink" title="同步&#x2F;异步执行的二元性"></a>同步&#x2F;异步执行的二元性</h4><p>两种模式下抛出错误的情形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Error: foo </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar </span></span><br></pre></td></tr></table></figure>



<p>1.第一个 try&#x2F;catch 抛出并捕获了错误，第二个 try&#x2F;catch 抛出错误却没有捕获到。</p>
<p>2.这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这 里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式 的媒介。</p>
<p>3.在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队 列来处理的。因此，try&#x2F;catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互 的方式就是使用异步结构——更具体地说，就是期约的方法。</p>
<h3 id="期约的实例方法"><a href="#期约的实例方法" class="headerlink" title="期约的实例方法"></a>期约的实例方法</h3><h4 id="实现-Thenable-接口"><a href="#实现-Thenable-接口" class="headerlink" title="实现 Thenable 接口"></a>实现 Thenable 接口</h4><p>在 ECMAScript 暴露的异步结构中，<strong>任何对象</strong>都有一个 then()方法。这个方法被认为实现了 Thenable 接口。</p>
<p>ECMAScript 的 Promise 类型实现了 Thenable 接口。</p>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多 两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话， 则会在期约分别进入“兑现”和“拒绝”状态时执行。传给then()的任何非函数类型的参数都会被静默忽略。</p>
<h5 id="Promise-prototype-then-方法返回一个新的期约实例："><a href="#Promise-prototype-then-方法返回一个新的期约实例：" class="headerlink" title="Promise.prototype.then()方法返回一个新的期约实例："></a>Promise.prototype.then()方法返回一个新的期约实例：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false </span></span><br></pre></td></tr></table></figure>



<p>这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会 包装上一个期约解决之后的值。如果没有显式的返回语句，则 Promise.resolve()会包装默认的返回值 undefined</p>
<p>onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？ 因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。</p>
<h4 id="传递解决值和拒绝理由"><a href="#传递解决值和拒绝理由" class="headerlink" title="传递解决值和拒绝理由"></a>传递解决值和拒绝理由</h4><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理 程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第 二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失 败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。</p>
<p>1.在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传 的。</p>
<p>2.这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一 参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo then里面只有一个onresolved参数，所以就是onResolved 处理程序</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar catch</span></span><br></pre></td></tr></table></figure>



<p>Promise.resolve()和 Promise.reject()在被调用时就会接收解决值和拒绝理由。同样地，它 们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar </span></span><br></pre></td></tr></table></figure>



<h4 id="拒绝期约与拒绝错误处理"><a href="#拒绝期约与拒绝错误处理" class="headerlink" title="拒绝期约与拒绝错误处理"></a>拒绝期约与拒绝错误处理</h4><p>1.拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。</p>
<p>2.期约可以以任何理由拒绝，包括 undefined，但最好统一使用错误对象。</p>
<h3 id="期约连锁与期约合成"><a href="#期约连锁与期约合成" class="headerlink" title="期约连锁与期约合成"></a>期约连锁与期约合成</h3><h4 id="期约连锁"><a href="#期约连锁" class="headerlink" title="期约连锁"></a>期约连锁</h4><p>把期约逐个地串联起来。之所以可以这样做，是因为每个期约实例的方 法（then()、catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line">&#125;); </span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second&#x27;</span>)) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;third&#x27;</span>)) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fourth&#x27;</span>)); </span><br><span class="line"><span class="comment">// first </span></span><br><span class="line"><span class="comment">// second </span></span><br><span class="line"><span class="comment">// third </span></span><br><span class="line"><span class="comment">// fourth </span></span><br></pre></td></tr></table></figure>

<p>这个实现最终执行了一连串同步任务。没有那么有用。使用 4 个同步函数也可以做到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>))(); </span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;second&#x27;</span>))(); </span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;third&#x27;</span>))(); </span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fourth&#x27;</span>))(); </span><br></pre></td></tr></table></figure>

<p>要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。</p>
<p>这样就可以让每 个后续期约都等待之前的期约，也就是串行化异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 executor&#x27;</span>); </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>); </span><br><span class="line">&#125;); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 executor&#x27;</span>); </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;)) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3 executor&#x27;</span>); </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;)) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4 executor&#x27;</span>); </span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;)); </span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后</span></span><br></pre></td></tr></table></figure>

<p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简 洁地将异步任务串行化，解决之前依赖回调的难题。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>1.Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个 可迭代对象，返回一个新期约：</p>
<p>2.如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的 期约也会拒绝：</p>
<p>3.如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p>
<p>4.如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期 约不会影响最终期约的拒绝理由。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>1.Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个 方法接收一个可迭代对象，返回一个新期约：</p>
<p>2.Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的 期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3 </span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4 </span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5 </span></span><br></pre></td></tr></table></figure>



<p>3.如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约 不会影响最终期约的拒绝理由。</p>
<h2 id="promise的异常处理（附加）"><a href="#promise的异常处理（附加）" class="headerlink" title="promise的异常处理（附加）"></a>promise的异常处理（附加）</h2><p><img src="/../images/%E5%BC%82%E5%B8%B81.png" alt="image-20231107221319535"></p>
<p>promise异常会向着链条向后传递</p>
<p>catch能捕获链式上的上一个promise对象的异常</p>
<p><img src="/../images/%E5%BC%82%E5%B8%B82.png" alt="image-20231107221319535"></p>
<p><img src="/../images/%E5%BC%82%E5%B8%B83.png" alt="image-20231107221319535"></p>
<p>如果使用then，只能捕获ajax这个promise对象的异常</p>
<p><img src="/../images/%E5%BC%82%E5%B8%B84.png" alt="image-20231107221319535"></p>
<p><img src="/../images/%E5%BC%82%E5%B8%B85.png" alt="image-20231107221319535"></p>
<p>可以注册一个全局处理异常对象事件在window上</p>
<p><img src="/../images/%E5%BC%82%E5%B8%B86.png" alt="image-20231107221319535"></p>
<p>而在node当中，需要在process当中注册这个事件</p>
<p><img src="/../images/%E5%BC%82%E5%B8%B87.png" alt="image-20231107221319535"></p>
<p>不过还是尽量在代码中明确捕获每一个异常，而不是丢给全局。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>黑板擦</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2023/11/07/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E6%9C%9F%E7%BA%A6/">http://example.com/2023/11/07/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E6%9C%9F%E7%BA%A6/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>黑板擦</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>扣1送小布丁</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JavaScript/"># JavaScript</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/11/08/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/">第十一章_异步函数</a>
            
            
            <a class="next" rel="next" href="/2023/11/06/pc%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/">pc端网页特效</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 黑板擦 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>