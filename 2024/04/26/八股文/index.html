<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文 | 我在看着你</title><meta name="author" content="黑板擦"><meta name="copyright" content="黑板擦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML篇1.src和href的区别 src属性在HTML标签中用于加载外部资源，其行为和效果取决于所使用的标签类型。通常情况下，它被用于加载图片、脚本、框架、音频和视频等外部资源。 href属性在HTML标签中用于创建超链接或引入外部样式表，其行为和效果取决于所使用的标签类型。通常情况下，它被用于创建超链接或引入外部样式表，以实现页面间的导航或样式的引入。  区别：  适用标签不同： src属性">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文">
<meta property="og:url" content="http://example.com/2024/04/26/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="我在看着你">
<meta property="og:description" content="HTML篇1.src和href的区别 src属性在HTML标签中用于加载外部资源，其行为和效果取决于所使用的标签类型。通常情况下，它被用于加载图片、脚本、框架、音频和视频等外部资源。 href属性在HTML标签中用于创建超链接或引入外部样式表，其行为和效果取决于所使用的标签类型。通常情况下，它被用于创建超链接或引入外部样式表，以实现页面间的导航或样式的引入。  区别：  适用标签不同： src属性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Snipaste_2024-04-06_01-13-21.png">
<meta property="article:published_time" content="2024-04-25T16:29:53.000Z">
<meta property="article:modified_time" content="2024-10-24T15:59:50.687Z">
<meta property="article:author" content="黑板擦">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Snipaste_2024-04-06_01-13-21.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/26/%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-24 23:59:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/Snipaste_2024-04-06_01-08-30.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 追番</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/Snipaste_2024-04-06_01-13-21.png')"><nav id="nav"><span id="blog-info"><a href="/" title="我在看着你"><span class="site-name">我在看着你</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 追番</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-25T16:29:53.000Z" title="发表于 2024-04-26 00:29:53">2024-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-24T15:59:50.687Z" title="更新于 2024-10-24 23:59:50">2024-10-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HTML篇"><a href="#HTML篇" class="headerlink" title="HTML篇"></a>HTML篇</h2><h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1.src和href的区别"></a>1.src和href的区别</h3><ul>
<li><code>src</code>属性在HTML标签中用于加载外部资源，其行为和效果取决于所使用的标签类型。通常情况下，它被用于加载图片、脚本、框架、音频和视频等外部资源。</li>
<li><code>href</code>属性在HTML标签中用于创建超链接或引入外部样式表，其行为和效果取决于所使用的标签类型。通常情况下，它被用于创建超链接或引入外部样式表，以实现页面间的导航或样式的引入。</li>
</ul>
<p>区别：</p>
<ol>
<li><strong>适用标签不同</strong>：<ul>
<li><code>src</code>属性通常用于<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>等标签，用于嵌入外部资源。</li>
<li><code>href</code>属性通常用于<code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>和<code>&lt;base&gt;</code>等标签，用于创建超链接或引入外部样式表。</li>
</ul>
</li>
<li><strong>加载行为不同</strong>：<ul>
<li>对于<code>src</code>属性，浏览器会立即加载指定的资源，它会阻塞页面的加载，直到资源加载完成。</li>
<li>对于<code>href</code>属性，它指定的资源通常在用户与页面交互时加载，不会阻塞页面的加载。</li>
</ul>
</li>
<li><strong>替换内容不同</strong>：<ul>
<li><code>src</code>属性会替换元素原本的内容，例如，一个<code>&lt;img&gt;</code>标签的<code>src</code>属性指向的图片地址会显示在页面上，而原本<code>&lt;img&gt;</code>标签中的内容将被替换掉。</li>
<li><code>href</code>属性不会替换元素原本的内容，例如，一个<code>&lt;a&gt;</code>标签的<code>href</code>属性指向的超链接地址会成为链接的目标，但不会影响<code>&lt;a&gt;</code>标签原本的内容。</li>
</ul>
</li>
</ol>
<h3 id="2-Html5新增特性"><a href="#2-Html5新增特性" class="headerlink" title="2.Html5新增特性"></a>2.Html5新增特性</h3><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><ul>
<li><code>代码结构清晰</code>，易于阅读，</li>
<li><code>利于开发和维护</code> 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li><code>有利于搜索引擎优化（SEO）</code>，搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
</ul>
<h4 id="增强表单属性"><a href="#增强表单属性" class="headerlink" title="增强表单属性"></a>增强表单属性</h4><p>email<code>、</code>number<code>、</code>时间控件<code>、</code>color颜色拾取器<code>、</code>placeholder<code>、</code>autofocus自动获取焦点…</p>
<h4 id="新增音视频标签"><a href="#新增音视频标签" class="headerlink" title="新增音视频标签"></a>新增音视频标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</span><br><span class="line">您的浏览器不支持 audio 元素。</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/30.png"></p>
<h4 id="画布canvas"><a href="#画布canvas" class="headerlink" title="画布canvas"></a>画布canvas</h4><p><code>&lt;canvas&gt;</code> 是 <code>HTML5</code> 新增的，一个可以使用脚本(通常为 <code>JavaScript</code>) 在其中绘制图像的 <code>HTML</code> 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。</p>
<h4 id="SVG绘图"><a href="#SVG绘图" class="headerlink" title="SVG绘图"></a>SVG绘图</h4><ul>
<li>SVG指可伸缩矢量图形</li>
<li>SVG用于定义用于网络的基于矢量的图形</li>
<li>SVG使用XML格式定义图形</li>
<li>SVG图像在放大或改变尺寸的情况下其图形质量不会有损失</li>
</ul>
<h4 id="SVG与Canvas的区别："><a href="#SVG与Canvas的区别：" class="headerlink" title="SVG与Canvas的区别："></a>SVG与Canvas的区别：</h4><ul>
<li>SVG适用于描述XML中的2D图形的语言</li>
<li>Canvas随时随地绘制2D图形（使用javaScript）</li>
<li>SVG是基于XML的，意味这可以操作DOM，渲染速度较慢</li>
<li>在SVG中每个形状都被当做是一个对象，如果SVG发生改变，页面就会发生重绘</li>
<li>Canvas是一像素一像素地渲染，如果改变某一个位置，整个画布会重绘。</li>
</ul>
<h4 id="拖拉拽API"><a href="#拖拉拽API" class="headerlink" title="拖拉拽API"></a>拖拉拽API</h4><p>拖放是一种常见的特性，即捉取对象后拖到另一个位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当元素拖动时，我们可以检查其拖动的数据。</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/31.png"></p>
<h4 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h4><p>使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键&#x2F;值 对存在, web网页的数据只允许该网页访问使用。</p>
<p><strong>websorage拥有5M的存储容量，而cookie却只有4K</strong>，这是完全不能比的。</p>
<p>客户端存储数据的两个对象为：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。</li>
</ul>
<p>API(以localStorage为例)：</p>
<ul>
<li>保存数据：localStorage.setItem(key,value);</li>
<li>读取数据：localStorage.getItem(key);</li>
<li>删除单个数据：localStorage.removeItem(key);</li>
<li>删除所有数据：localStorage.clear();</li>
<li>得到某个索引的key：localStorage.key(index);</li>
</ul>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket协议为web应用程序客户端和服务端之间提供了一种全双工通信机制。</p>
<h3 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3.DOCTYPE(⽂档类型) 的作⽤"></a>3.DOCTYPE(⽂档类型) 的作⽤</h3><p><code>DOCTYPE</code>是HTML5中一种标准通用标记语言的文档类型声明，是用来告诉浏览器的解析器，该用什么样的方式去加载识别文档。</p>
<p>一般是html和xml的方式</p>
<h3 id="4-iframe-有那些优点和缺点？"><a href="#4-iframe-有那些优点和缺点？" class="headerlink" title="4.iframe 有那些优点和缺点？"></a>4.iframe 有那些优点和缺点？</h3><p><code>iframe</code>通常用来加载外部链接，不会影响网页内容的加载。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>可以将网页原封不动的加载进来，用来加载显示较慢的内容，如广告、视频等</p>
</li>
<li><p>增加代码的可用性</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>加载的内容无法被浏览器引擎识别，对<code>SEO</code>不友好</li>
<li>会阻塞<code>onload</code>事件加载</li>
</ul>
<h3 id="5-script标签中defer和async的区别"><a href="#5-script标签中defer和async的区别" class="headerlink" title="5.script标签中defer和async的区别"></a>5.script标签中defer和async的区别</h3><ul>
<li>常规的script标签会阻碍浏览器的解析，直到脚本加载并执行完毕</li>
<li>带有async属性的script标签会异步加载脚本，<strong>加载完成后会立即执行，可能阻塞文档解析</strong>，也可能不阻塞，执行时机不确定</li>
<li>带有defer属性的script标签也是异步加载脚本，但<strong>会在文档解析完成后执行，并且不会破坏脚本之间的依赖关系</strong></li>
</ul>
<h3 id="6-块级元素、行内元素、行内块元素区别"><a href="#6-块级元素、行内元素、行内块元素区别" class="headerlink" title="6.块级元素、行内元素、行内块元素区别"></a>6.块级元素、行内元素、行内块元素区别</h3><h4 id="块级元素有以下特点："><a href="#块级元素有以下特点：" class="headerlink" title="块级元素有以下特点："></a>块级元素有以下特点：</h4><ul>
<li>每个块级元素都是独自占一行；</li>
<li>高度，行高，外边距（margin）以及内边距（padding）都可以控制；</li>
<li>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；</li>
<li>多个块状元素标签写在一起，默认排列方式为从上至下；</li>
</ul>
<h4 id="行内元素有以下特点："><a href="#行内元素有以下特点：" class="headerlink" title="行内元素有以下特点："></a>行内元素有以下特点：</h4><ul>
<li>不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；</li>
<li>高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效  上下无效；</li>
<li>设置行高有效，等同于给父级元素设置行高；</li>
<li>元素的宽度就是它包含的文字或图片的宽度，不可改变；</li>
<li>行内元素中不能放块级元素，a 链接里面不能再放链接；</li>
</ul>
<h4 id="行内块级元素具体特点如下："><a href="#行内块级元素具体特点如下：" class="headerlink" title="行内块级元素具体特点如下："></a>行内块级元素具体特点如下：</h4><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。</p>
<h4 id="元素类型转换-display"><a href="#元素类型转换-display" class="headerlink" title="元素类型转换 display"></a>元素类型转换 display</h4><p>display：block ，定义元素为块级元素</p>
<p>display : inline ，定义元素为行内元素</p>
<p>display：inline-block，定义元素为行内块级元素</p>
<h3 id="7-怎样添加、移除、移动、复制、创建和查找节点"><a href="#7-怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="7.怎样添加、移除、移动、复制、创建和查找节点"></a>7.怎样添加、移除、移动、复制、创建和查找节点</h3><p>添加节点<code>document.appendchild(dom)</code></p>
<p>移除节点<code>document.removechild(dom)</code></p>
<p>移动节点<code>document.appendchild(targetDom)</code></p>
<p>复制节点<code>dom.cloneNode(true)</code>，参数<code>true</code>表示是否复制子节点</p>
<p>创建节点<code>document.createElement(dom)</code></p>
<p>查找节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;elementId&quot;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;className&quot;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;tagName&quot;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;selector&quot;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;selector&quot;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><h3 id="1-设置背景透明"><a href="#1-设置背景透明" class="headerlink" title="1.设置背景透明"></a>1.设置背景透明</h3><p>在 CSS 中设置背景透明的方式有多种，以下是其中几种常见的方式：</p>
<ol>
<li><p><strong>使用 RGBA 颜色值</strong>：<br>使用 RGBA 颜色值是一种常见的设置背景透明的方式。RGBA 表示红、绿、蓝和透明度（Alpha），透明度值介于 0（完全透明）和 1（完全不透明）之间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>); <span class="comment">/* 白色背景，透明度为 50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用透明 PNG 图片</strong>：<br>使用透明的 PNG 图片作为背景，可以实现背景的部分透明效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;transparent-background.png&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 transparent 关键字</strong>：<br><code>transparent</code> 关键字表示完全透明的颜色，可以直接将其作为背景颜色来实现背景透明。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent; <span class="comment">/* 完全透明的背景 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 CSS3 的 opacity 属性</strong>：<br><code>opacity</code> 属性可以设置元素的透明度，包括元素的背景和内容。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>; <span class="comment">/* 元素透明度为 50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上是一些常见的设置背景透明的方式，具体应根据实际需求选择适合的方法。</p>
<h3 id="2-CSS3新增特性"><a href="#2-CSS3新增特性" class="headerlink" title="2.CSS3新增特性"></a>2.CSS3新增特性</h3><h4 id="新增CSS选择器、伪类"><a href="#新增CSS选择器、伪类" class="headerlink" title="新增CSS选择器、伪类"></a>新增CSS选择器、伪类</h4><h5 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h5><p>多元素选择器，为多个元素应用同一个样式；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后代选择器，使一些样式、规则只在某一些指定的有“祖孙—后代关系”的后代元素上适用，其他非指定的结构中不适用；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子元素选择器，使一些样式、规则只在某一些指定的有直接的“父子关系”的子元素上适用，其他非指定的结构中不适用；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接相邻元素选择器，前提，两个元素有共同的父元素，且后一个元素“紧接”在前一个元素后边时，你想对后一个元素添加样式；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>普通相邻元素选择器，相对于“直接相邻元素选择器”而言，两个元素也必须有共同的父元素，但后一个元素不需要“紧接”在前一个元素后边，你也可以对后一个元素添加样式；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> ~ <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="特效：text-shadow、box-shadow"><a href="#特效：text-shadow、box-shadow" class="headerlink" title="特效：text-shadow、box-shadow"></a>特效：<code>text-shadow</code>、<code>box-shadow</code></h4><h4 id="线性渐变-gradient"><a href="#线性渐变-gradient" class="headerlink" title="线性渐变: gradient"></a>线性渐变: <code>gradient</code></h4><h4 id="旋转过渡：transform、transtion"><a href="#旋转过渡：transform、transtion" class="headerlink" title="旋转过渡：transform、transtion"></a>旋转过渡：<code>transform</code>、<code>transtion</code></h4><h4 id="动画-animation"><a href="#动画-animation" class="headerlink" title="动画: animation"></a>动画: <code>animation</code></h4><h4 id="圆角-border-radius"><a href="#圆角-border-radius" class="headerlink" title="圆角: border-radius"></a>圆角: <code>border-radius</code></h4><h3 id="3-伪元素和伪类的区别？"><a href="#3-伪元素和伪类的区别？" class="headerlink" title="3.伪元素和伪类的区别？"></a>3.伪元素和伪类的区别？</h3><p>伪元素（pseudo-elements）和伪类（pseudo-classes）是 CSS 中用于选择元素的特殊方式，它们在语法和作用上有一些区别。</p>
<ol>
<li><p><strong>伪元素（pseudo-elements）</strong>：</p>
<ul>
<li>伪元素用于向选中的元素添加特殊的样式，以创建一些不在文档树中的额外元素。这些额外元素通常用于装饰或添加内容，但不会真正改变文档内容。</li>
<li>伪元素以双冒号 <code>::</code> 开头，例如 <code>::before</code> 和 <code>::after</code>。</li>
<li>常见的伪元素包括 <code>::before</code>、<code>::after</code>、<code>::first-line</code> 和 <code>::first-letter</code> 等。</li>
<li>伪元素在 CSS2 中以单冒号 <code>:</code> 开头，但在 CSS3 中规范中改为使用双冒号 <code>::</code>。</li>
</ul>
</li>
<li><p><strong>伪类（pseudo-classes）</strong>：</p>
<ul>
<li>伪类用于选择文档中的某些状态或特定的元素，它们并不创建新的元素，而是根据元素的状态或位置来进行选择。</li>
<li>伪类以单冒号 <code>:</code> 开头，例如 <code>:hover</code> 和 <code>:nth-child()</code>。</li>
<li>常见的伪类包括 <code>:hover</code>、<code>:active</code>、<code>:focus</code>、<code>:first-child</code> 和 <code>:nth-child()</code> 等。</li>
</ul>
</li>
</ol>
<p>总的来说，<strong>伪元素用于创建额外的元素或样式效果，而伪类用于选择元素的特定状态或位置</strong>。在实际使用中，伪元素通常用于添加额外的装饰或内容，而伪类用于响应用户的交互或选择特定位置的元素。</p>
<h3 id="4-隐藏元素的方式"><a href="#4-隐藏元素的方式" class="headerlink" title="4.隐藏元素的方式"></a>4.隐藏元素的方式</h3><ul>
<li><code>display：none</code>：元素在文档中不存在，不会占据位置。</li>
<li><code>visibility： hidden</code>：元素在文档中的位置还保留，仍然占据空间。</li>
<li><code>opacity：0</code>：将透明度设置为0。</li>
<li><code>z-index</code>：负值：直接将元素放置在最下层，利用其他元素来遮盖。</li>
<li><code>position：absolute</code>：将元素定位到可视区域以外。</li>
</ul>
<h3 id="5-有了使用过Sass、Less-吗？他们的区别是什么？"><a href="#5-有了使用过Sass、Less-吗？他们的区别是什么？" class="headerlink" title="5.有了使用过Sass、Less 吗？他们的区别是什么？"></a>5.有了使用过Sass、Less 吗？他们的区别是什么？</h3><p>他们都是 <code>CSS</code> 预处理器，是 CSS<code> </code>上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 <code>CSS</code>。 增加了 <code>CSS</code>代码的复用性，层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。 <strong>区别</strong></p>
<ol>
<li>编译环境不一样<ul>
<li><code>Sass</code>是在服务端处理的，以前是<code>Ruby</code>，现在是<code>Dart-Sass</code>或<code>Node-Sass</code></li>
<li>而<code>Less</code>是需要引入<code>less.js</code>来处理Less代码输出CSS到浏览器，也可以在开发服务器将Less语法编译成css文件，输出CSS文件到生产包目录</li>
</ul>
</li>
<li>变量符不一样，Less是<code>@</code>，而Scss是<code>$</code>。</li>
<li><code>Sass</code>支持条件语句，可以使用<code>if&#123;&#125;else&#123;&#125;,for&#123;&#125;</code>循环等等。而<code>Less</code>不支持</li>
</ol>
<h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6.link和@import的区别"></a>6.link和@import的区别</h3><ul>
<li><code>link</code>是HTML提供的标签，不仅可以加载<code>CSS</code>文件，还可以定义<code>RSS、rel</code>连接属性等</li>
<li><code>@import</code>是CSS提供等语法规则，只有导入样式表带作用。</li>
<li><code>link</code>标签引入的CSS被同时加载，而<code>@import</code>引入的CSS将在页面<strong>加载完毕</strong>后被加载</li>
</ul>
<h3 id="7-常见的CSS单位"><a href="#7-常见的CSS单位" class="headerlink" title="7.常见的CSS单位"></a>7.常见的CSS单位</h3><ul>
<li>px像素<ul>
<li>CSS像素</li>
<li>物理像素</li>
</ul>
</li>
<li>**百分比%**，作用于父元素， 当浏览器的宽度或者高度发生变化时，当前元素依据比例发生变化。</li>
<li><strong>em和rem</strong>，相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></li>
<li><strong>vw&#x2F;vh</strong>是与视图窗口有关的单位，代表视图窗口的宽高。</li>
</ul>
<h4 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h4><ul>
<li><code>px</code> 固定像素单位，不能随其它元素的变化而变化</li>
<li><code>em</code>是相对于父元素的单位，会随着父元素变化而变化</li>
<li><code>rem</code>是相对于根元素<code>html</code>，它会随着<code>html</code>元素变化而变化</li>
</ul>
<h3 id="8-两栏布局"><a href="#8-两栏布局" class="headerlink" title="8.两栏布局"></a>8.两栏布局</h3><ul>
<li><strong>利用浮动</strong>，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">1000px</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="selector-class">.left</span> &#123;</span><br><span class="line">       <span class="attribute">float</span>: left;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">1000px</span>;</span><br><span class="line">       <span class="attribute">background</span>: tomato;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="selector-class">.right</span> &#123;</span><br><span class="line">       <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">1000px</span>;</span><br><span class="line">       <span class="attribute">width</span>: auto;</span><br><span class="line">       <span class="attribute">background</span>: gold;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>利用浮动</strong>，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>利用flex布局</strong>，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>利用绝对定位</strong>，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="9-水平垂直居中"><a href="#9-水平垂直居中" class="headerlink" title="9.水平垂直居中"></a>9.水平垂直居中</h3><ul>
<li>利用绝对定位，先将元素的左上角通过<code>top:50%</code>和<code>left:50%</code>定位到页面的中心，然后再通过<code>translate</code>来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>利用绝对定位，设置四个方向的值都为0，并将<code>margin</code>设置为<code>auto</code>，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>使用<code>flex</code>布局，通过<code>align-items:center</code>和<code>justify-content:center</code>设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-flex布局理解"><a href="#10-flex布局理解" class="headerlink" title="10.flex布局理解"></a>10.flex布局理解</h3><p><code>flex</code>布局是<code>CSS3</code>新增的一种布局方式，能够根据不同屏幕尺寸的变化来自适应大小。</p>
<h4 id="常用的属性："><a href="#常用的属性：" class="headerlink" title="常用的属性："></a>常用的属性：</h4><ul>
<li><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</li>
<li><code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</li>
<li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</li>
<li><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</li>
<li><code>align-items</code>属性定义项目在交叉轴上如何对齐。</li>
<li><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<h4 id="flex-1表示什么"><a href="#flex-1表示什么" class="headerlink" title="flex: 1表示什么"></a>flex: 1表示什么</h4><p>flex : 1 其实是代表3个属性的简写：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=flex-grow&spm=1001.2101.3001.7020">flex-grow</a>、flex-shirnk、flex-basis，这3个属性是可以单独进行设置的</p>
<p>当设置了 flex:1 属性时，代表 flex-grow: 1、flex-shirnk：1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=flex-basis&spm=1001.2101.3001.7020">flex-basis</a>：0%</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/32.png"></p>
<h3 id="11-对BFC的理解，如何创建BFC"><a href="#11-对BFC的理解，如何创建BFC" class="headerlink" title="11.对BFC的理解，如何创建BFC"></a>11.对BFC的理解，如何创建BFC</h3><p><strong>BFC是块级格式上下文</strong>（Block Formatting Context，BFC），是CSS布局的一个概念，在BFC布局里面的元素不受外面元素影响。</p>
<h4 id="创建BFC条件"><a href="#创建BFC条件" class="headerlink" title="创建BFC条件"></a><strong>创建BFC条件</strong></h4><ul>
<li>设置浮动：<code>float</code>有值并不为空</li>
<li>设置绝对定位：<code> position（absolute、fixed）</code></li>
<li><code>overfilow</code>值为：<code>hidden</code>、<code>auto</code>、&#96;scroll</li>
<li><code>display</code>值为：<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>等</li>
</ul>
<h4 id="BFC作用："><a href="#BFC作用：" class="headerlink" title="BFC作用："></a><strong>BFC作用</strong>：</h4><ul>
<li>解决<code>margin</code>重叠问题：由于BFC是一个独立的区域，内部元素和外部元素互不影响，将两个元素变为BFC，就解决了<code>margin</code>重叠问题</li>
<li>创建自适应两栏布局：可以用来创建自适应两栏布局，左边宽高固定，右边宽度自适应。</li>
<li>解决高度塌陷问题：在子元素设置浮动后，父元素会发生高度的塌陷，也就是父元素的高度为0解决这个问题，只需要将父元素变成一个BFC。</li>
</ul>
<h3 id="12-什么是margin重叠，如何解决"><a href="#12-什么是margin重叠，如何解决" class="headerlink" title="12.什么是margin重叠，如何解决"></a>12.什么是margin重叠，如何解决</h3><p>两个块级元素分别设置上下<code>margin</code>时可能会导致边距合并为一个边距，合并到边距取最大的那个值。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。<strong>重叠只会出现在垂直方向。</strong></p>
<h4 id="计算规则"><a href="#计算规则" class="headerlink" title="计算规则"></a><strong>计算规则</strong></h4><ul>
<li>都是正数，取最大的。<code>20px 40px ---&gt; 40px</code></li>
<li>一正一负，用正数减去负数后。<code>20px -50px ---&gt; -30px</code></li>
<li>都是负数，用0减去两个中绝对值大的那个。<code>-30px -10px ---&gt; -20px</code></li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h4><p>对于重叠的情况，主要有两种：<strong>兄弟之间重叠（margin合并）</strong> 和 <strong>父子之间重叠（margin塌陷）</strong></p>
<ul>
<li>兄弟之间重叠<ul>
<li>底部元素变为行内盒子：<code>display: inline-block</code></li>
<li>底部元素设置浮动：<code>float</code></li>
<li>底部元素的<code>position</code>的值为<code>absolute/fixed</code></li>
</ul>
</li>
<li>父子之间重叠<ul>
<li>父元素加入：<code>overflow: hidden</code></li>
<li>父元素添加透明边框：<code>border:1px solid transparent</code></li>
<li>子元素变为行内盒子：<code>display: inline-block</code></li>
<li>子元素加入浮动属性或定位</li>
</ul>
</li>
</ul>
<h3 id="13-position-常用属性"><a href="#13-position-常用属性" class="headerlink" title="13.position 常用属性"></a>13.position 常用属性</h3><ul>
<li><code>static</code> 默认值，没有定位，元素正常在文档流中显示</li>
<li><code>relative</code> 相对定位，相对于原来的位置进行定位</li>
<li><code>absolute</code> 绝对定位，相对于static定位意外以外的一个父元素进行定位。</li>
<li><code>fixed</code> 绝对定位，相对于浏览器窗口</li>
<li><code>sticky</code> 粘性定位，基于用户滚动位置</li>
</ul>
<h3 id="14-实现一个三角形"><a href="#14-实现一个三角形" class="headerlink" title="14.实现一个三角形"></a>14.实现一个三角形</h3><p>通过设置不同方向边框来实现</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="15-画一条0-5px的线"><a href="#15-画一条0-5px的线" class="headerlink" title="15.画一条0.5px的线"></a>15.画一条0.5px的线</h3><p>使用 <code>transform: scale()</code> 方法绘制 0.5px 的线条，可以确保在大多数设备上准确渲染出细微的线条。这里是如何实现的示例：</p>
<h5 id="水平线条"><a href="#水平线条" class="headerlink" title="水平线条"></a>水平线条</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>0.5px Line<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.horizontal-line</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1px</span>; <span class="comment">/* Initial height */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform-origin</span>: top;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;horizontal-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="垂直线条"><a href="#垂直线条" class="headerlink" title="垂直线条"></a>垂直线条</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>0.5px Line<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.vertical-line</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">1px</span>; <span class="comment">/* Initial width */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform-origin</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;vertical-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><ul>
<li><strong>水平线条</strong>: 通过将一个高度为1px的div使用<code>transform: scaleY(0.5)</code>来缩放，使其显示为0.5px的高度。<code>transform-origin: top</code>确保了缩放是从上边缘开始。</li>
<li><strong>垂直线条</strong>: 通过将一个宽度为1px的div使用<code>transform: scaleX(0.5)</code>来缩放，使其显示为0.5px的宽度。<code>transform-origin: left</code>确保了缩放是从左边缘开始。</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li><strong>初始尺寸</strong>: 确保初始尺寸设置为1px（例如，水平线条的高度或垂直线条的宽度），这样缩放后能正确显示为0.5px。</li>
<li><strong>浏览器支持</strong>: <code>transform</code>属性在现代浏览器中有很好的支持，但对于非常旧的浏览器可能会有兼容性问题。</li>
</ol>
<h3 id="16-如何解决1px"><a href="#16-如何解决1px" class="headerlink" title="16.如何解决1px"></a>16.如何解决1px</h3><p>在移动端的高DPI（如Retina）屏幕上，CSS中的1px可能显得比预期的粗，这是因为这些屏幕的设备像素比（device pixel ratio, DPR）通常大于1。为了解决这个问题，可以使用几种方法来确保线条在所有设备上都能呈现出一致的1px效果。</p>
<h5 id="方法一：直接使用0-5px"><a href="#方法一：直接使用0-5px" class="headerlink" title="方法一：直接使用0.5px"></a>方法一：直接使用0.5px</h5><p>对于现代浏览器，可以直接使用0.5px来绘制细线条。这种方法简单直接，但需要确保浏览器支持。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>0.5px Line<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.line</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-top</span>: <span class="number">0.5px</span> solid black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="方法二：利用伪元素，先放大再缩小"><a href="#方法二：利用伪元素，先放大再缩小" class="headerlink" title="方法二：利用伪元素，先放大再缩小"></a>方法二：利用伪元素，先放大再缩小</h5><p>使用伪元素创建一个1px的线条，通过<code>transform: scale</code>来缩小为0.5px。这样可以确保在高DPI屏幕上也能正确显示。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>1px Line<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.line</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.line</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform-origin</span>: top;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="方法三：使用viewport缩放"><a href="#方法三：使用viewport缩放" class="headerlink" title="方法三：使用viewport缩放"></a>方法三：使用viewport缩放</h5><p>通过控制<code>viewport</code>的缩放比例来解决1px问题。虽然这种方法较少使用，但在特定情况下可能有效。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=0.5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Viewport Scale<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.line</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-top</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方法将整个页面缩小50%，然后用CSS缩放回去。不过，这会影响整个页面的布局，因此需要慎重使用。</p>
<h5 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h5><ol>
<li><strong>直接写0.5px</strong>: 这是最直接的方法，现代浏览器大多支持。不过在一些旧浏览器上可能不生效。</li>
<li><strong>利用伪元素</strong>: 通过创建伪元素，先绘制1px的线条，然后使用CSS的<code>transform: scale</code>进行缩小。这样可以确保线条在所有设备上都显示为0.5px。</li>
<li><strong>使用viewport缩放</strong>: 通过调整<code>viewport</code>缩放比例，可以缩小页面元素的实际显示尺寸，然后再用CSS调整回来。这种方法影响范围较大，但在某些特定场景下有效。</li>
</ol>
<p>通过这些方法，可以解决高DPI设备上1px线条显示过粗的问题，确保视觉效果的一致性。</p>
<h2 id="JavaScript篇"><a href="#JavaScript篇" class="headerlink" title="JavaScript篇"></a>JavaScript篇</h2><h3 id="1-什么是回调函数？"><a href="#1-什么是回调函数？" class="headerlink" title="1.什么是回调函数？"></a>1.什么是回调函数？</h3><p>回调函数也就是 “回头再调用函数”，把函数指针(引用)通过参数的形式传递给某个函数，该函数在它自身调用之后再调用你传递的函数。</p>
<p>通常将一个函数B传入另一个函数A，并且在需要的时候再调用函数A。</p>
<p>对回调函数的理解就是，定义了一个函数，不去调用他，但是这个函数会在特定时间条件下被调用</p>
<p>回调函数常用于处理异步操作，如网络请求、计时器、事件监听等。</p>
<h5 id="回调函数的用途"><a href="#回调函数的用途" class="headerlink" title="回调函数的用途"></a>回调函数的用途</h5><ol>
<li><strong>处理异步操作</strong>: 回调函数通常用于处理异步任务，如网络请求、数据库操作等。</li>
<li><strong>事件处理</strong>: 在事件驱动的编程中，回调函数用于处理用户交互事件，如点击、鼠标移动等。</li>
<li><strong>数组方法</strong>: 在数组的方法中如 <code>map</code>, <code>filter</code>, <code>reduce</code> 等，回调函数被用来处理数组的每一个元素。</li>
</ol>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><strong>回调地狱</strong>: 过度嵌套的回调函数会导致代码难以维护和理解，通常称为“回调地狱”或“回调金字塔”。</li>
<li><strong>错误处理</strong>: 在异步操作中，确保正确处理错误和异常。否则可能会导致未预料的行为。</li>
</ul>
<h5 id="现代替代方案"><a href="#现代替代方案" class="headerlink" title="现代替代方案"></a>现代替代方案</h5><p>为了避免回调地狱和使异步代码更清晰，现代JavaScript引入了Promises和<code>async/await</code>语法。</p>
<h3 id="2-什么是闭包？优缺点分别是什么？"><a href="#2-什么是闭包？优缺点分别是什么？" class="headerlink" title="2.什么是闭包？优缺点分别是什么？"></a>2.什么是闭包？优缺点分别是什么？</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>闭包（Closure）是指在 JavaScript 中，函数能够访问它自身作用域之外的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(n); <span class="comment">// 999</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f1</span>(); <span class="comment">// 执行 f1，并返回 f2 函数</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 调用 result，即 f2 函数，弹出警告框显示 999</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><ol>
<li>当我们调用 <code>f1()</code> 时，<code>f1</code> 函数执行并返回其内部的 <code>f2</code> 函数。</li>
<li>即使 <code>f1</code> 函数已经执行完毕，<code>f2</code> 函数仍然保有对 <code>f1</code> 作用域中 <code>n</code> 变量的引用。</li>
<li>当我们调用 <code>result()</code> 时，它实际上是调用 <code>f2</code> 函数，并且可以访问 <code>f1</code> 中定义的 <code>n</code> 变量。</li>
</ol>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>1.防止变量污染作用域</p>
<p>2.闭包可以创建私有变量和方法</p>
<p>3.闭包可以用来记住函数执行时的状态信息</p>
<p>4.闭包在处理异步操作和回调函数时非常有用，可以在异步操作完成时保留并访问执行上下文</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><h5 id="1-内存消耗："><a href="#1-内存消耗：" class="headerlink" title="1.内存消耗："></a>1.内存消耗：</h5><p>读取函数内部的变量让函数内部的变量的值始终保持在内存中，不会在父函数调用后被自动清除</p>
<p>解决方法：</p>
<p>1.手动释放引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createClosure</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> largeObject = &#123;&#125;; <span class="comment">// 假设这是一个大的对象</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(largeObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">createClosure</span>();</span><br><span class="line"><span class="comment">// 当不再需要闭包时，释放对 largeObject 的引用</span></span><br><span class="line">closure = <span class="literal">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.使用现代语言特性</p>
<p>利用 <code>let</code> 和 <code>const</code> 声明块级作用域变量，避免不必要的全局变量泄漏</p>
<h5 id="2-性能问题"><a href="#2-性能问题" class="headerlink" title="2.性能问题"></a>2.性能问题</h5><p>解决方法：</p>
<p>1.避免不必要的闭包</p>
<p>2.避免频繁创建和销毁闭包</p>
<p>3.避免频繁创建和销毁闭包</p>
<p>4.使用事件委托</p>
<h3 id="3-js数据类型有哪些"><a href="#3-js数据类型有哪些" class="headerlink" title="3.js数据类型有哪些"></a>3.js数据类型有哪些</h3><p><code>JavaScript</code>共有八种数据类型，分别是 <strong>Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt</strong>。</p>
<p>其中 <strong>Symbol</strong> 和 <strong>BigInt</strong> 是ES6 中新增的数据类型：</p>
<ul>
<li><strong>Symbol</strong>代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li><strong>BigInt</strong> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为<strong>原始数据类型</strong>和<strong>引用数据类型（复杂数据类型）</strong>，他们在内存中的存储方式不同。</p>
<ul>
<li><strong>堆：</strong> 存放<strong>引用数据类型</strong>，引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；<strong>引用数据类型在栈中存储了指针</strong>，该指针指向堆中该实体的起始地址，如<code>Object</code>、<code>Array</code>、<code>Function</code>。</li>
<li><strong>栈：</strong> 存放<strong>原始数据类型</strong>，栈中的简单数据段，占据空间小，属于被频繁使用的数据，如<code>String</code>、<code>Number</code>、<code>Null</code>、<code>Boolean</code>。</li>
</ul>
<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4.null和undefined区别"></a>4.null和undefined区别</h3><p><code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null</code>。</p>
<ul>
<li><strong>undefined</strong> 代表的含义是<strong>未定义</strong>，一般变量<strong>声明了但还没有定义</strong>的时候会返回 <code>undefined</code>，<code>typeof</code>为<code>undefined</code></li>
<li><strong>null</strong> 代表的含义是<strong>空对象</strong>，null主要用于赋值给一些可能会返回对象的变量，作为初始化，<code>typeof</code>为<code>object</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-instanceof-运算符的实现原理"><a href="#5-instanceof-运算符的实现原理" class="headerlink" title="5.instanceof 运算符的实现原理"></a>5.instanceof 运算符的实现原理</h3><p><code>instanceof</code> 运算符的原理是基于原型链的查找。当使用 <code>obj instanceof Constructor</code> 进行判断时，<code>JavaScript</code> 引擎会从 <code>obj</code> 的原型链上查找 <code>Constructor.prototype</code> 是否存在，如果存在则返回 <code>true</code>，否则继续在原型链上查找。如果查找到原型链的顶端仍然没有找到，则返回 <code>false</code>。</p>
<p><code>instanceof</code>运算符只能用于检查某个对象是否是某个构造函数的实例，<strong>不能用于基本类型的检查</strong>，如<code>string</code>、<code>number</code>等</p>
<h3 id="6-typeof-和-instanceof-区别"><a href="#6-typeof-和-instanceof-区别" class="headerlink" title="6.typeof 和 instanceof 区别"></a>6.typeof 和 instanceof 区别</h3><p><code>typeof</code>与<code>instanceof</code> 都是判断数据类型的方法，区别如下：</p>
<ul>
<li><code>typeof</code>会返回一个<strong>运算数的基本类型</strong>，<code>instanceof </code>返回的是<strong>布尔值</strong></li>
<li><code>instanceof</code> 可以准确判断<strong>引用数据类型</strong>，但是不能正确判断<strong>原始数据类型</strong></li>
<li><code>typeof</code>虽然可以判断原始数据类型（<code>null</code> 除外），但是无法判断引用数据类型（<code>function</code> 除外）</li>
</ul>
<h5 id="为什么typeof判断null为object？"><a href="#为什么typeof判断null为object？" class="headerlink" title="为什么typeof判断null为object？"></a>为什么typeof判断null为object？</h5><p>这是 <code>JavaScript</code> 语言的一个历史遗留问题</p>
<h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7.为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7.为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。 因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h5><ul>
<li>将其先转换成整数，再相加之后转回小数。具体做法为先乘10相加后除以10</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=(<span class="number">0.1</span>*<span class="number">10</span>+<span class="number">0.2</span>*<span class="number">10</span>)/<span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x===<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>number</code>对象的<code>toFixed</code>方法，只保留一位小数点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="8-判断数组的方式有哪些"><a href="#8-判断数组的方式有哪些" class="headerlink" title="8.判断数组的方式有哪些"></a>8.判断数组的方式有哪些</h3><p>通过<code>Object.prototype.toString.call()</code>做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>通过原型链做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过ES6的<code>Array.isArray()</code>做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br></pre></td></tr></table></figure>

<p>通过<code>instanceof</code>做判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br></pre></td></tr></table></figure>



<h3 id="9-对类数组对象的理解，如何转化为数组"><a href="#9-对类数组对象的理解，如何转化为数组" class="headerlink" title="9.对类数组对象的理解，如何转化为数组"></a>9.对类数组对象的理解，如何转化为数组</h3><p>类数组也叫<strong>伪数组</strong>，类数组和数组类似，但<strong>不能调用数组方法</strong>，常见的类数组有<strong>arguments</strong>、通过<code>document.getElements</code>获取到的内容等，这些类数组具有<code>length</code>属性</p>
<p>通过 <code>Array.from</code> 方法来实现转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)</span><br></pre></td></tr></table></figure>

<p>通过 <code>call</code> 调用数组的 <code>slice</code> 方法来实现转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike)</span><br></pre></td></tr></table></figure>



<h3 id="10-数组有哪些方法"><a href="#10-数组有哪些方法" class="headerlink" title="10.数组有哪些方法"></a>10.数组有哪些方法</h3><p>数组和字符串的转换方法：<code>toString()</code>、<code>toLocalString()</code>、<code>join() </code>其中<code> join()</code> 方法可以指定转换为字符串时的分隔符。</p>
<p>数组尾部操作的方法 <code>pop()</code> 和<code> push()</code>，<code>push</code> 方法可以传入多个参数。</p>
<p>数组首部操作的方法 <code>shift()</code> 和 <code>unshift()</code> 重排序的方法 <code>reverse()</code> 和<code> sort()</code>，<code>sort()</code> 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>
<p>数组连接的方法<code> concat()</code> ，返回的是拼接好的数组，不影响原数组。</p>
<p>数组截取办法 <code>slice()</code>，用于截取数组中的一部分返回，不影响原数组。</p>
<p>数组插入方法 <code>splice()</code>，影响原数组查找特定项的索引的方法，<code>indexOf()</code> 和 <code>lastIndexOf()</code> 迭代方法 <code>every()</code>、<code>some()</code>、<code>filter()</code>、<code>map()</code> 和<code>forEach()</code>方法</p>
<p>数组归并方法 <code>reduce() </code>和 <code>reduceRight()</code> 方法</p>
<p><strong>改变原数组的方法</strong>：<code>fill()</code>、<code>pop()</code>、<code>push()</code>、<code>shift()</code>、<code>splice()</code>、<code>unshift()</code>、<code>reverse()</code>、<code>sort()</code>；</p>
<p><strong>不改变原数组的方法</strong>：<code>concat()</code>、<code>every()</code>、<code>filter()</code>、<code>find()</code>、<code>findIndex()</code>、<code>forEach()</code>、<code>indexOf()</code>、<code>join()</code>、<code>lastIndexOf()</code>、<code>map()</code>、<code>reduce()</code>、<code>reduceRight()</code>、<code>slice()</code>、<code>some()</code>。</p>
<h3 id="11-substring和substr的区别"><a href="#11-substring和substr的区别" class="headerlink" title="11.substring和substr的区别"></a>11.substring和substr的区别</h3><p>它们都是字符串方法，用于截取字符串的一部分，主要区别在于参数不同</p>
<ul>
<li><code>substring(startIndex, endIndex)</code>： 接收两个参数，一个起始索引和结束索引，来指定字符串范围，如果省略第二个参数，则截取到字符串末尾。</li>
<li><code>substr(startIndex, length)</code>： 接收两个参数，并返回从 <code>startIndex</code> 开始，长度为 <code>length</code> 的子字符串。如果省略第二个参数，则截取到字符串末尾。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// 输出: &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">7</span>, <span class="number">5</span>)); <span class="comment">// 输出: &quot;World&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="12-知道object-assign吗"><a href="#12-知道object-assign吗" class="headerlink" title="12.知道object.assign吗"></a>12.知道object.assign吗</h3><p><code>Object.assign()</code> 是 JavaScript 中一个用于将一个或多个源对象的可枚举属性复制到目标对象的静态方法。它返回目标对象。该方法常用于对象的浅拷贝和合并。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>target</strong>: 目标对象，将要接收源对象的属性。</li>
<li><strong>sources</strong>: 一个或多个源对象，这些对象的属性将被复制到目标对象。</li>
</ul>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><h4 id="1-对象的浅拷贝"><a href="#1-对象的浅拷贝" class="headerlink" title="1. 对象的浅拷贝"></a>1. 对象的浅拷贝</h4><p><code>Object.assign()</code> 可以用于对象的浅拷贝（即仅复制对象的顶层属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：这是浅拷贝，因此嵌套对象（或数组）仍然是共享引用。</p>
<h4 id="2-对象的合并"><a href="#2-对象的合并" class="headerlink" title="2. 对象的合并"></a>2. 对象的合并</h4><p><code>Object.assign()</code> 可以合并多个对象，将多个源对象的属性复制到目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergedObject = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, o1, o2, o3);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mergedObject); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果多个源对象有相同的属性，则后面的属性将覆盖前面的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergedObject = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, o1, o2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mergedObject); <span class="comment">// &#123; a: 1, b: 3, c: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-继承属性和不可枚举属性"><a href="#3-继承属性和不可枚举属性" class="headerlink" title="3. 继承属性和不可枚举属性"></a>3. 继承属性和不可枚举属性</h4><p><code>Object.assign()</code> 只会复制源对象的自身可枚举属性（不包括继承的属性和不可枚举的属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;, &#123;</span><br><span class="line">  <span class="attr">bar</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">baz</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123; bar: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-修改目标对象"><a href="#4-修改目标对象" class="headerlink" title="4. 修改目标对象"></a>4. 修改目标对象</h4><p><code>Object.assign()</code> 会直接修改目标对象本身，并且返回目标对象。如果目标对象需要是一个全新的对象，通常会用空对象 <code>&#123;&#125;</code> 作为目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedTarget); <span class="comment">// &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === returnedTarget); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p><strong>浅拷贝</strong>: <code>Object.assign()</code> 执行的是浅拷贝，而不是深拷贝。如果源对象的某个属性是对象或数组，目标对象获得的只是这个对象或数组的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>.<span class="property">b</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常会中断复制过程</strong>: 如果在复制属性的过程中抛出异常，那么 <code>Object.assign()</code> 方法将不会处理剩余的源对象，并且目标对象已经添加的属性也不会被回滚。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This will stop the copying process&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// &quot;This will stop the copying process&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>Object.assign()</code> 是一个强大的工具，适用于对象的浅拷贝和合并。但由于它执行的是浅拷贝，因此在处理嵌套对象时需要特别注意。如果需要进行深拷贝，可能需要使用其他方法，如递归复制对象或使用第三方库（如 Lodash 的 <code>_.cloneDeep</code>）。</p>
<h3 id="13-知道扩展操作符吗"><a href="#13-知道扩展操作符吗" class="headerlink" title="13.知道扩展操作符吗"></a>13.知道扩展操作符吗</h3><p>扩展操作符（spread operator，<code>...</code>）在对象或数组拷贝时执行的是浅拷贝。浅拷贝仅复制对象或数组的顶层属性，嵌套对象或数组则依然是共享同一引用。</p>
<h5 id="对象的浅拷贝"><a href="#对象的浅拷贝" class="headerlink" title="对象的浅拷贝"></a>对象的浅拷贝</h5><p>扩展操作符可以用于对象的浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 2 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 obj1 中的嵌套对象属性</span></span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>obj2</code> 是 <code>obj1</code> 的浅拷贝，因此修改 <code>obj1</code> 中嵌套对象 <code>b</code> 的属性 <code>c</code> 会影响 <code>obj2</code>。</p>
<h5 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h5><p>扩展操作符同样可以用于数组的浅拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, [2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 arr1 中的嵌套数组</span></span><br><span class="line">arr1[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>arr2</code> 是 <code>arr1</code> 的浅拷贝，因此修改 <code>arr1</code> 中嵌套数组的内容会影响 <code>arr2</code>。</p>
<h3 id="14-new操作符的实现原理"><a href="#14-new操作符的实现原理" class="headerlink" title="14.new操作符的实现原理"></a>14.new操作符的实现原理</h3><p>new操作符的执行过程：</p>
<ol>
<li>创建一个空对象</li>
<li>设置原型，将构造函数的原型指向空对象的 <code>prototype</code> 属性。</li>
<li>将 <code>this</code> 指向这个对象，通过apply执行构造函数。</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</li>
</ol>
<h3 id="15-for…in和for…of的区别"><a href="#15-for…in和for…of的区别" class="headerlink" title="15.for…in和for…of的区别"></a>15.for…in和for…of的区别</h3><p><code>for...in</code> 循环主要是为了遍历对象而生，不适用于遍历数组；<code>for...of</code> 循环可以用来遍历数组、类数组对象，字符串、<code>Set</code>、<code>Map</code> 以及 <code>Generator</code> 对象。</p>
<h3 id="16-对AJAX的理解"><a href="#16-对AJAX的理解" class="headerlink" title="16.对AJAX的理解"></a>16.对AJAX的理解</h3><p><code>AJAX</code>是 Asynchronous JavaScript and XML 的缩写，<strong>指的是通过 JavaScript 的 异步通信</strong>，从服务器获取 <code>XML</code> 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建<code>AJAX</code>请求的步骤：</p>
<ul>
<li>创建一个 <code>XMLHttpRequest</code> 对象。</li>
<li>在这个对象上使用 <code>open</code> 方法创建一个 <code>HTTP</code> 请求，<code>open</code> 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 <code>setRequestHeader</code> 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 <code>XMLHttpRequest</code> 对象一共有 5 个状态，当它的状态变化时会触发<code>onreadystatechange</code> 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 <code>readyState</code> 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 <code>response</code> 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调用 <code>send</code> 方法来向服务器发起请求，可以传入参数作为发送的数据体。</li>
</ul>
<h3 id="17-实现一个AJAX请求"><a href="#17-实现一个AJAX请求" class="headerlink" title="17.实现一个AJAX请求"></a>17.实现一个AJAX请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="18-ajax、axios、fetch的区别"><a href="#18-ajax、axios、fetch的区别" class="headerlink" title="18.ajax、axios、fetch的区别"></a>18.ajax、axios、fetch的区别</h3><h5 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1.ajax"></a><strong>1.ajax</strong></h5><p>英译过来是<code>Aysnchronous JavaScript And XML</code>，直译是异步<code>JS</code>和<code>XML</code>（<code>XML</code>类似<code>HTML</code>，但是设计宗旨就为了传输数据，现已被<code>JSON</code>代替），解释一下就是说<strong>以<code>XML</code>作为数据传输格式发送JS<code>异步</code>请求</strong>。但实际上<strong>ajax是一个一类技术的统称的术语</strong>，包括<code>XMLHttpRequest</code>、<code>JS</code>、<code>CSS</code>、<code>DOM</code>等，它<strong>主要实现网页拿到请求数据后不用刷新整个页面也能呈现最新的数据</strong>。</p>
<p>下面我们简单封装一个<code>ajax</code>请求【面试高频题】：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> ajaxGet = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, url)</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>);  <span class="comment">// 响应结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error, xhr.<span class="property">status</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-fetch"><a href="#2-fetch" class="headerlink" title="2. fetch"></a><strong>2. fetch</strong></h5><p>它其实就<strong>是一个<code>JS</code>自带的发送请求的一个<code>api</code><strong>，拿来跟<code>ajax</code>对比是完全不合理的，它们完全不是一个概念的东西，适合拿来和<code>fetch</code>对比的其实是<code>xhr</code>，也就是上面封装<code>ajax</code>请求的代码里的<code>XMLHttpRequest</code>，这两都是<code>JS</code>自带的发请求的方法，而<code>fetch</code>是<code>ES6</code>出现的，自然功能比xhr更强，主要原因就是它是</strong>基于<code>Promise</code>的，它返回一个<code>Promise</code><strong>，因此可以</strong>使用<code>.then(res =&gt; )</code>的方式链式处理请求结果，这不仅提高了代码的可读性，还避免了回调地狱</strong>(<code>xhr</code>通过<code>xhr.onreadystatechange= () =&gt; &#123;&#125;</code>这样回调的方式监控请求状态，要是想在请求后再发送请求就要在回调函数内再发送请求，这样容易出现回调地狱)的问题。<strong>而且<code>JS</code>自带，语法也非常简洁，几行代码就能发起一个请求，用起来很方便</strong>，据说大佬都爱用。</p>
<p>它的特点是：</p>
<ul>
<li>使用 promise，不使用回调函数。</li>
<li>采用模块化设计，比如 rep、res 等对象分散开来，比较友好。</li>
<li>通过数据流对象处理数据，可以提高网站性能。</li>
</ul>
<p>下面我们简单写个fetch请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// get请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/get&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求错误！状态码为：&#x27;</span>, res.<span class="property">status</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">text</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;no-cors&#x27;</span>,  <span class="comment">// 设置cors表示只能发送跨域的请求，no-cors表示跨不跨域都能发</span></span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-axios"><a href="#3-axios" class="headerlink" title="3. axios"></a><strong>3. axios</strong></h5><p>axios是<strong>用于网络请求的第三方库，它是一个库</strong>。axios<strong>利用xhr进行了二次封装的请求库</strong>，xhr只是axios中的其中一个请求适配器，axios<strong>在nodejs端还有个http的请求适配器</strong>；axios &#x3D; xhr + http；它返回一个<code>Promise</code>。【项目中经常需要封装的axios】</p>
<p>它的特点：</p>
<ul>
<li>在浏览器环境中创建 XMLHttpRequests；在node.js环境创建 http 请求</li>
<li>返回Promise</li>
<li>拦截请求和响应</li>
<li>自动转换 JSON 数据</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
</ul>
<p>它的基础语法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 Get 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;  <span class="comment">// 查询query使用params</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送 Post 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;  <span class="comment">// 请求体body用data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面我们在vue项目中封装一个使用axios实现的请求。</p>
<p><code>libs/config.js</code>：配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;http://127.0.0.1:8000&quot;</span>, <span class="comment">// 请求基础地址，可根据环境自定义</span></span><br><span class="line">  <span class="attr">useTokenAuthentication</span>: <span class="literal">false</span>, <span class="comment">// 是否开启token认证</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> serverConfig;</span><br></pre></td></tr></table></figure>

<p><code>libs/request.js</code>：封装请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;  <span class="comment">// 第三方库 需要安装</span></span><br><span class="line"><span class="keyword">import</span> serverConfig <span class="keyword">from</span> <span class="string">&quot;./config&quot;</span>;</span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> apiClient = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: serverConfig.<span class="property">baseUrl</span>, <span class="comment">// 基础请求地址</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// 跨域请求是否需要携带cookie</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求发送前的处理逻辑 比如token认证，设置各种请求头啥的</span></span><br><span class="line">    <span class="comment">// 如果开启token认证</span></span><br><span class="line">    <span class="keyword">if</span> (serverConfig.<span class="property">useTokenAuthentication</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求头携带token</span></span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求发送失败的处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应数据处理逻辑，比如判断token是否过期等等</span></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应数据失败的处理逻辑</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; error.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (error.<span class="property">response</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">302</span>:</span><br><span class="line">          message = <span class="string">&quot;接口重定向了！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">          message = <span class="string">&quot;参数不正确！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          message = <span class="string">&quot;您未登录，或者登录已经超时，请先登录！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          message = <span class="string">&quot;您没有权限操作！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          message = <span class="string">`请求地址出错: <span class="subst">$&#123;error.response.config.url&#125;</span>`</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">          message = <span class="string">&quot;请求超时！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">409</span>:</span><br><span class="line">          message = <span class="string">&quot;系统已存在相同数据！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">          message = <span class="string">&quot;服务器内部错误！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">          message = <span class="string">&quot;服务未实现！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">          message = <span class="string">&quot;网关错误！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">          message = <span class="string">&quot;服务不可用！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">          message = <span class="string">&quot;服务暂时无法访问，请稍后再试！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">          message = <span class="string">&quot;HTTP 版本不受支持！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          message = <span class="string">&quot;异常问题，请联系管理员！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiClient;</span><br></pre></td></tr></table></figure>

<p><code>/api/index.js</code>：配置请求接口，这里一个get一个post</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> apiClient <span class="keyword">from</span> <span class="string">&quot;@/libs/request&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getInfo</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">apiClient</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/get&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    params,  <span class="comment">// axios的get请求query用params</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">postInfo</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">apiClient</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/post&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: params,  <span class="comment">// axios的post请求body用data</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  getInfo,</span><br><span class="line">  postInfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>：用于测试请求结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&#x27;./api/index.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">isH5</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">            api.<span class="title function_">getInfo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            api.<span class="title function_">postInfo</span>(&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/28.png"></p>
<h3 id="19-forEach和map方法有什么区别"><a href="#19-forEach和map方法有什么区别" class="headerlink" title="19.forEach和map方法有什么区别"></a>19.forEach和map方法有什么区别</h3><p>两个方法都是用来遍历循环数组，区别如下：</p>
<ul>
<li><code>forEach()</code>对数据的操作会改变原数组，该方法没有返回值；</li>
<li><code>map()</code>方法不会改变原数组的值，<strong>返回一个新数组</strong>，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h3 id="20-什么是尾调用，使用尾调用有什么好处？"><a href="#20-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="20.什么是尾调用，使用尾调用有什么好处？"></a>20.什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用就是在函数的<strong>最后一步调用函数</strong>，在一个函数里调用另外一个函数会<strong>保留当前执行的上下文</strong>，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，<strong>从而节省内存</strong>。但是ES6的尾调用只能在<strong>严格模式下开启</strong>，正常模式是无效的。</p>
<h3 id="21-用过哪些设计模式"><a href="#21-用过哪些设计模式" class="headerlink" title="21.用过哪些设计模式"></a>21.用过哪些设计模式</h3><p><strong>单例模式</strong>：保证类只有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>工厂模式</strong>：用来创建对象，根据不同的参数返回不同的对象实例。</p>
<p><strong>策略模式</strong>：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<p><strong>装饰器模式</strong>：在不改变对象原型的基础上，对其进行包装扩展。</p>
<p><strong>观察者模式</strong>：定义了对象间一种一对多关系，当目标对象状态发生改变时，所有依赖它对对象都会得到通知。</p>
<p><strong>发布订阅模式</strong>： 基于一个主题&#x2F;事件通道，希望接收通知的对象通过自定义事件订阅主题，被激活事件的对象（通过发布主题事件的方式被通知)。</p>
<h3 id="22-如何实现深浅拷贝"><a href="#22-如何实现深浅拷贝" class="headerlink" title="22.如何实现深浅拷贝"></a>22.如何实现深浅拷贝</h3><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>1.<code>JSON.stringify()</code>将js对象序列化，再通过<code>JSON.parse</code>反序列</p>
<ul>
<li>如果对象中有函数、<code>undefined</code>、<code>symbol</code>时，都会丢失</li>
<li>如果有正则表达式、<code>Error</code>对象等，会得到空对象</li>
</ul>
<p>2.递归方式</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><ul>
<li><code>Objec.assign()</code> 拷贝对象</li>
<li>扩展运算符</li>
</ul>
<h3 id="23-call-、bind（）、-apply-的区别？"><a href="#23-call-、bind（）、-apply-的区别？" class="headerlink" title="23.call() 、bind（）、 apply() 的区别？"></a>23.call() 、bind（）、 apply() 的区别？</h3><ul>
<li>都可以用作改变<code>this</code>指向</li>
<li><code>call</code>和<code>apply</code>的区别在于传参，<code>call</code>、<code>bind</code>都是传入对象。<code>apply</code>传入一个数组。</li>
<li><code>call</code>、<code>apply</code>改变<code>this</code>指向后会立即执行函数，<code>bind</code>在改变<code>this</code>后返回一个函数，不会立即执行函数，需要手动调用。</li>
</ul>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/33.png" alt="image-20240517214224245"></p>
<h5 id="连续多个-bind，最后this指向是什么？"><a href="#连续多个-bind，最后this指向是什么？" class="headerlink" title="连续多个 bind，最后this指向是什么？"></a>连续多个 bind，最后this指向是什么？</h5><p>在 <code>JavaScript</code> 中，连续多次调用 <code>bind</code> 方法，最终函数的 <code>this</code> 上下文是由<strong>第一次调用 bind 方法</strong>的参数决定的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = getName.<span class="title function_">bind</span>(obj1).<span class="title function_">bind</span>(obj2).<span class="title function_">bind</span>(obj3);</span><br><span class="line"><span class="title function_">fn1</span>(); <span class="comment">// 输出 &quot;obj1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="24-理解原型"><a href="#24-理解原型" class="headerlink" title="24.理解原型"></a>24.理解原型</h3><ul>
<li><strong>prototype</strong> : js通过构造函数来创建对象，每个构造函数内部都会一个原型<code>prototype</code>属性，它指向另外一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</li>
<li><em><strong>*proto*</strong></em>: 当使用构造函数创建一个实例对象后，可以通过<code>__proto__</code>访问到<code>prototype</code>属性。</li>
<li><strong>constructor</strong>：实例对象通过这个属性可以访问到构造函数</li>
</ul>
<h3 id="25-理解原型链"><a href="#25-理解原型链" class="headerlink" title="25.理解原型链"></a>25.理解原型链</h3><p>每个实例对象都有一个<code>__proto__</code>属性指向它的构造函数的原型对象，而这个原型对象也会有自己的原型对象，一层一层向上，直到顶级原型对象<code>null</code>，这样就形成了一个原型链。</p>
<p>当访问对象的一个属性或方法时，当对象身上不存在该属性方法时，就会沿着原型链向上查找，直到查找到该属性方法位置。</p>
<p>原型链的顶层原型是<code>Object.prototype</code>，如果这里没有就只指向<code>null</code></p>
<h3 id="26-对作用域、作用域链的理解"><a href="#26-对作用域、作用域链的理解" class="headerlink" title="26.对作用域、作用域链的理解"></a>26.对作用域、作用域链的理解</h3><p><strong>作用域</strong>是一个变量或函数的可访问范围，作用域控制着变量或函数的可见性和生命周期。</p>
<ol>
<li><strong>全局作用域</strong>：可以全局访问<ul>
<li>最外层函数和最外层定义的变量拥有全局作用域</li>
<li><code>window</code>上的对象属性方法拥有全局作用域</li>
<li>为定义直接复制的变量自动声明拥有全局作用域</li>
<li>过多的全局作用域变量会导致变量全局污染，命名冲突</li>
</ul>
</li>
<li><strong>函数作用域</strong>：只能在函数中访问使用<ul>
<li>在函数中定义的变量，都只能在内部使用，外部无法访问</li>
<li>内层作用域可以访问外层，外层不能访问内存作用域</li>
</ul>
</li>
<li>ES6中的<strong>块级作用域</strong>：只在代码块中访问使用<ul>
<li>使用ES6中新增的<code>let</code>、<code>const</code>声明的变量，具备块级作用域，块级作用域可以在函数中创建（由{}包裹的代码都是块级作用域）</li>
<li><code>let</code>、<code>const</code>申明的变量不会变量提升，<code>const</code>也不能重复声明</li>
<li>块级作用域主要用来解决由变量提升导致的变量覆盖问题</li>
</ul>
</li>
</ol>
<p><strong>作用域链：</strong> 变量在指定的作用域中没有找到，会依次向上一层作用域进行查找，直到全局作用域。这个查找的过程被称为作用域链。</p>
<h3 id="27-浏览器的垃圾回收机制"><a href="#27-浏览器的垃圾回收机制" class="headerlink" title="27.浏览器的垃圾回收机制"></a>27.浏览器的垃圾回收机制</h3><p><strong>垃圾回收</strong>：<code>JavaScript</code>代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。</p>
<p>在 V8 中，会把堆分为<strong>新生代和老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象：</p>
<ul>
<li><p>Major  GC(主垃圾回收器)</p>
<p>：主要负责老生代垃圾的回收</p>
<ul>
<li>内存占用比较小</li>
</ul>
</li>
<li><p>Minor GC(副垃圾回收器)</p>
<p>：主要负责新生代垃圾的回收</p>
<ul>
<li>对象的占用空间大  对象存活时间长</li>
</ul>
</li>
</ul>
<h5 id="新生代（副垃圾回收器）"><a href="#新生代（副垃圾回收器）" class="headerlink" title="新生代（副垃圾回收器）"></a>新生代（副垃圾回收器）</h5><p>副垃圾回收器主要负责新⽣代的垃圾回收。大多数的对象最开始都会被分配在新生代，该存储空间相对较小，分为两个空间：<strong>from 空间</strong>（对象区）和 <strong>to 空间</strong>（空闲区）。</p>
<ul>
<li>新增变量会放到<code>To</code>空间，当空间满后需要执行一次垃圾清理操作</li>
<li>对垃圾数据进行标记，标记完成后<strong>将存活的数据复制到From空间中</strong>，有序排列</li>
<li>交换两个空间，原来的<code>To</code>变成<code>From</code>，旧的<code>From</code>变成<code>To</code></li>
</ul>
<h5 id="老生代（主垃圾回收器）"><a href="#老生代（主垃圾回收器）" class="headerlink" title="老生代（主垃圾回收器）"></a>老生代（主垃圾回收器）</h5><p>主垃圾回收器主要负责⽼⽣代中的垃圾回收。存储一些占用空间大、存活时间长的数据，采用<strong>标记清除</strong>算法进行垃圾回收。</p>
<p>主要分为<strong>标记</strong>、<strong>清除</strong>两个阶段。</p>
<ul>
<li><strong>标记</strong>：将所有的变量打上标记0，然后从根节点(<code>window</code>对象、DOM树等)开始遍历，把存活的变量标记为1</li>
<li><strong>清除</strong>：清除标记为0的对象，释放内存。清除后将1的变量改为0，方便下一轮回收。</li>
</ul>
<p>对⼀块内存多次执⾏标记清除算法后，会<strong>产⽣⼤量不连续的内存碎⽚</strong>。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜引⼊了另外⼀种算法——<strong>标记整理</strong>。</p>
<p><strong>标记整理</strong>的标记过程仍然与标记清除算法⾥的是⼀样的，先标记可回收对象，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有<strong>存活的对象都向⼀端移动</strong>，然后直接清理掉这⼀端之外的内存。</p>
<h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>一个对象被引用一次，引用数就+1，反之就-1。当引用为0，就会出发垃圾回收。</p>
<p>这种方式会产生一个问题，在循环引用时，引用数永远不会为0，无法回收。</p>
<h5 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h5><ul>
<li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>被遗忘的计时器或回调函数：设置了 <code>setInterval</code> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>脱离 <code>DOM</code> 的引用：获取一个 <code>DOM</code> 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h2 id="手写代码篇"><a href="#手写代码篇" class="headerlink" title="手写代码篇"></a>手写代码篇</h2><h3 id="1-数组去重"><a href="#1-数组去重" class="headerlink" title="1.数组去重"></a>1.数组去重</h3><h5 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h5><p>Set 是 JavaScript 中一个内建的对象，它只允许存储唯一的值。利用这一特性，我们可以轻松实现数组去重。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArr);</span><br></pre></td></tr></table></figure>

<h5 id="使用-filter"><a href="#使用-filter" class="headerlink" title="使用 filter"></a>使用 filter</h5><p>你也可以使用数组的 <code>filter</code> 方法来实现去重。这个方法会遍历数组，并对每个元素执行一个测试函数，只有使测试函数返回 <code>true</code> 的元素才会被保留在新数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueArray</span>(<span class="params">arr</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === index);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];  </span><br><span class="line"><span class="keyword">const</span> unique = <span class="title function_">uniqueArray</span>(array);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unique); <span class="comment">// 输出: [1, 2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法在处理大数组时可能效率不高，这个方法本身的时间复杂度就是 O(n)</p>
<h5 id="使用-reduce"><a href="#使用-reduce" class="headerlink" title="使用 reduce"></a>使用 reduce</h5><p><code>reduce</code> 方法也可以用来实现数组去重。这个方法会遍历数组，并将每个元素归并成一个单一的结果。你可以利用这个结果来创建一个新数组，只包含唯一的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueArray</span>(<span class="params">arr</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!accumulator.<span class="title function_">includes</span>(current)) &#123;  </span><br><span class="line">      accumulator.<span class="title function_">push</span>(current);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> accumulator;  </span><br><span class="line">  &#125;, []);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];  </span><br><span class="line"><span class="keyword">const</span> unique = <span class="title function_">uniqueArray</span>(array);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unique); <span class="comment">// 输出: [1, 2, 3, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="2-js将数字每千分位用逗号隔开"><a href="#2-js将数字每千分位用逗号隔开" class="headerlink" title="2.js将数字每千分位用逗号隔开"></a>2.js将数字每千分位用逗号隔开</h3><p>使用<code>toLocaleString</code>方法将数字格式化为带有千分位逗号的字符串。这个方法会根据你所在地区的本地化设置来格式化数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1234567.89</span>;</span><br><span class="line"><span class="keyword">let</span> formattedNum = num.<span class="title function_">toLocaleString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(formattedNum);</span><br></pre></td></tr></table></figure>



<p>你可以为<code>toLocaleString</code>方法提供一个选项对象，明确指定你想要的语言环境（locale）。例如，如果你想要使用美国英语的格式（即使用逗号作为千分位分隔符，点作为小数点），你可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1234567.89</span>;  </span><br><span class="line"><span class="keyword">let</span> formattedNum = num.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-US&#x27;</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(formattedNum);  <span class="comment">// 输出 &quot;1,234,567.89&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="3-手写防抖和节流"><a href="#3-手写防抖和节流" class="headerlink" title="3.手写防抖和节流"></a>3.手写防抖和节流</h3><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">// 创建一个变量来存储计时器ID</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">             timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                 func.<span class="title function_">call</span>(<span class="variable language_">this</span>, delay);</span><br><span class="line">                 timer = <span class="literal">null</span>;</span><br><span class="line">             &#125;, <span class="number">2000</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (timer) <span class="keyword">return</span> timer;</span><br><span class="line">          timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-手写promise"><a href="#4-手写promise" class="headerlink" title="4.手写promise"></a>4.手写promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [];</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [];</span><br><span class="line">      <span class="keyword">let</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">let</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span>=&gt;</span><span class="title function_">fn</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulfilled,onRejected</span>) &#123;</span><br><span class="line">      onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">      onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">      <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">                <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">                <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(fn)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>,fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">          then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">reject</span>(e); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//resolve方法</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(val)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject方法</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">reject</span>(val)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//race方法 </span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        promises[i].<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">processData</span>(<span class="params">index,data</span>)&#123;</span><br><span class="line">      arr[index] = data;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">if</span>(i == promises.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(arr);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promises.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="title function_">processData</span>(i,data);</span><br><span class="line">        &#125;,reject);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">defer</span> = <span class="title class_">Promise</span>.<span class="property">deferred</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">    dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">      dfd.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Promise</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-手写深浅拷贝"><a href="#5-手写深浅拷贝" class="headerlink" title="5.手写深浅拷贝"></a>5.手写深浅拷贝</h3><h5 id="assign实现浅拷贝"><a href="#assign实现浅拷贝" class="headerlink" title="assign实现浅拷贝"></a>assign实现浅拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj !== <span class="title class_">Object</span> || obj === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;wwc&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="string">&#x27;21&#x27;</span>,</span><br><span class="line">    <span class="attr">favorite</span>:&#123;</span><br><span class="line">        <span class="attr">game</span>:<span class="string">&#x27;p系列&#x27;</span>,</span><br><span class="line">        <span class="attr">hobby</span>:<span class="string">&#x27;sleep&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">shallowCopy</span>(obj1);</span><br><span class="line">obj1.<span class="property">favorite</span>.<span class="property">hobby</span> = <span class="string">&#x27;eat&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);</span><br></pre></td></tr></table></figure>

<h5 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj,clonedObjects = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>)&#123;</span><br><span class="line"><span class="comment">// 如果 obj 为 null 或不是对象（包括基本数据类型），直接返回该值</span></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 检查对象是否已经被克隆过，以避免循环引用导致的无限递归</span></span><br><span class="line"><span class="keyword">if</span>(clonedObjects.<span class="title function_">has</span>(obj))&#123;</span><br><span class="line">    <span class="keyword">return</span> clonedObjects.<span class="title function_">get</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone;</span><br><span class="line"><span class="comment">//  如果 obj 是数组</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj))&#123;</span><br><span class="line">    clone = [];</span><br><span class="line">     <span class="comment">// 将原对象和克隆对象的引用存储在 WeakMap 中</span></span><br><span class="line">    clonedObjects,<span class="title function_">set</span>(obj,clone);</span><br><span class="line">    <span class="comment">// 递归克隆数组中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;obj.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        clone[i] = <span class="title function_">deepClone</span>(obj[i],clonedObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 obj 是普通对象</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">    clone = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将原对象和克隆对象的引用存储在 WeakMap 中</span></span><br><span class="line">    clonedObjects.<span class="title function_">set</span>(obj,clone);</span><br><span class="line">    <span class="comment">// 递归克隆对象的每个属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            clone[key] = <span class="title function_">deepClone</span>(obj[key],clonedObjects);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">4</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">deepClone</span>(original);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// 输出: &#123; a: 1, b: [2, 3], c: &#123; d: 4 &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy !== original); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">c</span> !== original.<span class="property">c</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy.<span class="property">b</span> !== original.<span class="property">b</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-手写ajax封装"><a href="#6-手写ajax封装" class="headerlink" title="6.手写ajax封装"></a>6.手写ajax封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, method</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="comment">//xhr.open(&#x27;请求方式&#x27;, &#x27;请求地址&#x27;, 是否异步)</span></span><br><span class="line">        <span class="comment">//初始化设置请求方法和url</span></span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        xhr.<span class="title function_">send</span>();</span><br><span class="line">        <span class="comment">//绑定事件，onreadystatechange,存储函数（或函数名）处理响应结果(每当 readyState 改变时，就会触发 onreadystatechange 事件,一共会触发 4 次,从 0 到 4)</span></span><br><span class="line">        <span class="comment">//readyState 属性存有 XMLHttpRequest 的状态信息</span></span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-交换a-b的值，不能用临时变量"><a href="#7-交换a-b的值，不能用临时变量" class="headerlink" title="7.交换a,b的值，不能用临时变量"></a>7.交换a,b的值，不能用临时变量</h3><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">[a,b] = [b,a];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br></pre></td></tr></table></figure>



<h3 id="8-new的实现"><a href="#8-new的实现" class="headerlink" title="8.new的实现"></a>8.new的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">obj,...args</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建一个空对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">//2.将这个新对象的内部原型链接到构造函数的prototype对象</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="comment">//3.将这个新对象作为this上下文，并调用构造函数</span></span><br><span class="line">    <span class="keyword">const</span> result = constructor.<span class="title function_">apply</span>(obj,...args);</span><br><span class="line">    <span class="comment">// 4. 如果构造函数返回的是一个对象，则返回这个对象；否则返回新创建的对象  </span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? <span class="attr">result</span>:obj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-数组的扁平化"><a href="#9-数组的扁平化" class="headerlink" title="9.数组的扁平化"></a>9.数组的扁平化</h3><h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;  </span><br><span class="line">       <span class="keyword">let</span> result = [];  </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;  </span><br><span class="line">           <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;  </span><br><span class="line">               result = result.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(arr[i]));  </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">               result.<span class="title function_">push</span>(arr[i]);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> result;  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   <span class="keyword">let</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]];  </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenArray</span>(nestedArray)); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h5 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatArray</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)))&#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatArray</span>(nestedArray));</span><br></pre></td></tr></table></figure>





<h3 id="10-函数柯里化"><a href="#10-函数柯里化" class="headerlink" title="10.函数柯里化"></a>10.函数柯里化</h3><p>JavaScript中，你可以通过创建一个返回函数的函数来实现这种链式调用的模式。这种模式通常被称为柯里化（Currying）的一种形式，尽管在这个例子中，我们并没有减少参数的数量，而是延迟了它们的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Linkadd</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Linkadd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Linkadd</span>.<span class="property">getsum</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Linkadd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">5</span>)(<span class="number">3</span>)(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">getsum</span>());</span><br></pre></td></tr></table></figure>



<p>在这个例子中，<code>add</code> 函数返回了一个名为 <code>innerAdd</code> 的内部函数。<code>innerAdd</code> 函数接受一个数字参数，将其加到 <code>sum</code> 变量上，然后返回自己。因此，你可以连续调用 <code>add(1)(2)(3)</code>，每次调用都会将新的数字添加到 <code>sum</code> 中。</p>
<p>需要注意的是，由于 <code>innerAdd</code> 是一个函数，如果你直接打印 <code>add(1)(2)(3)</code>，它将输出函数本身而不是结果。</p>
<p>一个更好的方法是提供一个方法来获取结果，在这个版本中，我们添加了一个 <code>getResult</code> 方法来获取结果，而不是覆盖 <code>toString</code>。这样，<code>innerAdd</code> 函数的行为就更加清晰和可预测了。</p>
<h3 id="11-实现类数组转化为数组"><a href="#11-实现类数组转化为数组" class="headerlink" title="11.实现类数组转化为数组"></a>11.实现类数组转化为数组</h3><h4 id="方法一：使用Array-prototype-slice-call"><a href="#方法一：使用Array-prototype-slice-call" class="headerlink" title="方法一：使用Array.prototype.slice.call()"></a><strong>方法一：使用<code>Array.prototype.slice.call()</code></strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>:<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;c&#x27;</span>,<span class="attr">length</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Array.prototype.slice.call()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ToArray</span>=(<span class="params">arrayLike</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> realArray = <span class="title class_">ToArray</span>(arrayLike);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(realArray); <span class="comment">// 输出 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="方法二：使用Array-from-方法"><a href="#方法二：使用Array-from-方法" class="headerlink" title="方法二：使用Array.from()方法"></a><strong>方法二：使用<code>Array.from()</code>方法</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Array.from()方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray3</span>(<span class="params">arrayLike</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> realArray3 = <span class="title function_">toArray3</span>(arrayLike);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(realArray3); <span class="comment">// 输出 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>



<h3 id="12-将js对象转化为树形结构"><a href="#12-将js对象转化为树形结构" class="headerlink" title="12.将js对象转化为树形结构"></a>12.将js对象转化为树形结构</h3><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">items, parentId = <span class="literal">null</span></span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> tree = [];  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> items) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (items[i].<span class="property">parentId</span> == parentId) &#123;  </span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">buildTree</span>(items, items[i].<span class="property">id</span>);  </span><br><span class="line">      <span class="keyword">if</span> (children.<span class="property">length</span>) &#123;  </span><br><span class="line">        items[i].<span class="property">children</span> = children;  </span><br><span class="line">      &#125;  </span><br><span class="line">      tree.<span class="title function_">push</span>(items[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> tree;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用上面的函数构建树  </span></span><br><span class="line"><span class="keyword">const</span> tree = <span class="title function_">buildTree</span>(items);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="哈希字典法"><a href="#哈希字典法" class="headerlink" title="哈希字典法"></a>哈希字典法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [  </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,  </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1.1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,  </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1.2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,  </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 2&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,  </span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 2.1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,  </span><br><span class="line">    <span class="comment">// ... 更多的项目  </span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">arrayToTree</span>(<span class="params">items</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> itemMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        itemMap[item.<span class="property">id</span>] = &#123; ...item,<span class="attr">children</span>:[]&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tree = [];</span><br><span class="line"></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;id,parentId &#125; = item;</span><br><span class="line">        <span class="keyword">const</span> treeItem = itemMap[id];</span><br><span class="line">        <span class="keyword">if</span>(parentId === <span class="literal">null</span>)&#123;</span><br><span class="line">            tree.<span class="title function_">push</span>(treeItem);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            itemMap[parentId].<span class="property">children</span>.<span class="title function_">push</span>(treeItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tree = <span class="title function_">arrayToTree</span>(items);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tree,<span class="literal">null</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>







<h3 id="13-用Promise实现图片的异步加载"><a href="#13-用Promise实现图片的异步加载" class="headerlink" title="13.用Promise实现图片的异步加载"></a>13.用Promise实现图片的异步加载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个加载图片的函数，返回一个Promise对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LoadImage</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>(); <span class="comment">// 创建一个新的Image对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当图片成功加载时，触发onload事件处理器</span></span><br><span class="line">        img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(img); <span class="comment">// 解析Promise，并传递加载的Image对象</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当图片加载失败时，触发onerror事件处理器</span></span><br><span class="line">        img.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error); <span class="comment">// 拒绝Promise，并传递错误对象</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        img.<span class="property">src</span> = url; <span class="comment">// 设置图片的src属性，开始加载图片</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用LoadImage函数来加载图片</span></span><br><span class="line"><span class="title class_">LoadImage</span>(<span class="string">&#x27;https://example.com/path/to/image.jpg&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(img); <span class="comment">// 将加载的图片追加到文档的body中</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载成功&#x27;</span>); <span class="comment">// 在控制台输出加载成功的消息</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 如果图片加载失败，在控制台输出错误信息</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="14-使用-setTimeout-实现-setInterval"><a href="#14-使用-setTimeout-实现-setInterval" class="headerlink" title="14.使用 setTimeout 实现 setInterval"></a>14.使用 setTimeout 实现 setInterval</h3><p><code>setInterval</code> 和 <code>setTimeout</code> 都是 JavaScript 中用于执行定时任务的函数，但它们的行为有所不同。<code>setInterval</code> 会按照指定的间隔不断重复执行某个函数，而 <code>setTimeout</code> 则只会在指定的时间后执行一次函数。</p>
<p>虽然 <code>setInterval</code> 已经提供了我们需要的定时重复执行的功能，但有时我们可能出于某种原因（比如对性能的优化或者更精确的控制）想要使用 <code>setTimeout</code> 来模拟 <code>setInterval</code> 的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">callback,delay</span>)&#123;</span><br><span class="line">    <span class="comment">//初始调用</span></span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归调用 setTimeout 来模拟 setInterval</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//清除前一个 setTimeout,防止在回调函数执行视觉较长时产生累计的延迟</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(intervalId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用 mySetInterval</span></span><br><span class="line">        <span class="title function_">mySetInterval</span>(callback,delay);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行回调函数</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">    &#125;,delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//s</span></span><br><span class="line"><span class="title function_">mySetInterval</span>(<span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,world&#x27;</span>),<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>







<h2 id="ES6篇"><a href="#ES6篇" class="headerlink" title="ES6篇"></a>ES6篇</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1.let、const、var的区别"></a>1.let、const、var的区别</h3><ul>
<li><p><strong>块级作用域：</strong></p>
<p> 块作用域由 { } 包裹，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>内层变量可能覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
</li>
<li><p><strong>变量提升：</strong> <code>var</code>存在变量提升，<code>let</code>和<code>const</code>不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
</li>
<li><p><strong>给全局添加属性：</strong> 浏览器的全局对象是<code>window</code>，<code>Node</code>的全局对象是<code>global</code>。<code>var</code>声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是<code>let</code>和<code>const</code>不会。</p>
</li>
<li><p><strong>重复声明：</strong> <code>var</code>声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。<code>const</code>和<code>let</code>不允许重复声明变量。</p>
</li>
<li><p><strong>初始值设置：</strong> 在变量声明时，<code>var </code>和<code>let</code>可以不用设置初始值。而<code>const</code>声明变量必须设置初始值。</p>
</li>
<li><p><strong>暂时性死区</strong>：在使用<code>let</code>、<code>const</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用<code>var</code>声明的变量不存在暂时性死区。</p>
</li>
</ul>
<h3 id="2-箭头函数与普通函数的区别"><a href="#2-箭头函数与普通函数的区别" class="headerlink" title="2.箭头函数与普通函数的区别"></a>2.箭头函数与普通函数的区别</h3><ul>
<li>箭头函数是<strong>匿名函数</strong>，不能作为构造函数，使用<code>new</code>关键字。</li>
<li>箭头函数没有<code>arguments</code></li>
<li>箭头函数没有自己的<code>this</code>，会获取所在的上下文作为自己的<code>this</code></li>
<li><code>call()</code>、<code>applay()</code>、<code>bind()</code>方法不能改变箭头函数中的<code>this</code>指向</li>
<li>箭头函数没有<code>prototype</code></li>
<li>箭头函数不能用作<code>Generator</code>函数，不能使用<code>yeild</code>关键字</li>
</ul>
<h3 id="3-Set、Map的区别"><a href="#3-Set、Map的区别" class="headerlink" title="3.Set、Map的区别"></a>3.Set、Map的区别</h3><p><strong>Set</strong></p>
<ul>
<li>创建：<code>  new Set([1, 1, 2, 3, 3, 4, 2])</code></li>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li><code>set(key, val):</code> 向<code>Map</code>中添加新元素</li>
<li><code>get(key):</code> 通过键值查找特定的数值并返回</li>
<li><code>has(key): </code>判断<code>Map</code>对象中是否有<code>Key</code>所对应的值，有返回<code>true</code>,否则返回<code>false</code></li>
<li><code>delete(key): </code>通过键值从<code>Map</code>中移除对应的数据</li>
<li><code>clear():</code> 将这个<code>Map</code>中的所有元素删除</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li><code>Map</code>是一种键值对的集合，和对象不同的是，键可以是任意值</li>
<li><code>Map</code>可以遍历，可以和各种数据格式转换</li>
<li><code>Set</code>是类似数组的一种的数据结构，类似数组的一种集合，但在Set中没有重复的值</li>
</ul>
<h3 id="4-map和Object的区别"><a href="#4-map和Object的区别" class="headerlink" title="4.map和Object的区别"></a>4.map和Object的区别</h3><p><code>map</code>和<code>Object</code>都是用键值对来存储数据，区别如下：</p>
<ul>
<li><strong>键的类型</strong>：<code>Map</code> 的键可以是<strong>任意数据类型</strong>（包括对象、函数、<code>NaN </code>等），而 <code>Object</code> 的键<strong>只能是字符串</strong>或者 <code>Symbol</code> 类型。</li>
<li><strong>键值对的顺序</strong>：<code>Map</code>中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。</li>
<li><strong>键值对的遍例</strong>：<code>Map</code> 的键值对可以使用 <code>for...of</code> 进行遍历，而 <code>Object</code> 的键值对需要手动遍历键值对。</li>
<li><strong>继承关系</strong>：<code>Map </code>没有继承关系，而 <code>Object</code> 是所有对象的基类。</li>
</ul>
<h3 id="5-map和weakMap的区别"><a href="#5-map和weakMap的区别" class="headerlink" title="5.map和weakMap的区别"></a>5.map和weakMap的区别</h3><p>它们是 <code>JavaScript</code> 中的两种不同的键值对集合，主要区别如下：</p>
<ol>
<li><code>map</code>的键可以是任意类型，<code>weakMap</code>键只能是对象类型。</li>
<li><code>map</code> 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，<code>map</code> 仍然会保留该键的内存。<code>weakMap</code> 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。</li>
</ol>
<h3 id="6-说说你对Promise的理解"><a href="#6-说说你对Promise的理解" class="headerlink" title="6.说说你对Promise的理解"></a>6.说说你对Promise的理解</h3><p><code>Promise</code>是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。</p>
<p><code>Promise</code>的实例有三个状态:</p>
<ul>
<li><code>Pending</code>（初始状态）</li>
<li><code>Fulfilled</code>（成功状态）</li>
<li><code>Rejected</code>（失败状态）</li>
</ul>
<p><code>Promise</code>的实例有两个过程：</p>
<ul>
<li><p><code>pending</code> -&gt; <code>fulfilled</code> : <strong>Resolved（已完成）</strong></p>
</li>
<li><p><code>pending</code> -&gt; <code>rejected</code>：<strong>Rejected（已拒绝）</strong></p>
<p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。</p>
</li>
</ul>
<p><code>Promise</code>构造函数接收一个带有<code>resolve</code>和<code>reject</code>参数的回调函数。</p>
<ul>
<li><code>resolve</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>fulfilled</code>，在异步操作成功时调用，并将异步结果返回，作为参数传递出去</li>
<li><code>reject</code>的作用是将<code>Promise</code>状态从<code>pending</code>变为<code>rejected</code>，在异步操作失败后，将异步操作错误的结果，作为参数传递出去</li>
</ul>
<p><code>Promise</code>的缺点：</p>
<ul>
<li>无法取消 <code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li>
<li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h3 id="7-Promise方法"><a href="#7-Promise方法" class="headerlink" title="7.Promise方法"></a>7.Promise方法</h3><ul>
<li><code>promise.then()</code>  对应<code>resolve</code>成功的处理</li>
<li><code>promise.catch()</code>对应<code>reject</code>失败的处理</li>
<li><code>promise.all()</code>可以完成并行任务，将多个<code>Promise</code>实例数组，包装成一个新的<code>Promise</code>实例，返回的实例就是普通的<code>Promise</code>。有一个失败，代表该<code>Primise</code>失败。当所有的子<code>Promise</code>完成，返回值时全部值的数组</li>
<li><code>promise.race()</code>类似<code>promise.all()</code>，区别在于有任意一个完成就算完成</li>
<li><code>promise.allSettled()</code> 返回一个在所有给定的 <code>promise</code> 都已经 <code>fulfilled</code> 或 <code>rejected</code> 后的 <code>promise</code> ，并带有一个对象数组，每个对象表示对应的<code>promise</code> 结果。</li>
</ul>
<h3 id="8-promise-all-和-promise-allsettled-区别"><a href="#8-promise-all-和-promise-allsettled-区别" class="headerlink" title="8.promise.all 和 promise.allsettled 区别"></a>8.promise.all 和 promise.allsettled 区别</h3><p><code>Promise.all()</code> 和 <code>Promise.allSettled()</code> 都是用来处理多个 <code>Promise</code> 实例的方法，它们的区别在于以下几点：</p>
<ul>
<li><strong>all:</strong> 只有当所有<code>Promise</code>实例都<code>resolve</code>后，才会<code>resolve</code>返回一个由所有<code>Promise</code>返回值组成的数组。如果有一个<code>Promise</code>实例<code>reject</code>，就会立即被拒绝，并返回拒绝原因。<code>all</code>是团队的成功才算，如果有一个人失败就算失败。</li>
<li><strong>allSettled：</strong> 等所有<code>Promise</code>执行完毕后，不管成功或失败， 都会吧每个<code>Promise</code>状态信息放到一个数组里面返回。</li>
</ul>
<h3 id="9-对async-await-的理解"><a href="#9-对async-await-的理解" class="headerlink" title="9.对async&#x2F;await 的理解"></a>9.对async&#x2F;await 的理解</h3><p>async&#x2F;await<code>其实是Generator 的语法糖，它能实现的效果都能用</code>then<code>链来实现，它是为优化</code>then<code>链而开发出来的。通过</code>async<code>关键字声明一个异步函数， </code>await <code>用于等待一个异步方法执行完成，并且会阻塞执行。 </code>async<code>函数返回的是一个 Promise 对象，如果在函数中</code>return<code> 一个变量，</code>async<code>会把这个直接量通过</code>Promise.resolve()<code>封装成</code>Promise<code>对象。如果没有返回值，返回</code>Promise.resolve(undefined)</p>
<h5 id="async-await对比Promise的优势"><a href="#async-await对比Promise的优势" class="headerlink" title="async&#x2F;await对比Promise的优势"></a>async&#x2F;await对比Promise的优势</h5><ul>
<li>代码可读性高，<code>Promise</code>虽然摆脱了回掉地狱，但自身的链式调用会影响可读性。</li>
<li>相对<code>Promise</code>更优雅，传值更方便。</li>
<li>对错误处理友好，可以通过<code>try/catch</code>捕获，<code>Promise</code>的错误捕获⾮常冗余</li>
</ul>
<h3 id="10-对ES6的理解"><a href="#10-对ES6的理解" class="headerlink" title="10.对ES6的理解"></a>10.对ES6的理解</h3><ul>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>箭头函数</li>
<li>模版字符串</li>
<li><code>Set</code>、<code>Map</code>集合</li>
<li>新增<code>class</code>类</li>
<li><code>Proxy</code></li>
<li><code>Promise</code></li>
</ul>
<h3 id="11-ES6模块和CommonJS模块有什么区别"><a href="#11-ES6模块和CommonJS模块有什么区别" class="headerlink" title="11.ES6模块和CommonJS模块有什么区别"></a>11.ES6模块和CommonJS模块有什么区别</h3><p>语法不同：<code>ES6 </code>模块使用 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块，而 <code>CommonJS</code> 模块使用 <code>require</code> 和 <code>module.exports</code> 或 <code>exports</code> 来导入和导出模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS 模块</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./commonjs&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>异步加载: <code>ES6</code> 模块支持动态导入（dynamic import），<strong>可以异步加载模块</strong>。这使得在需要时按需加载模块成为可能，从而提高了性能。<code>CommonJS</code> 模块在设计时没有考虑异步加载的需求，通常在模块的顶部进行同步加载。</li>
</ul>
<h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><h3 id="1-vue的常用的属性和指令有哪些？"><a href="#1-vue的常用的属性和指令有哪些？" class="headerlink" title="1.vue的常用的属性和指令有哪些？"></a>1.vue的常用的属性和指令有哪些？</h3><h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a><strong>属性</strong>：</h5><ul>
<li><code>data</code>：用于定义组件的初始数据。</li>
<li><code>props</code>：用于传递数据给子组件。</li>
<li><code>computed</code>：用于定义计算属性。</li>
<li><code>methods</code>：用于定义组件的方法。</li>
<li><code>watch</code>：用于监听组件的数据变化。</li>
<li><code>components</code>：用于注册子组件。可以通过 <code>components</code> 属性将其他组件注册为当前组件的子组件，从而在模板中使用这些子组件。</li>
</ul>
<h5 id="指令："><a href="#指令：" class="headerlink" title="指令："></a>指令：</h5><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>v-text 指令，会把该元素下面的所有内容替换掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-text=&quot;hello vue&quot;&gt;hello world&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>现实结果是：hello vue</p>
<h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>v-html 指令，会用一个HTML标签字符串，替换该元素下面的所有内容。</p>
<p>但是，不建议使用v-html指令，因为它会导致被恶意者进行XSS攻击的潜在风险。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-html=&quot;&#x27;&lt;span style=&amp;quot;color:red&amp;quot;&gt;hello vue&lt;/span&gt;&#x27;&quot;&gt;</span><br><span class="line"> </span><br><span class="line">  hello world</span><br><span class="line"> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>现实结果是：字体颜色为红色的 hello vue</p>
<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>v-show 指令，控制元素的显示隐藏，元素存在并占据空间。</p>
<p>元素隐藏时，相当于给该元素添加了 CSS 样式：display:none;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-show=&quot;show&quot;&gt;hello vue&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;button @click=&quot;show = !show&quot;&gt;changeShow&lt;/button&gt;</span><br></pre></td></tr></table></figure>



<h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>v-if 指令，控制元素是否加载。</p>
<p>v-esle-if&#x2F;v-else指令不能单独使用，必须配合v-if一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;number===1&quot;&gt;hello vue &#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div v-else-if=&quot;number===2&quot;&gt;hello world &#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;div v-else&gt;hello someone &#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>v-for 指令，for循环，基于源数据多次渲染元素或模板块。</p>
<p>v-for 既可以渲染一个数组，也可以渲染一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(item, idx) in [1, 2, 3]&quot; :key=&quot;idx&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 渲染的结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>



<h5 id="v-if-和v-for优先级"><a href="#v-if-和v-for优先级" class="headerlink" title="v-if 和v-for优先级"></a>v-if 和v-for优先级</h5><p>当 v-if 与 v-for 一起使用时：</p>
<p>在 vue2 中 v-for 比 v-if 有更高的优先级。这意味着 v-if 将分别重复运行于每个 v-for 循环中。<br>在 vue3 中 v-if 比 v-for 有更高的优先级。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名。</p>
<h5 id="v-for-的key"><a href="#v-for-的key" class="headerlink" title="v-for 的key"></a>v-for 的key</h5><p><strong>①、为什么需要给 v-for 设置 key？</strong></p>
<p>这牵扯到 vue 的 vnode 的 Diff 算法的特点</p>
<p><strong>②、在 v-for 中直接用 index 作为 key 的值有什么不好？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot; &gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        list: [</span><br><span class="line">        &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            name: &quot;Person1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            name: &quot;Person2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            id: 3,</span><br><span class="line">            name: &quot;Person3&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            id:4,</span><br><span class="line">            name:&quot;Person4&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>此时，删除 “Person4” 是正常的，但是如果我删除 “Person2” 就会出现问题。</p>
<p>删除前</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">index</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">Person1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">Person2</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">Person3</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">Person4</td>
</tr>
</tbody></table>
<p>删除后</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">index</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">Person1</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">Person3</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">2</td>
<td align="left">Person4</td>
</tr>
</tbody></table>
<p>可见，数组的 index 下标始终是从 0 开始依次递增不间断的，当其中某一项被删除后，被删节点之后的 index 下标会自动全部做减 1 更新。所以，删除了 id 是 2 的节点时，被删节点之后的 index 下标全部做减 1 更新了。所以，当 DOM 内容比较复杂时，建议设置并使用唯一的 id 属性，来作为 key 的值。</p>
<h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>v-on指令，可简写为“@”，绑定事件监听器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;number = number + 1&quot;&gt;number++&lt;/button&gt;</span><br></pre></td></tr></table></figure>





<h3 id="2-vue2的生命周期有哪些及每个生命周期做了什么？"><a href="#2-vue2的生命周期有哪些及每个生命周期做了什么？" class="headerlink" title="2.vue2的生命周期有哪些及每个生命周期做了什么？"></a>2.vue2的生命周期有哪些及每个生命周期做了什么？</h3><p><strong>创建前后：</strong></p>
<ul>
<li><code>beforeCreate（创建前）：</code> 数据观测和初始化事件还未开始，不能访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法。</li>
<li><code>created(创建后)：</code>实例创建完成，可以访问<code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code>上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。</li>
</ul>
<p><strong>挂载前后：</strong></p>
<ul>
<li><code>beforeMount（挂载前）:</code> Vue实例还未挂在到页面HTML上，此时可以发起服务器请求</li>
<li><code>mounted（挂载后）:</code>Vue实例已经挂在完毕，可以操作DOM</li>
</ul>
<p><strong>更新前后：</strong></p>
<ul>
<li><code>beforeUpdate（更新前）:</code> 数据更新之前调用，还未渲染页面</li>
<li><code>updated（更新后）:</code>DOM重新渲染，此时数据和界面都是新的。</li>
</ul>
<p><strong>销毁前后：</strong></p>
<ul>
<li><code>beforeDestorye（销毁前）:</code>实例销毁前调用，这时候能够获取到<code>this</code></li>
<li><code>destoryed（销毁后）:</code>实例销毁后调用，实例完全被销毁。</li>
</ul>
<h3 id="3-MVVM的理解"><a href="#3-MVVM的理解" class="headerlink" title="3.MVVM的理解"></a>3.MVVM的理解</h3><p><code>MVVM</code>是一种软件架构模式，<code>MVVM</code> 分为 <code>Model</code>、<code>View</code>、<code>ViewModel</code>：</p>
<ul>
<li><code>Model</code>代表数据模型，数据和业务逻辑都在<code>Model</code>层中定义；</li>
<li><code>View</code>代表UI视图，负责数据的展示；</li>
<li><code>ViewModel</code>负责监听<code>Model</code>中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p><code>Model</code>和<code>View</code>并无直接关联，而是通过<code>ViewModel</code>来进行联系的，<code>Model</code>和<code>ViewModel</code>之间有着双向数据绑定的联系。因此当<code>Model</code>中的数据改变时会触发<code>View</code>层的刷新，<code>View</code>中由于用户交互操作而改变的数据也会在<code>Model</code>中同步。</p>
<h3 id="4-vue和react的区别，有什么相同"><a href="#4-vue和react的区别，有什么相同" class="headerlink" title="4.vue和react的区别，有什么相同"></a>4.vue和react的区别，有什么相同</h3><p><strong>不同：</strong></p>
<ul>
<li>模版语法不同，<code>react</code>采用JSX语法，<code>vue</code>使用基于HTML的模版语法</li>
<li>数据绑定不同，<code>vue</code> 使用双向数据绑定，<code>react</code> 则需要手动控制组件的状态和属性。</li>
<li>状态管理不同，<code>vue</code>使用<code>vuex</code>状态管理，<code>react</code>使用<code>redux</code>状态管理</li>
<li>组件通信不同，<code>vue</code>使用<code>props</code>和事件的方式进行父子组件通信，<code>react</code>则通过<code>props</code>和回调函数的方式进行通信。</li>
<li>生命周期不同，<code>vue</code>有8个生命周期钩子，<code>react</code>有10个</li>
<li>响应式原理不同，<code>vue</code>使用双向绑定来实现数据更新，<code>react</code>则通过单向数据流来实现</li>
</ul>
<p><strong>相同</strong>：</p>
<ul>
<li><strong>组件化开发</strong>：<code>Vue</code> 和 <code>React</code> 都采用了组件化开发的方式，将用户界面划分为独立、可复用的组件，从而使代码更加模块化、可维护和可扩展。</li>
<li><strong>虚拟 DOM</strong>：<code>Vue</code> 和 <code>React</code> 都使用虚拟 DOM 技术，通过在 <code>JavaScript</code> 和真实 DOM 之间建立一个轻量级的虚拟 DOM 层，实现高效的 DOM 更新和渲染。</li>
<li><strong>响应式更新</strong>：<code>Vue</code> 和 <code>React</code> 都支持响应式更新，即当数据发生变化时，会自动更新相关的组件和视图，以保持用户界面的同步性。</li>
<li><strong>集成能力</strong>：<code>Vue</code> 和 <code>React</code> 都具有良好的集成能力，可以与其他库和框架进行整合，例如 <code>Vue</code> 可以与 <code>Vuex</code>、<code>Vue Router</code> 等配套使用，<code>React</code> 可以与 <code>Redux</code>、<code>React Router</code> 等配套使用。</li>
</ul>
<h3 id="5-Vue2和Vue3有哪些区别"><a href="#5-Vue2和Vue3有哪些区别" class="headerlink" title="5.Vue2和Vue3有哪些区别"></a>5.Vue2和Vue3有哪些区别</h3><ul>
<li><code>Vue2</code>使用的是<code>optionsAPI </code>，<code>Vue3</code>使用<code>composition API</code>，更好的组织代码，提高代码可维护性</li>
<li><code>Vue3</code>使用<code>Proxy</code>代理实现了新的响应式系统，比<code>Vue2</code>有着更好的性能和更准确的数据变化追踪能力。</li>
<li><code>Vue3</code>引入了Teleprot组件，可以将DOM元素渲染到DOM数的其他位置，用于创建模态框、弹出框等。</li>
<li><code>Vue3</code>全局API名称发生了变化，同时新增了<code>watchEffect</code>、<code>Hooks</code>等功能</li>
<li><code>Vue3</code>对<code>TypeScript</code>的支持更加友好</li>
<li><code>Vue3</code>核心库的依赖更少，减少打包体积</li>
<li>支持更好的<code>Tree Shikng</code>，可以更加精确的按需引入模块</li>
</ul>
<h3 id="6-SPA和多页面有什么区别"><a href="#6-SPA和多页面有什么区别" class="headerlink" title="6.SPA和多页面有什么区别"></a>6.SPA和多页面有什么区别</h3><p><strong>区别</strong></p>
<ul>
<li><strong>页面加载方式</strong>：在多页面应用中，每个页面都是独立的 HTML 文件，每次导航时需要重新加载整个页面。而在 <code>SPA</code> 中，初始加载时只加载一个 HTML 页面，后续的导航通过 <code>JavaScript</code> 动态地更新页面内容，无需重新加载整个页面。</li>
<li><strong>用户体验</strong>：<code>SPA</code> 提供了流畅、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。</li>
<li><strong>代码复用</strong>：<code>SPA</code> 通常采用组件化开发的方式，可以在不同的页面中复用组件，提高代码的可维护性和可扩展性。多页面应用的每个页面都是独立的，组件复用的机会较少。</li>
<li><strong>路由管理</strong>：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的 <code>URL</code>。而在 <code>SPA</code> 中，前端负责管理页面的导航和路由，通过前端路由库（如 <code>React Router</code> 或 <code>Vue Router</code>）来管理不同路径对应的组件。</li>
<li><strong>SEO（搜索引擎优化）</strong>：由于多页面应用的每个页面都是独立的 HTML 文件，搜索引擎可以直接索引和抓取每个页面的内容，有利于搜索引擎优化。相比之下，<code>SPA</code> 的内容是通过 <code>JavaScript</code> 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容，需要采取额外的优化措施。</li>
<li>服务器负载：<code>SPA</code> 只需初始加载时获取 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 文件，后续的页面更新和数据获取通常通过 API 请求完成，减轻了服务器的负载。而多页面应用每次导航都需要从服务器获取整个页面的内容。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>用户体验</strong>：<code>SPA</code> 提供了流畅、快速的用户体验，在页面加载后，只有需要的数据和资源会被加载，减少了页面刷新的延迟。</li>
<li><strong>响应式交互</strong>：由于 <code>SPA</code> 依赖于异步数据加载和前端路由，可以实现实时更新和动态加载内容，使用户可以快速地与应用程序交互。</li>
<li><strong>代码复用</strong>：<code>SPA</code> 通常采用组件化开发的方式，提高了代码的可维护性和可扩展性。</li>
<li><strong>服务器负载较低</strong>：由于只有初始页面加载时需要从服务器获取 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 文件，减轻了服务器的负载。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>首次加载时间</strong>：<code>SPA</code> 首次加载时需要下载较大的 <code>JavaScript</code> 文件，这可能导致初始加载时间较长。</li>
<li><strong>SEO（搜索引擎优化）问题</strong>：由于 <code>SPA</code> 的内容是通过 <code>JavaScript</code> 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容。</li>
<li><strong>内存占用</strong>：<code>SPA</code> 在用户浏览应用程序时保持单个页面的状态，这可能导致较高的内存占用。</li>
<li><strong>安全性</strong>：由于 <code>SPA</code> 通常使用 <code>API</code> 进行数据获取，因此需要特别注意安全性。</li>
</ul>
<h3 id="7-Vue的性能优化有哪些"><a href="#7-Vue的性能优化有哪些" class="headerlink" title="7.Vue的性能优化有哪些"></a>7.Vue的性能优化有哪些</h3><h5 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h5><ul>
<li><code>v-if</code>和<code>v-for</code>不一起使用</li>
<li><code>v-for</code>保证<code>key</code>的唯一性</li>
<li>使用<code>keep-alive</code>缓存组件</li>
<li><code>v-if</code>和<code>v-show</code>酌情使用</li>
<li>路由懒加载、异步组件</li>
<li>图片懒加载</li>
<li>节流防抖</li>
<li>第三方模块按需引入</li>
<li>服务端与渲染</li>
</ul>
<h5 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h5><ul>
<li>压缩代码</li>
<li>使用CDN加载第三方模块</li>
<li>抽离公共文件</li>
</ul>
<h5 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h5><ul>
<li>骨架屏</li>
<li>客户端缓存</li>
</ul>
<h5 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h5><ul>
<li>预渲染</li>
<li>服务端渲染</li>
<li>合理使用 <code>meta</code> 标签</li>
</ul>
<h3 id="8-Computed-和-Watch-的区别"><a href="#8-Computed-和-Watch-的区别" class="headerlink" title="8.Computed 和 Watch 的区别"></a>8.Computed 和 Watch 的区别</h3><p><code>computed</code>计算属性，通过对已有的属性值进行计算得到一个新值。它需要依赖于其他的数据，当数据发生变化时，<code>computed</code>会自动计算更新。<code>computed</code>属性值会被缓存，只有当依赖数据发生变化时才会重新计算，这样可以避免重复计算提高性能。</p>
<p><code>watch</code>用于监听数据的变化，并在变化时执行一些操作。它可以监听单个数据或者数组，当数据发生变化时会执行对应的回调函数，和<code>computed</code>不同的是<code>watch</code>不会有缓存。</p>
<h3 id="9-Vue组件通信"><a href="#9-Vue组件通信" class="headerlink" title="9.Vue组件通信"></a>9.Vue组件通信</h3><p>父传子</p>
<ul>
<li>props</li>
<li>$children</li>
<li>$refs</li>
</ul>
<p>子传父</p>
<ul>
<li>$emit</li>
<li>$parent</li>
</ul>
<p>兄弟组件</p>
<ul>
<li>provied</li>
<li>inject</li>
<li>eventBus</li>
<li>Vuex</li>
</ul>
<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10.常见的事件修饰符及其作用"></a>10.常见的事件修饰符及其作用</h3><ul>
<li><code>.stop</code>阻止冒泡</li>
<li><code>.prevent</code>阻止默认事件</li>
<li><code>.capture</code> 与事件冒泡的方向相反，事件捕获由外到内；</li>
<li>.<code>self</code> 只会触发自己范围内的事件，不包含子元素；</li>
<li><code>.once</code>只会触发一次。</li>
</ul>
<h3 id="11-v-if和v-show的区别"><a href="#11-v-if和v-show的区别" class="headerlink" title="11.v-if和v-show的区别"></a>11.v-if和v-show的区别</h3><p><code>v-if</code>元素不可见，直接删除DOM，有更高的切换消耗。 </p>
<p><code>v-show</code>通过设置元素<code>display: none</code>控制显示隐藏，更高的初始渲染消耗。</p>
<h3 id="12-Vue中data为什么是一个函数而不是对象"><a href="#12-Vue中data为什么是一个函数而不是对象" class="headerlink" title="12.Vue中data为什么是一个函数而不是对象"></a>12.Vue中data为什么是一个函数而不是对象</h3><p>因为对象是一个引用类型，如果<code>data</code>是一个对象的情况下会造成多个组件共用一个<code>data</code>，<code>data</code>为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p>
<h3 id="13-mixin-和-mixins-区别"><a href="#13-mixin-和-mixins-区别" class="headerlink" title="13.mixin 和 mixins 区别"></a>13.mixin 和 mixins 区别</h3><ul>
<li><strong><code>mixin</code></strong> 是一个包含可复用代码块的对象，可以包含数据、方法、生命周期钩子等。</li>
<li><strong><code>mixins</code></strong> 是 Vue 组件选项中的一个数组属性，用于指定一个或多个 mixin 对象，从而将这些 mixin 混入组件中。</li>
</ul>
<h5 id="mixin的选项合并（核心概念）"><a href="#mixin的选项合并（核心概念）" class="headerlink" title="mixin的选项合并（核心概念）"></a>mixin的选项合并（核心概念）</h5><ul>
<li>什么是选项合并：</li>
</ul>
<p><code>（面试问题）</code>当组件和混⼊对象含有同名选项时，这些选项将以恰当的⽅式进⾏“合并”。</p>
<h6 id="1-混入的数据存在冲突时"><a href="#1-混入的数据存在冲突时" class="headerlink" title="1.混入的数据存在冲突时"></a>1.混入的数据存在冲突时</h6><p>数据对象在内部会进⾏递归合并，并在发⽣冲突时以组件数据优先。</p>
<h6 id="2-混入的生命周期存在冲突时"><a href="#2-混入的生命周期存在冲突时" class="headerlink" title="2.混入的生命周期存在冲突时"></a>2.混入的生命周期存在冲突时</h6><p>同名钩子函数将合并为一个数组，因此都将被调用。 另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p>
<h6 id="3-混入的方法存在冲突时"><a href="#3-混入的方法存在冲突时" class="headerlink" title="3.混入的方法存在冲突时"></a>3.混入的方法存在冲突时</h6><p>值为对象的选项，将被合并为同一个对象。 例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>。</p>
<p>两个对象键名冲突时，取组件对象的键值对。（2个同名的方法，取组件内的而不是mixins中的）</p>
<h5 id="mixin的缺点"><a href="#mixin的缺点" class="headerlink" title="mixin的缺点"></a>mixin的缺点</h5><h6 id="1-变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。"><a href="#1-变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。" class="headerlink" title="1.变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。"></a>1.变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。</h6><p>组件里可以引入多个mixin，并直接隐式调用mixin里的变量&#x2F;方法，这会让我们有时候混乱，区分不出这些变量和方法 分别是哪个mixin里的？</p>
<h6 id="2-多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。"><a href="#2-多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。" class="headerlink" title="2.多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。"></a>2.多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。</h6><p>比如组件1中的方法要输出属性info，<br>但是组件2中也有同名属性info，且覆盖了组件1中的属性info，<br>那么当执行组件1中的方法时，输出的却是组件2中的属性，<br>这个我们可以避免，但是一不小心就会导致冲突，很容易制造混乱。</p>
<h6 id="3-mixins和组件可能出现多对多的关系，复杂度较高"><a href="#3-mixins和组件可能出现多对多的关系，复杂度较高" class="headerlink" title="3.mixins和组件可能出现多对多的关系，复杂度较高"></a>3.mixins和组件可能出现多对多的关系，复杂度较高</h6><p>即一个组件可以引用多个mixins，一个mixins也可以被多个组件引用。</p>
<p>示例一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 mixin 对象</span></span><br><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">mixinData</span>: <span class="string">&#x27;这是来自 mixin 的数据&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mixin 的 created 钩子被调用&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">mixinMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是来自 mixin 的方法&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mixin 的组件</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">componentData</span>: <span class="string">&#x27;这是组件自己的数据&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件的 created 钩子被调用&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">componentMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是组件自己的方法&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mixinA = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mixinA 的 created 钩子&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mixinB = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mixinB 的 created 钩子&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多个 mixin 的组件</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [mixinA, mixinB],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件的 created 钩子&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="14-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#14-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="14.使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>14.使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在 Vue 2 中，<code>Object.defineProperty()</code> 被用于实现数据劫持（reactive data binding），使得数据变动时能够触发更新。然而，<code>Object.defineProperty()</code> 存在一些局限性和缺点，这些缺点是促使 Vue 3 采用 Proxy 实现响应式系统的原因之一。以下是 <code>Object.defineProperty()</code> 的主要缺点：</p>
<h5 id="1-无法监听数组索引的变动"><a href="#1-无法监听数组索引的变动" class="headerlink" title="1. 无法监听数组索引的变动"></a>1. 无法监听数组索引的变动</h5><p><code>Object.defineProperty()</code> 无法直接监听数组索引的变动。例如，通过索引直接修改数组元素或改变数组长度，这些操作不会触发相应的 setter，从而无法响应这些变化。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">items</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;items&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Items changed&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.<span class="property">items</span>[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 不会触发 setter</span></span><br><span class="line">data.<span class="property">items</span>.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// 不会触发 setter</span></span><br></pre></td></tr></table></figure>

<h5 id="2-无法检测新增或删除属性"><a href="#2-无法检测新增或删除属性" class="headerlink" title="2. 无法检测新增或删除属性"></a>2. 无法检测新增或删除属性</h5><p><code>Object.defineProperty()</code> 只能劫持对象已有的属性，对于动态添加的新属性或删除的属性，无法进行劫持和检测。这意味着对对象的属性添加或删除操作不会自动触发视图更新。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name changed&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 无法检测到新增属性</span></span><br><span class="line"><span class="keyword">delete</span> data.<span class="property">name</span>; <span class="comment">// 无法检测到删除属性</span></span><br></pre></td></tr></table></figure>

<h5 id="3-手动递归劫持"><a href="#3-手动递归劫持" class="headerlink" title="3. 手动递归劫持"></a>3. 手动递归劫持</h5><p>为了使整个对象的所有属性都响应式，需要手动递归遍历每个属性并对其进行劫持，处理深层嵌套的对象非常麻烦，容易导致性能问题。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// getter logic</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">          <span class="comment">// setter logic</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">reactive</span>(obj[key]); <span class="comment">// 递归</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">nested</span>: &#123; <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="title function_">reactive</span>(data);</span><br></pre></td></tr></table></figure>

<h5 id="4-性能问题"><a href="#4-性能问题" class="headerlink" title="4. 性能问题"></a>4. 性能问题</h5><p>对于大型对象，递归遍历和劫持所有属性会导致初始化性能较差。每次属性访问都需要通过 getter 和 setter 拦截，增加了访问开销。</p>
<h5 id="Vue-3-中的改进：Proxy"><a href="#Vue-3-中的改进：Proxy" class="headerlink" title="Vue 3 中的改进：Proxy"></a>Vue 3 中的改进：Proxy</h5><p>为了克服上述缺点，Vue 3 采用了 <code>Proxy</code> 来实现响应式系统。<code>Proxy</code> 可以监听和拦截几乎所有对象的操作，包括属性读取、写入、删除、新增等，具有更强的灵活性和性能优势。</p>
<p><strong>Proxy 的优势</strong>：</p>
<ol>
<li><strong>监听数组索引变动</strong>：<code>Proxy</code> 可以监听数组索引的变动和长度变化。</li>
<li><strong>检测新增和删除属性</strong>：<code>Proxy</code> 可以拦截对象属性的添加和删除操作。</li>
<li><strong>无需递归</strong>：<code>Proxy</code> 可以在属性访问时动态拦截，无需在初始化时递归遍历所有属性。</li>
<li><strong>性能更好</strong>：对于大型对象，<code>Proxy</code> 提供了更好的性能，避免了初始化时的深度遍历。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">items</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyData = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line">proxyData.<span class="property">items</span>[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 触发 set 拦截器</span></span><br><span class="line">proxyData.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 触发 set 拦截器</span></span><br><span class="line"><span class="keyword">delete</span> proxyData.<span class="property">name</span>; <span class="comment">// 触发 deleteProperty 拦截器</span></span><br></pre></td></tr></table></figure>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>Object.defineProperty()</code> 在 Vue 2 中的使用有其局限性，包括无法监听数组索引变动、无法检测属性新增或删除、需要手动递归劫持、性能问题和维护复杂性。Vue 3 通过使用 <code>Proxy</code> 来实现更强大和灵活的响应式系统，有效解决了这些问题，提高了代码的可维护性和性能。</p>
<h3 id="15-Vue是如何收集依赖的？"><a href="#15-Vue是如何收集依赖的？" class="headerlink" title="15.Vue是如何收集依赖的？"></a>15.Vue是如何收集依赖的？</h3><p>依赖收集发生在<code>defineReactive()</code>方法中，在方法内<code>new Dep()</code>实例化一个<code>Dep()</code>实例，然后在<code>getter</code>中通过<code>dep.depend()</code>方法对数据依赖进行收集，然后在<code>settter</code>中通过<code>dep.notify()</code>通知更新。整个<code>Dep</code>其实就是一个观察者，把收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个<code>Watcher</code>，当数据发生改变通知每个<code>Watcher</code>，由<code>Wathcer</code>进行更新渲染。</p>
<h3 id="16-slot是什么？有什么作用？原理是什么？"><a href="#16-slot是什么？有什么作用？原理是什么？" class="headerlink" title="16.slot是什么？有什么作用？原理是什么？"></a>16.slot是什么？有什么作用？原理是什么？</h3><p><code>slot</code>插槽，一般在封装组件的时候使用，在组件内不知道以那种形式来展示内容时，可以用<code>slot</code>来占据位置，最终展示形式由父组件以内容形式传递过来，主要分为三种：</p>
<ul>
<li><strong>默认插槽</strong>：又名匿名插槽，当<code>slot</code>没有指定<code>name</code>属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li><strong>具名插槽</strong>：带有具体名字的插槽，也就是带有<code>name</code>属性的<code>slot</code>，一个组件可以出现多个具名插槽。</li>
<li><strong>作用域插槽</strong>：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件<code>vm</code>实例化时，获取到父组件传入的<code>slot</code>标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到<code>slot</code>标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="17双向数据绑定的原理"><a href="#17双向数据绑定的原理" class="headerlink" title="17双向数据绑定的原理"></a>17双向数据绑定的原理</h3><p>采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，<code>data</code>数据在初始化的时候，会实例化一个<code>Observe</code>类，在它会将<code>data</code>数据进行递归遍历，并通过<code>Object.defineProperty</code>方法，给每个值添加上一个<code>getter</code>和一个<code>setter</code>。在数据读取的时候会触发<code>getter</code>进行依赖（Watcher）收集，当数据改变时，会触发<code>setter</code>，对刚刚收集的依赖进行触发，并且更新<code>watcher</code>通知视图进行渲染。</p>
<h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18.$nextTick 原理及作用"></a>18.$nextTick 原理及作用</h3><p><code>$nextTick</code> 是一个常用的方法，它的主要作用是确保在下一次 DOM 更新循环结束后执行一个回调函数。这对于在数据变化后立即获取更新后的 DOM 状态非常有用。以下是对 <code>$nextTick</code> 的详细解释，包括其原理及作用。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li><strong>确保在 DOM 更新后执行代码</strong>: 当 Vue 中的数据发生变化时，DOM 更新是异步的，Vue 会在下一个事件循环中进行批量更新。<code>$nextTick</code> 可以确保在数据更新并且 DOM 重新渲染后执行某些操作。</li>
<li><strong>访问更新后的 DOM 元素</strong>: 在一些情况下，需要在数据更新后立即对 DOM 元素进行操作，例如获取元素的高度、宽度，或是执行某些与 DOM 相关的操作。使用 <code>$nextTick</code> 可以确保这些操作在 DOM 更新完成后执行。</li>
</ol>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">updateMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Hello Vue.js!&#x27;</span>;</span><br><span class="line">      <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 确保 DOM 更新完成后执行</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">messageRef</span>.<span class="property">textContent</span>); <span class="comment">// 获取更新后的 DOM 内容</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;messageRef&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateMessage&quot;</span>&gt;</span>Update Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，当 <code>updateMessage</code> 方法被调用时，<code>message</code> 的值会改变，但由于 DOM 更新是异步的，如果立即访问 <code>this.$refs.messageRef.textContent</code>，可能会得到更新前的内容。通过 <code>$nextTick</code> 确保在 DOM 更新完成后访问 DOM 元素。</p>
<h3 id="19-Vue中怎么重置data？"><a href="#19-Vue中怎么重置data？" class="headerlink" title="19.Vue中怎么重置data？"></a>19.Vue中怎么重置data？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Oject</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>.<span class="property">$data</span>,<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="title function_">data</span>())</span><br></pre></td></tr></table></figure>

<p><code>this.$data </code> 是获取当前状态下的data  </p>
<p><code>this.$options.data() </code>是获取该组件初始状态下的data  </p>
<p><code>Object.assign </code>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象  </p>
<h3 id="20-Vue中data的属性可以和methods中的方法同名吗？为什么？"><a href="#20-Vue中data的属性可以和methods中的方法同名吗？为什么？" class="headerlink" title="20.Vue中data的属性可以和methods中的方法同名吗？为什么？"></a>20.Vue中data的属性可以和methods中的方法同名吗？为什么？</h3><p>不可以。在initState的时候，会对data中的属性、props、methods的属性名进行检查。出现同名会立即警告</p>
<p>源码 中的 <strong>initData()</strong> 方法  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123; <span class="title function_">warn</span>(<span class="string">` Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>, vm ) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会取出 methods 中的方法进行判断，也就是 hasOwn(methods, key)  </p>
<p>如果此 key 值 在 methods 中存在，会有warn 警告</p>
<p>为什么会先执行data中的呢？因为是先init data的</p>
<h3 id="21-对keep-alive的理解"><a href="#21-对keep-alive的理解" class="headerlink" title="21.对keep-alive的理解"></a>21.对keep-alive的理解</h3><p>keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在页面渲染完毕后不会被渲染成一个DOM元素，所以再次回到上一个页面，该页面状态会保持，不会重新渲染。</p>
<ul>
<li><code>include</code> 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li><code>exclude</code> 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li><code>max</code> 数字，最多可以缓存多少组件实例。</li>
</ul>
<p><strong>2 个生命周期 activated ， deactivated</strong></p>
<ul>
<li><code>activated</code>：当缓存的组件被激活时，该钩子函数被调用。可以在该钩子函数中进行一些状态恢复、数据更新等操作。</li>
<li><code>deactivated</code>：当缓存的组件被停用时，该钩子函数被调用。可以在该钩子函数中进行一些状态保存、数据清理等操作。</li>
</ul>
<p>。</p>
<h3 id="22-v-for循环中key有什么作用"><a href="#22-v-for循环中key有什么作用" class="headerlink" title="22.v-for循环中key有什么作用"></a>22.v-for循环中key有什么作用</h3><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较。</p>
<p><strong>对比规则</strong>：<br>(1)旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p>
<p>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<p>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到到页面。</p>
<p>用index作为key可能会引发的问题:若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<p>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p>
<p>在 Vue 的 v-for 循环中，key 是一个特殊的属性，用于指定每个被迭代的元素的唯一标识。它的<strong>作用</strong>有以下几个方面：</p>
<p><strong>作用高效的更新策略</strong></p>
<p>​	key 的主要作用是帮助 Vue 在进行列表渲染时，识别每个元素的身份。Vue 使用 key 来跟踪每个节点的身份，从而在进行列表更新时，尽可能地复用和更新现有的 DOM 节点，减少不必要的 DOM 操作，提高性能。</p>
<p><strong>维持组件状态在使用 v-for 渲染组件列表时，每个组件都是独立存在的，拥有自己的状态</strong>。</p>
<p>​	使用 key 可以确保在列表更新时，每个组件都能保持自己的状态，而不会出现错位或混淆的情况。</p>
<p><strong>提供可靠的唯一性</strong></p>
<p>​	使用具有唯一性的 key 可以避免在列表中存在相同的项或出现重复的项。它帮助 Vue 在循环中区分不同的元素，确保每个元素都有一个独特的标识</p>
<h3 id="23-vue如何监听键盘事件"><a href="#23-vue如何监听键盘事件" class="headerlink" title="23.vue如何监听键盘事件"></a>23.vue如何监听键盘事件</h3><ol>
<li><p><code>@keyup.</code>  事件修饰符方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;myInput&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hello world&quot;</span> <span class="attr">autofocus</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;handleKey&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>




<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input ref=&quot;myInput&quot; type=&quot;text&quot; value=&quot;hello world&quot; autofocus @keyup.enter=&quot;handleKey&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> methods: &#123;</span><br><span class="line"> handleKey(e) &#123;</span><br><span class="line"> console.log(e)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>addEventListener</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> mounted() &#123;</span><br><span class="line"> document.addEventListener(&#x27;keyup&#x27;, this.handleKey)</span><br><span class="line"> &#125;,</span><br><span class="line"> beforeDestroy() &#123;</span><br><span class="line"> document.removeEventListener(&#x27;keyup&#x27;, this.handleKey)</span><br><span class="line"> &#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line"> handleKey(e) &#123;</span><br><span class="line"> console.log(e)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="24-你知道v-model的原理吗？"><a href="#24-你知道v-model的原理吗？" class="headerlink" title="24.你知道v-model的原理吗？"></a>24.你知道v-model的原理吗？</h3><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/1.png"></p>
<h3 id="25-vue首页白屏是什么问题引起的？如何解决呢？"><a href="#25-vue首页白屏是什么问题引起的？如何解决呢？" class="headerlink" title="25.vue首页白屏是什么问题引起的？如何解决呢？"></a>25.vue首页白屏是什么问题引起的？如何解决呢？</h3><p>打包优化 路由懒加载 代码压缩 第三方插件按需加载</p>
<p>在考虑性能优化方面，可以采取以下方法来减少 Vue 应用程序的首页白屏时间：</p>
<ol>
<li><p><strong>代码分割和懒加载</strong>：将应用程序拆分为更小的模块，并使用 Vue 的异步组件功能或者动态 import 来实现懒加载，这样可以减少首次加载时需要下载的代码量，加快页面渲染速度。</p>
</li>
<li><p><strong>路由懒加载</strong>：对于使用了 Vue 路由的应用程序，可以将路由配置进行懒加载，只在需要时加载对应的组件，而不是一次性加载所有路由组件。</p>
</li>
<li><p><strong>代码压缩和混淆</strong>：使用工具（如 Webpack）对代码进行压缩和混淆，减小文件大小，加快资源加载速度。</p>
</li>
<li><p><strong>图片优化</strong>：对于页面中的图片资源，使用适当的压缩和优化方法，减小图片文件大小，从而减少页面加载时间。</p>
</li>
<li><p><strong>缓存优化</strong>：合理使用浏览器缓存和服务端缓存，减少重复请求，加快页面加载速度。</p>
</li>
<li><p><strong>CDN 加速</strong>：将静态资源部署到 CDN 上，利用 CDN 的分布式网络加速资源加载，提高页面加载速度。</p>
</li>
<li><p><strong>减少 HTTP 请求</strong>：尽量减少页面需要发起的 HTTP 请求，合并和精简资源文件，减少页面加载时间。</p>
</li>
<li><p><strong>服务端渲染（SSR）</strong>：对于需要 SEO 优化或者有较高首屏渲染要求的应用程序，考虑使用服务端渲染来提高页面加载性能和搜索引擎索引效果。</p>
</li>
</ol>
<p>通过综合使用这些方法，可以有效减少 Vue 应用程序的首页白屏时间，提升用户体验和性能表现。</p>
<h3 id="26-CDN加速"><a href="#26-CDN加速" class="headerlink" title="26.CDN加速"></a>26.CDN加速</h3><p>当使用 CDN（内容分发网络）加速 Vue 应用程序时，可以将静态资源（如 JavaScript 文件、CSS 文件、图片等）部署到 CDN 上，从而利用 CDN 的分布式网络加速资源加载，提高页面加载速度。</p>
<p>举个例子，假设你的 Vue 应用程序包含以下静态资源：</p>
<ol>
<li><strong>JavaScript 文件</strong>：<code>app.js</code></li>
<li><strong>CSS 文件</strong>：<code>styles.css</code></li>
<li><strong>图片文件</strong>：<code>logo.png</code></li>
</ol>
<p>你可以将这些静态资源上传到一个 CDN 服务提供商（如 Cloudflare、Amazon CloudFront、Azure CDN 等）上，并获得对应的 CDN 地址，例如：</p>
<ul>
<li>JavaScript 文件的 CDN 地址：<code>https://cdn.example.com/app.js</code></li>
<li>CSS 文件的 CDN 地址：<code>https://cdn.example.com/styles.css</code></li>
<li>图片文件的 CDN 地址：<code>https://cdn.example.com/logo.png</code></li>
</ul>
<p>然后，在 Vue 应用程序的 HTML 文件中，将这些静态资源的链接指向 CDN 地址，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.example.com/styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.example.com/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，在用户访问你的 Vue 应用程序时，静态资源会通过 CDN 进行加速，从最接近用户的 CDN 节点进行传输，而不是直接从你的服务器加载，从而减少了网络延迟，加快了资源加载速度，提高了页面加载性能。</p>
<h3 id="27-服务端渲染（SSR）"><a href="#27-服务端渲染（SSR）" class="headerlink" title="27.服务端渲染（SSR）"></a>27.服务端渲染（SSR）</h3><p>以下是一个完整的例子，展示如何在 Vue 应用程序中使用服务端渲染：</p>
<ol>
<li><p><strong>创建 Vue 应用程序</strong>：首先，创建一个 Vue 应用程序，例如使用 Vue CLI 来初始化一个新项目。</p>
</li>
<li><p><strong>配置服务器端入口</strong>：在项目中创建服务器端入口文件，通常命名为 <code>server.js</code>，并使用 Vue Server Renderer 实现服务器端渲染。以下是一个简单的示例：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-server-renderer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> template = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./index.template.html&#x27;</span>), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">&#x27;./dist/server-bundle.json&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">&#x27;./dist/client-manifest.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="title function_">createBundleRenderer</span>(serverBundle, &#123;</span><br><span class="line">  <span class="attr">runInNewContext</span>: <span class="literal">false</span>,</span><br><span class="line">  template,</span><br><span class="line">  clientManifest</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123; <span class="attr">url</span>: req.<span class="property">url</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="keyword">await</span> renderer.<span class="title function_">renderToString</span>(context);</span><br><span class="line">    res.<span class="title function_">send</span>(html);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Internal Server Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">3000</span>;</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server running on port <span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>创建模板文件</strong>：创建一个 HTML 模板文件 <code>index.template.html</code>，用于包裹 Vue 应用程序的内容，并提供一个占位符用于 Vue Server Renderer 插入渲染后的 HTML。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.template.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue SSR App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里可以插入一些通用的 meta 标签、样式表等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里是 Vue 应用程序的根节点 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Vue Server Renderer 会将渲染后的 HTML 插入到这个 div 中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; APP &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里可以插入一些通用的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>构建应用程序</strong>：使用 Vue CLI 或其他构建工具来构建 Vue 应用程序。确保生成的客户端和服务器端的 bundle 文件。</p>
</li>
<li><p><strong>运行服务器端</strong>：在终端中运行服务器端代码 <code>node server.js</code>，启动服务器。</p>
</li>
</ol>
<p>通过以上步骤，你的 Vue 应用程序就会在服务器端进行渲染，并将渲染后的 HTML 页面发送给客户端。这样客户端收到的就是一个已经包含了初始内容的完整 HTML 页面，而不是一个空白的页面，从而提高了首屏加载速度和 SEO 效果。</p>
<h3 id="28-vue-router是用来做什么的？它有哪些组件？"><a href="#28-vue-router是用来做什么的？它有哪些组件？" class="headerlink" title="28.vue-router是用来做什么的？它有哪些组件？"></a>28.vue-router是用来做什么的？它有哪些组件？</h3><p>vue-router路由，通俗来讲主要是来实现页面的跳转，通过设置不同的path，向服务器发送的不同的请求，获取不同的资源。<br>主要组件：router-view、router-link</p>
<h3 id="29-vue-router钩子函数有哪些？都有哪些参数？"><a href="#29-vue-router钩子函数有哪些？都有哪些参数？" class="headerlink" title="29.vue-router钩子函数有哪些？都有哪些参数？"></a>29.vue-router钩子函数有哪些？都有哪些参数？</h3><p>Vue Router 提供了一系列的导航钩子函数，用于在路由导航过程中执行一些操作，例如权限验证、路由拦截等。常用的导航钩子函数包括：</p>
<ol>
<li><p><strong>全局前置守卫</strong>：<code>beforeEach(to, from, next)</code></p>
<ul>
<li>参数：<ul>
<li><code>to</code>: Route: 即将要进入的目标路由对象</li>
<li><code>from</code>: Route: 当前导航正要离开的路由</li>
<li><code>next</code>: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>全局解析守卫</strong>：<code>beforeResolve(to, from, next)</code></p>
<ul>
<li>参数与全局前置守卫相同。</li>
</ul>
</li>
<li><p><strong>全局后置钩子</strong>：<code>afterEach(to, from)</code></p>
<ul>
<li>参数：<ul>
<li><code>to</code>: Route: 进入的目标路由对象</li>
<li><code>from</code>: Route: 离开的路由对象</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路由独享的守卫</strong>：</p>
<ul>
<li><code>beforeEnter(to, from, next)</code>: 在单个路由配置中独享的导航守卫。<ul>
<li>参数与全局前置守卫相同。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>组件内的守卫</strong>：</p>
<ul>
<li><code>beforeRouteEnter(to, from, next)</code>: 进入路由前，在路由导航被确认前调用。</li>
<li><code>beforeRouteUpdate(to, from, next)</code>: 路由更新时调用。</li>
<li><code>beforeRouteLeave(to, from, next)</code>: 离开路由时调用。</li>
</ul>
</li>
</ol>
<p>以上是常用的 Vue Router 导航钩子函数及其参数。这些钩子函数允许你在路由导航的不同阶段执行一些逻辑，并控制导航的行为。</p>
<h3 id="30-route和router有什么区别？"><a href="#30-route和router有什么区别？" class="headerlink" title="30.route和router有什么区别？"></a>30.route和router有什么区别？</h3><p>route：代表当前路由信息对象，可以获取到当前路由的信息参数<br>router：代表路由实例的对象，包含了路由的跳转方法，钩子函数等</p>
<h3 id="31-setup-函数"><a href="#31-setup-函数" class="headerlink" title="31.setup()函数"></a>31.setup()函数</h3><p><strong>1.基本使用</strong></p>
<p>使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a> 来声明响应式的状态，在 <code>setup()</code> 函数中返回的对象会暴露给模板和组件实例。其它的选项也可以通过组件实例来获取 <code>setup()</code> 暴露的属性</p>
<p>在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写 .value。当通过 this 访问时也会同样如此解包。</p>
<p><strong>setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</strong></p>
<p><strong>2.访问 Prop</strong></p>
<p><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</p>
<p>注意如果你解构了 <code>props</code> 对象，解构出的变量将会丢失响应性。</p>
<p>推荐通过 <code>props.xxx</code> 的形式来使用其中的 props。</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/17.png"></p>
<p>如果确实需要解构 <code>props</code> 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs">toRefs()</a> 和 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-utilities.html#toref">toRef()</a> 这两个工具函数：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/18.png"></p>
<p><strong>3.Setup的上下文</strong></p>
<p>传入 <code>setup</code> 函数的第二个参数是一个 <strong>Setup 上下文</strong>对象。上下文对象暴露了其他一些在 <code>setup</code> 中可能会用到的值：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/19.png"></p>
<p>该上下文对象是非响应式的，可以安全地解构：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/20.png"></p>
<p>attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。</p>
<p><code>expose</code> 函数用于显式地<strong>限制该组件暴露出的属性</strong>，当父组件通过<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component">模板引用</a>访问该组件的实例时，将仅能访问 <code>expose</code> 函数暴露出的内容</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/21.png"></p>
<blockquote>
<p>在父组件通过ref获取子组件的实例的属性和方法的需求中，需要注意：</p>
<p>1.如果子组件是 选项式API组件，基本不需要做任何操作</p>
<p>2.如果子组件是 组合式API组件，需要通过 context.expose 暴露给父组件需要使用的属性和方法</p>
<p>3.如果父组件使用 选项式API, 可以通过 this.$refs.refName 访问到子组件想要你看到的属性和方法</p>
<p>4.如果父组件使用 组合式API,需要在setup中先创建 refName，然后再访问子组件想要你看到的属性和方法（const refName &#x3D; ref() refName.value.X）</p>
</blockquote>
<p><strong>4.与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">渲染函数</a>一起使用</strong></p>
<p><code>setup</code> 也可以返回一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/extras/render-function.html">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/22.png"></p>
<p>返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题</p>
<p>我们可以通过调用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-setup.html#exposing-public-properties">expose()</a> 解决这个问题：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/23.png"></p>
<h3 id="32-响应式原理"><a href="#32-响应式原理" class="headerlink" title="32.响应式原理"></a>32.响应式原理</h3><p><code>Vue2.x</code>是借助<code>Object.defineProperty()</code>实现的，而<code>Vue3.x</code>是借助<code>Proxy</code>实现的</p>
<p>我们通过<code>Object.defineProperty</code>为对象<code>obj</code>添加属性，可以设置对象属性的<code>getter</code>和<code>setter</code>函数。之后我们每次通过点语法获取属性都会执行这里的<code>getter</code>函数，在这个函数中我们会把调用此属性的依赖收集到一个集合中 ；而在我们给属性赋值(修改属性)时，会触发这里定义的<code>setter</code>函数，在次函数中会去通知集合中的依赖更新，做到数据变更驱动视图变更。</p>
<p>3.x的与2.x的核心思想一致，只不过数据的劫持使用<code>Proxy</code>而不是<code>Object.defineProperty</code>，只不过Proxy相比Object.defineProperty在处理数组和新增属性的响应式处理上更加方便。</p>
<h3 id="33-router和route的区别"><a href="#33-router和route的区别" class="headerlink" title="33.router和route的区别"></a>33.router和route的区别</h3><ul>
<li><code>$route</code> 是路由信息，包括<code>path</code>、<code>params</code>、<code>query</code>、<code>name</code>等路由信息参数</li>
<li><code>$router</code> 是路由实例，包含了路由跳转方法、钩子函数等</li>
</ul>
<h3 id="34-如何设置动态路由"><a href="#34-如何设置动态路由" class="headerlink" title="34.如何设置动态路由"></a>34.如何设置动态路由</h3><ul>
<li>params传参<ul>
<li>路由配置： <code>/index/:id</code></li>
<li>路由跳转：<code>this.$router.push(&#123;name: &#39;index&#39;, params: &#123;id: &quot;zs&quot;&#125;&#125;);</code></li>
<li>路由参数获取：<code>$route.params.id</code></li>
<li>最后形成的路由：<code>/index/zs</code></li>
</ul>
</li>
<li>query传参<ul>
<li>路由配置：<code>/index</code>正常的路由配置</li>
<li>路由跳转：<code>this.$rouetr.push(&#123;path: &#39;index&#39;, query:&#123;id: &quot;zs&quot;&#125;&#125;);</code></li>
<li>路由参数获取：<code>$route.query.id</code></li>
<li>最后形成的路由：<code>/index?id=zs</code></li>
</ul>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>获取参数方式不一样，一个通过<code>$route.params</code>，一个通过 <code>$route.query</code></li>
<li>参数的生命周期不一样，<code>query</code>参数在URL地址栏中显示不容易丢失，<code>params</code>参数不会在地址栏显示，刷新后会消失</li>
</ul>
<h3 id="35-虚拟DOM的理解"><a href="#35-虚拟DOM的理解" class="headerlink" title="35.虚拟DOM的理解"></a>35.虚拟DOM的理解</h3><h5 id="对虚拟DOM的理解"><a href="#对虚拟DOM的理解" class="headerlink" title="对虚拟DOM的理解"></a>对虚拟DOM的理解</h5><p>虚拟DOM就是用JS对象来表述DOM节点，是对真实DOM的一层抽象。可以通过一些列操作使这个棵树映射到真实DOM上。</p>
<p>如在<code>Vue</code>中，会把代码转换为虚拟DOM，在最终渲染到页面，在每次数据发生变化前，都会缓存一份虚拟DOM，通过<code>diff</code>算法来对比新旧虚拟DOM记录到一个对象中按需更新，最后创建真实DOM，从而提升页面渲染性能。</p>
<h5 id="虚拟DOM就一定比真实DOM更快吗"><a href="#虚拟DOM就一定比真实DOM更快吗" class="headerlink" title="虚拟DOM就一定比真实DOM更快吗"></a>虚拟DOM就一定比真实DOM更快吗</h5><p><strong>虚拟DOM不一定比真实DOM更快，而是在特定情况下可以提供更好的性能。</strong></p>
<p>在复杂情况下，虚拟DOM可以比真实DOM操作更快，因为它是在内存中维护一个虚拟的DOM树，将真实DOM操作转换为对虚拟DOM的操作，然后通过<code>diff</code>算法找出需要更新的部分，最后只变更这部分到真实DOM就可以。在频繁变更下，它可以批量处理这些变化从而减少对真实DOM的访问和操作，减少浏览器的回流重绘，提高页面渲染性能。</p>
<p>而在一下简单场景下，直接操作真实DOM可能会更快，当更新操作很少或者只是局部改变时，直接操作真实DOM比操作虚拟DOM更高效，省去了虚拟DOM的计算、对比开销。</p>
<h5 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程"></a>虚拟DOM的解析过程</h5><ul>
<li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 <code>TagName</code>、<code>props</code> 和 <code>Children</code> 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li>
<li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li>
<li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>
</ul>
<h3 id="36-DIFF算法原理"><a href="#36-DIFF算法原理" class="headerlink" title="36.DIFF算法原理"></a>36.DIFF算法原理</h3><p><code>diff</code>的目的是找出差异，最小化的更新视图。 <code>diff</code>算法发生在视图更新阶段，当数据发生变化的时候，<code>diff</code>会对新旧虚拟DOM进行对比，只渲染有变化的部分。</p>
<ol>
<li>对比是不是同类型标签，不是同类型直接替换</li>
<li>如果是同类型标签，执行<code>patchVnode</code>方法，判断新旧<code>vnode</code>是否相等。如果相等，直接返回。</li>
<li>新旧vnode不相等，需要比对新旧节点，比对原则是以新节点为主，主要分为以下几种。<ol>
<li><code>newVnode</code> 和 <code>oldVnode</code>都有文本节点，用新节点替换旧节点。</li>
<li><code>newVnode</code>有子节点，<code>oldVnode</code>没有，新增<code>newVnode</code>的子节点。</li>
<li><code>newVnode</code>没有子节点，<code>oldVnode</code>有子节点，删除<code>oldVnode</code>中的子节点。</li>
<li><code>newVnode</code>和<code>oldVnode</code>都有子节点，通过<code>updateChildren</code>对比子节点。</li>
</ol>
</li>
</ol>
<h5 id="双端diff"><a href="#双端diff" class="headerlink" title="双端diff"></a><strong>双端diff</strong></h5><p><code>updateChildren</code>方法用来对比子节点是否相同，将新旧节点同级进行比对，减少比对次数。会创建4个指针，分别指向新旧两个节点的首尾，首和尾指针向中间移动。</p>
<p>每次对比下两个头指针指向的节点、两个尾指针指向的节点，头和尾指向的节点，是不是 key是一样的，也就是可复用的。如果是重复的，直接patch更新一下，如果是头尾节点，需要进行移动位置，结果以新节点的为主。</p>
<p>如果都没有可以复用的节点，就从旧的<code>vnode</code>中查找，然后进行移动，没有找到就插入一个新节点。</p>
<p>当比对结束后，此时新节点还有剩余，就批量增加，如果旧节点有剩余就批量删除。</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/4.awebp"></p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="1-从输入URL到页面加载的全过程"><a href="#1-从输入URL到页面加载的全过程" class="headerlink" title="1.从输入URL到页面加载的全过程"></a>1.从输入URL到页面加载的全过程</h3><p>首先在浏览器中输入URL</p>
<p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p>
<ul>
<li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li>
<li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li>
<li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li>
<li>ISP缓存：若上述均失败，继续向ISP搜索。</li>
</ul>
<p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p>
<p>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p>
<p>发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器</p>
<p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p>
<p>关闭TCP连接：通过四次挥手释放TCP连接</p>
<p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来</p>
<h3 id="2-浏览器解析页面的过程"><a href="#2-浏览器解析页面的过程" class="headerlink" title="2.浏览器解析页面的过程"></a>2.浏览器解析页面的过程</h3><p>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</p>
<p>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</p>
<p>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</p>
<p>布局（Layout）：计算出每个节点在屏幕中的位置</p>
<p>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</p>
<h3 id="3-JS引擎解析过程"><a href="#3-JS引擎解析过程" class="headerlink" title="3.JS引擎解析过程"></a>3.JS引擎解析过程</h3><p>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</p>
<p>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</p>
<p>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</p>
<p>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。</p>
<h3 id="4-浏览器重绘与重排的区别？"><a href="#4-浏览器重绘与重排的区别？" class="headerlink" title="4.浏览器重绘与重排的区别？"></a>4.浏览器重绘与重排的区别？</h3><ul>
<li><p>浏览器中的重绘（Repaint）和重排（Reflow）是页面渲染过程中的两个重要概念，它们虽然有联系，但是涉及的内容和影响范围不同：</p>
<ol>
<li><p><strong>重排（Reflow）</strong>：</p>
<ul>
<li>重排是指当页面中的一部分或全部需要重新布局时触发的过程。</li>
<li>重排可能由于以下原因而发生：DOM结构变化、CSS样式变化（如尺寸、位置、显示&#x2F;隐藏元素）、窗口尺寸变化等。</li>
<li>重排会影响到渲染树（Render Tree）的结构，导致浏览器重新计算元素的几何属性（位置和尺寸），然后重新布局整个页面。</li>
</ul>
</li>
<li><p><strong>重绘（Repaint）</strong>：</p>
<ul>
<li>重绘是指当页面元素的外观需要更新，但不影响其布局时触发的过程。</li>
<li>重绘可能由于以下原因而发生：CSS样式变化（如颜色、背景、边框等）、页面内容变化（如文本内容更新）等。</li>
<li>重绘不会导致页面的重新布局，浏览器会重新绘制受影响的元素，但不会改变其位置和尺寸。</li>
</ul>
</li>
</ol>
<p>因此，重排涉及到整个页面布局的重新计算和重新排列，性能开销相对较大，可能导致页面的闪烁和卡顿；而重绘则仅涉及到外观的更新，性能开销相对较小，但也会影响页面的渲染速度。</p>
</li>
</ul>
<h3 id="7-如何避免重绘或者重排？"><a href="#7-如何避免重绘或者重排？" class="headerlink" title="7.如何避免重绘或者重排？"></a>7.如何避免重绘或者重排？</h3><ol>
<li><strong>使用 will-change 属性</strong>：<code>will-change</code> 属性可以告诉浏览器某个元素可能会发生的变化，从而使浏览器提前做好优化准备。例如，设置 <code>will-change: transform;</code> 可以告诉浏览器该元素可能会进行变形，浏览器在处理时会尽量减少重排和重绘。</li>
<li><strong>使用 translateZ(0) 触发 GPU 加速</strong>：将元素的 <code>transform</code> 属性设置为 <code>translateZ(0)</code> 可以触发 GPU 加速，这样可以将动画的计算和渲染交给 GPU 处理，从而减少 CPU 的负载，避免了页面的重排和重绘。</li>
<li><strong>批量操作 DOM</strong>：尽量减少直接操作 DOM，可以将多个 DOM 操作合并成一次操作，或者使用 DocumentFragment 进行批量操作，减少了页面重排和重绘的次数。</li>
<li>为动画的 HTML 元件**使用 <code>fixed</code> 或 <code>absoult</code> 的 <code>position</code>**，那么修改他们的 CSS 是不会 reflow 的。</li>
<li><strong>不使用 table 布局。</strong>因为可能很小的一个小改动会造成整个 table 的重新布局。</li>
</ol>
<h3 id="8-浏览器的缓存机制"><a href="#8-浏览器的缓存机制" class="headerlink" title="8.浏览器的缓存机制"></a>8.浏览器的缓存机制</h3><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/14.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/15.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/16.png"></p>
<ul>
<li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/1.awebp"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p>
<ul>
<li><p><strong>强制缓存</strong></p>
<p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p>
<p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ol>
</li>
<li><p><strong>协商缓存</strong></p>
<p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。协商缓存主要有以下两种情况：</p>
<ol>
<li>协商缓存生效，返回304</li>
<li>协商缓存失效，返回200和请求结果结果</li>
</ol>
</li>
</ul>
<h3 id="9-进程、线程和协程"><a href="#9-进程、线程和协程" class="headerlink" title="9.进程、线程和协程"></a>9.进程、线程和协程</h3><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p>
<p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p>
<p><strong>协程</strong>，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p>
<h3 id="10-路由的hash和history模式的区别"><a href="#10-路由的hash和history模式的区别" class="headerlink" title="10.路由的hash和history模式的区别"></a>10.路由的hash和history模式的区别</h3><p><strong>hash模式</strong> 开发中默认的模式，地址栏URL后携带<code>#</code>，后面为路由。 原理是通过<code>onhashchange()</code>事件监听<code>hash</code>值变化，在页面<code>hash</code>值发生变化后，<code>window</code>就可以监听到事件改变，并按照规则加载相应的代码。<code>hash</code>值变化对应的URL都会被记录下来，这样就能实现浏览器历史页面前进后退。</p>
<p><strong>history模式</strong> <code>history</code>模式中URL没有<code>#</code>，这样相对<code>hash</code>模式更好看，但是需要后台配置支持。</p>
<p><code>history</code>原理是使用<code>HTML5 history</code>提供的<code>pushState</code>、<code>replaceState</code>两个API，用于浏览器记录历史浏览栈，并且在修改URL时不会触发页面刷新和后台数据请求。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-http-和-https-的区别及优缺点"><a href="#1-http-和-https-的区别及优缺点" class="headerlink" title="1.http 和 https 的区别及优缺点"></a>1.http 和 https 的区别及优缺点</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输,HTTPS 协议要比 HTTP协议安全，HTTPS是具有安全性的 SSL加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性</li>
<li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443</li>
<li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
<li>https <code>缓存</code>不如 http 高效，会增加数据开销</li>
<li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高</li>
</ul>
<h3 id="2-https-协议的工作原理"><a href="#2-https-协议的工作原理" class="headerlink" title="2.https 协议的工作原理"></a>2.https 协议的工作原理</h3><ul>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>
<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li>
<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>
<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>
</ul>
<h3 id="3-TCP-IP-如何保证数据包传输的有序可靠？"><a href="#3-TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="3.TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？"></a>3.TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后<code>通过 ACK 回复</code>和<code>超时重发</code>这两个机制来保证。</p>
<ol>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</li>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
<li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</li>
<li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li>
<li>接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li>
</ol>
<h3 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h3><ul>
<li>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</li>
<li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li>
<li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li>
<li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li>
</ul>
<h3 id="5-HTTP-请求跨域问题"><a href="#5-HTTP-请求跨域问题" class="headerlink" title="5.HTTP 请求跨域问题"></a>5.HTTP 请求跨域问题</h3><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。</p>
<p><strong>同源策略</strong>,是浏览器实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。</p>
<p><strong>「同源策略」</strong>是一个重要的安全策略，它用于限制一个<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90">源</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p><strong>解决方案</strong></p>
<h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/2.png"></p>
<h4 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h4><p>cors跨域的前提条件是服务器是自己人</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/3.png"></p>
<p>在 cors 中会有 <code>简单请求</code> 和 <code>复杂请求</code>的概念</p>
<p>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a></li>
</ul>
<p>情况二: 人为设置以下集合外的请求头</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept"><code>Accept</code></a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language"><code>Content-Language</code></a></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> （需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
<p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application&#x2F;json 为非简单请求)</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/4.png"></p>
<h5 id="a-简单请求"><a href="#a-简单请求" class="headerlink" title="a.简单请求"></a>a.简单请求</h5><p>不会触发 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%23Preflighted_requests">CORS 预检请求</a>。这样的请求为“简单请求”</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/5.png"></p>
<h5 id="b-预检请求"><a href="#b-预检请求" class="headerlink" title="b.预检请求"></a>b.预检请求</h5><p>预检请求就是先要进行发送一次预检请求到服务器，服务器确定ok后才能像简单请求一样跨域</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/6.png"></p>
<p>这个预检请求是以OPTIONS方法发送的</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/13.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/7.png"></p>
<p>问题1：不可以，需要服务器支持</p>
<p>问题2：不可以，需要抖音服务器支持</p>
<p>问题3：很有可能，因为上传图片使用的是post请求方式，Content-Type为<code>multipart/form-data</code>，但提交表单可能是ajax请求，并且Content-Type为<code>json</code></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/8.png"></p>
<h5 id><a href="#" class="headerlink" title></a></h5><h4 id="3-CORS传递-cookie-问题"><a href="#3-CORS传递-cookie-问题" class="headerlink" title="3.CORS传递 cookie 问题"></a>3.CORS传递 cookie 问题</h4><p>1.web 请求设置<code>withCredentials</code></p>
<p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios的 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>2.设置<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p>
<p>3.<code>Access-Control-Allow-Origin</code>不能为 <code>*</code></p>
<h4 id="4-proxy代理服务器"><a href="#4-proxy代理服务器" class="headerlink" title="4.proxy代理服务器"></a>4.proxy代理服务器</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/10.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/9.png"></p>
<h4 id="5-postMessage"><a href="#5-postMessage" class="headerlink" title="5.postMessage"></a>5.postMessage</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/11.png"></p>
<p><strong>举例：</strong></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/12.png"></p>
<h3 id="6-Cookie、sessionStorage、localStorage-的区别"><a href="#6-Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="6.Cookie、sessionStorage、localStorage 的区别"></a>6.Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p>
<ul>
<li>存储在客户端</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
<li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
</ul>
<h3 id="7-拆包-粘包-问题"><a href="#7-拆包-粘包-问题" class="headerlink" title="7.拆包&#x2F;粘包 问题"></a>7.拆包&#x2F;粘包 问题</h3><p>拆包</p>
<ul>
<li>待发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包</li>
</ul>
<p>粘包</p>
<ul>
<li><p>待发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据包合并为一次发送，将发生粘包</p>
</li>
<li><p>接收端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p>
</li>
</ul>
<h5 id="解决-粘包-拆包-问题"><a href="#解决-粘包-拆包-问题" class="headerlink" title="解决 粘包&#x2F;拆包 问题"></a>解决 粘包&#x2F;拆包 问题</h5><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p>
<p>以上提到的三种措施，都有其不足之处。</p>
<p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p>
<p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<p><strong>好的解决方法:</strong></p>
<p><strong>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</strong></p>
<h5 id="为什么TCP有粘包？"><a href="#为什么TCP有粘包？" class="headerlink" title="为什么TCP有粘包？"></a>为什么TCP有粘包？</h5><p>TCP协议粘包拆包问题是因为TCP协议数据传输是基于 “字节流” 的，它不包含消息、数据包等概念，需要应用层协议自己设计消息边界。日常网络应用开发大都在传输层进行，因此粘包拆包问题大都只发生在TCP协议中。</p>
<h5 id="为什么UDP没有粘包？"><a href="#为什么UDP没有粘包？" class="headerlink" title="为什么UDP没有粘包？"></a>为什么UDP没有粘包？</h5><p>UDP有消息保护边界，不会发生粘包拆包问题</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="福州宝宝巴士笔试题"><a href="#福州宝宝巴士笔试题" class="headerlink" title="福州宝宝巴士笔试题"></a>福州宝宝巴士笔试题</h3><h4 id="1、es6中有class可以面向对象开发，而es5则需要基于-来实现面向对象。"><a href="#1、es6中有class可以面向对象开发，而es5则需要基于-来实现面向对象。" class="headerlink" title="1、es6中有class可以面向对象开发，而es5则需要基于__来实现面向对象。"></a>1、es6中有class可以面向对象开发，而es5则需要基于__来实现面向对象。</h4><p>在 ES6 中，<code>class</code> 关键字引入了更清晰和简洁的面向对象编程（OOP）语法，而在 ES5 中则需要通过函数和原型链来实现类似的面向对象开发。让我们来看看这两者的区别：</p>
<p><strong>ES6：使用 <code>class</code></strong></p>
<p>ES6 中的 <code>class</code> 语法是对 JavaScript 原型继承的语法糖，实际上还是基于原型机制实现的，但语法上更接近传统的面向对象编程语言。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">person1.<span class="title function_">greet</span>();  <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5：基于构造函数和原型链</strong></p>
<p>在 ES5 中，实现面向对象编程需要使用构造函数和手动设置原型（prototype）来定义方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, my name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; and I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; years old.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>);</span><br><span class="line">person1.<span class="title function_">greet</span>();  <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ol>
<li><p><strong>语法简洁性</strong>：ES6 的 <code>class</code> 更加简洁，定义类、构造函数、方法都更直观。</p>
<p>2.<strong><code>class</code> 语法糖</strong>：虽然 ES6 使用 <code>class</code>，但其本质上仍然是通过 JavaScript 的原型机制来实现继承的。</p>
</li>
</ol>
<h4 id="2、es6和es5继承的方式"><a href="#2、es6和es5继承的方式" class="headerlink" title="2、es6和es5继承的方式"></a>2、es6和es5继承的方式</h4><p><strong>继承</strong>：ES6 使用 <code>extends</code> 和 <code>super</code> 实现继承，而在 ES5 中需要通过 <code>call</code> 或 <code>apply</code> 手动绑定 <code>this</code>。</p>
<p>ES6 继承示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);  <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">speak</span>();  <span class="comment">// Rex barks.</span></span><br></pre></td></tr></table></figure>

<p>ES5 继承示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);  <span class="comment">// 继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; barks.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">speak</span>();  <span class="comment">// Rex barks.</span></span><br></pre></td></tr></table></figure>

<p>ES6 的 <code>class</code> 语法让 JavaScript 的面向对象编程变得更加直观，减少了许多手动设置原型和继承的复杂性。</p>
<p>Dog.prototype &#x3D; Object.create(Animal.prototype);  &#x2F;&#x2F; 继承方法 </p>
<p>Dog.prototype.constructor &#x3D; Dog;</p>
<p>这两行代码的解释:</p>
<h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>ChatGPT</p>
<p>这两行代码用于实现 ES5 中的继承，尤其是在 JavaScript 原型链上进行方法的继承。让我们详细解释这两行代码的作用：</p>
<ol>
<li><code>Dog.prototype = Object.create(Animal.prototype);</code></li>
</ol>
<p>这一行代码的目的是让 <code>Dog</code> 继承 <code>Animal</code> 的方法。</p>
<ul>
<li><p>**<code>Object.create(Animal.prototype)</code>**：它创建了一个新对象，并将这个对象的原型设置为 <code>Animal.prototype</code>。这样，<code>Dog.prototype</code> 就继承了 <code>Animal.prototype</code> 上的所有方法。换句话说，<code>Dog</code> 类的实例也可以使用 <code>Animal</code> 类上的方法。</p>
<p>例如，如果 <code>Animal.prototype</code> 上有一个 <code>speak</code> 方法，那么通过这行代码，<code>Dog</code> 的实例也能够调用 <code>speak</code> 方法。</p>
</li>
<li><p>**为什么不直接使用 <code>Dog.prototype = Animal.prototype;</code>**：我们不能直接将 <code>Dog.prototype</code> 设置为 <code>Animal.prototype</code>，因为这会让 <code>Dog</code> 和 <code>Animal</code> 共享同一个原型对象。如果我们在 <code>Dog.prototype</code> 上修改了方法或属性，也会影响 <code>Animal.prototype</code>，这显然是不合理的。使用 <code>Object.create</code> 是为了创建一个新的对象来避免这种共享。</p>
</li>
</ul>
<ol start="2">
<li><code>Dog.prototype.constructor = Dog;</code></li>
</ol>
<p>这一行代码是为了修正 <code>constructor</code> 属性。</p>
<ul>
<li><p><strong><code>constructor</code> 属性</strong>：每个函数在创建时，默认都会有一个 <code>prototype</code> 对象，而这个对象默认会有一个 <code>constructor</code> 属性，指向这个函数本身。例如，<code>Dog.prototype.constructor</code> 默认会指向 <code>Dog</code>，<code>Animal.prototype.constructor</code> 会指向 <code>Animal</code>。</p>
<p>但是，当我们通过 <code>Dog.prototype = Object.create(Animal.prototype)</code> 来继承 <code>Animal</code> 的原型时，<code>Dog.prototype.constructor</code> 就会变成指向 <code>Animal</code>，因为 <code>Dog.prototype</code> 的原型是从 <code>Animal.prototype</code> 创建的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);  <span class="comment">// 输出：function Animal() &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<p>为了保持 <code>constructor</code> 指向 <code>Dog</code>，我们需要手动修正它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure>

<p>这样就能确保 <code>Dog</code> 的实例仍然正确地指向 <code>Dog</code> 构造函数。</p>
</li>
</ul>
<p>总结</p>
<ul>
<li>**<code>Dog.prototype = Object.create(Animal.prototype)</code>**：通过这行代码，<code>Dog</code> 的原型对象继承了 <code>Animal</code> 的原型对象，确保 <code>Dog</code> 的实例可以使用 <code>Animal</code> 定义的方法。</li>
<li>**<code>Dog.prototype.constructor = Dog</code>**：修正了 <code>Dog</code> 的原型对象的 <code>constructor</code> 属性，确保它指向正确的构造函数 <code>Dog</code>，而不是 <code>Animal</code>。</li>
</ul>
<h4 id="3、列举浏览器内核"><a href="#3、列举浏览器内核" class="headerlink" title="3、列举浏览器内核"></a>3、列举浏览器内核</h4><p><strong>Blink</strong>：Google Chrome、Microsoft Edge</p>
<p><strong>WebKit</strong>：Safari、早期版本的 Chrome 和 Opera</p>
<p><strong>Trident</strong>：Internet Explorer（IE）</p>
<p><strong>Gecko</strong>：Firefox</p>
<h4 id="4、多个标签页如何通信"><a href="#4、多个标签页如何通信" class="headerlink" title="4、多个标签页如何通信"></a>4、多个标签页如何通信</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/34.png"></p>
<ol>
<li><strong><code>localStorage</code> + <code>storage</code> 事件</strong></li>
</ol>
<p><code>localStorage</code> 是一种持久化的客户端存储机制，不同标签页都可以访问相同的 <code>localStorage</code>。当一个标签页修改了 <code>localStorage</code> 的数据时，其他打开的同源标签页会触发 <code>storage</code> 事件，从而实现通信。</p>
<p>示例：</p>
<p><strong>标签页 1：修改 <code>localStorage</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">localStorage.setItem(&#x27;message&#x27;, &#x27;Hello from tab 1&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>标签页 2：监听 <code>storage</code> 事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码window.addEventListener(&#x27;storage&#x27;, function(event) &#123;</span><br><span class="line">  if (event.key === &#x27;message&#x27;) &#123;</span><br><span class="line">    console.log(&#x27;Received message:&#x27;, event.newValue);  // 输出：Hello from tab 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><p>只在不同标签页修改 <code>localStorage</code> 时触发事件。</p>
<p> 2.<code>BroadcastChannel</code> API</p>
</li>
</ul>
<p><code>BroadcastChannel</code> API 提供了一种简单的方式，让同源的多个浏览器上下文（包括标签页、iframe、甚至 Workers）可以通过广播消息的方式进行通信。</p>
<p>示例：</p>
<p><strong>所有标签页：创建频道并监听消息</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;my_channel&#x27;</span>);</span><br><span class="line"></span><br><span class="line">channel.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">channel.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from one tab&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Service Worker + <code>postMessage</code></strong></li>
</ol>
<p><code>Service Worker</code> 可以作为多个标签页的中间代理，通过 <code>postMessage</code> 方法与标签页之间进行通信。虽然 <code>Service Worker</code> 主要用于网络请求和缓存控制，但也可以用于跨标签页消息传递。</p>
<p>示例：</p>
<p><strong>标签页：发送消息给 Service Worker</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.<span class="property">serviceWorker</span>) &#123;</span><br><span class="line">  navigator.<span class="property">serviceWorker</span>.<span class="property">controller</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from tab&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message from service worker:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Service Worker：监听消息并广播</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">  event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from service worker&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><code>Service Worker</code> 在后台运行，可以跨标签页进行复杂的通信。</li>
<li>适合需要保持持续状态或者后台处理的情况。</li>
<li>需要注册并激活 <code>Service Worker</code>。</li>
</ul>
<p>4、<strong>WebSocket</strong>（服务器端通信）</p>
<p>如果标签页之间的通信需要持久化或需要跨设备进行，WebSocket 是一种有效的解决方案。通过一个 WebSocket 服务器，所有的标签页都可以保持与服务器的连接，从而实现实时的跨标签页通信。</p>
<h4 id="5、什么是同源策略"><a href="#5、什么是同源策略" class="headerlink" title="5、什么是同源策略"></a>5、什么是同源策略</h4><p>同源：协议、域名、端口相同是同源</p>
<p>同源策略：同源策略是浏览器的一个安全功能，不同源的客户脚本在没有明确授权的情况不能读写对方的资源。</p>
<h4 id="6、网站如何SEO"><a href="#6、网站如何SEO" class="headerlink" title="6、网站如何SEO"></a>6、网站如何SEO</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/35.png"></p>
<h4 id="7、display的值有哪些、区别"><a href="#7、display的值有哪些、区别" class="headerlink" title="7、display的值有哪些、区别"></a>7、display的值有哪些、区别</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/36.png"></p>
<h4 id="8、列举你了解的UI框架"><a href="#8、列举你了解的UI框架" class="headerlink" title="8、列举你了解的UI框架"></a>8、列举你了解的UI框架</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/37.png"></p>
<h4 id="9、什么是闭包，闭包的优点"><a href="#9、什么是闭包，闭包的优点" class="headerlink" title="9、什么是闭包，闭包的优点"></a>9、什么是闭包，闭包的优点</h4><p>什么是闭包？</p>
<p>闭包是指在 JavaScript 中，函数能够记住并访问其词法作用域（即定义时的作用域），即使这个函数在其词法作用域之外被调用。</p>
<p><strong>举例说明：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> outerVariable = <span class="string">&quot;I&#x27;m from outer scope!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVariable);  <span class="comment">// 闭包使 innerFunction 能访问 outerVariable</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closure = <span class="title function_">outerFunction</span>();  <span class="comment">// 返回 innerFunction</span></span><br><span class="line"><span class="title function_">closure</span>();  <span class="comment">// 输出 &quot;I&#x27;m from outer scope!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>innerFunction</code> 是一个闭包。即使 <code>outerFunction</code> 执行完毕，<code>outerVariable</code> 仍然可以被 <code>innerFunction</code> 访问，因为闭包使得 <code>innerFunction</code> “记住” 了其创建时的作用域。</p>
<p>闭包的优点</p>
<ol>
<li><p><strong>数据封装</strong>：闭包可以隐藏函数中的变量，使其成为“私有变量”，外部无法直接访问。例如，闭包常用于创建模块化代码，保护内部数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>());  <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>count</code> 变量只能通过返回的闭包函数来访问，外部无法直接修改它。</p>
</li>
<li><p><strong>持久化变量</strong>：闭包使得函数执行结束后，局部变量不会被销毁，而是持续存在于内存中，直到不再被引用。</p>
<ul>
<li>例如，计数器、缓存等功能可以通过闭包保持状态。</li>
</ul>
</li>
</ol>
<h4 id="10、微信小程序的文件结构"><a href="#10、微信小程序的文件结构" class="headerlink" title="10、微信小程序的文件结构"></a>10、微信小程序的文件结构</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/38.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/39.png"></p>
<h4 id="11、什么是前端模块化"><a href="#11、什么是前端模块化" class="headerlink" title="11、什么是前端模块化"></a>11、什么是前端模块化</h4><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/40.png"></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/41.png"></p>
<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><p>1.自我介绍</p>
<h3 id="2-vue中的指令有哪些"><a href="#2-vue中的指令有哪些" class="headerlink" title="2.vue中的指令有哪些"></a>2.vue中的指令有哪些</h3><ul>
<li>v-text</li>
<li>v-html（不建议使用）</li>
<li>v-show</li>
<li>v-if &#x2F; v-else-if &#x2F; v-else</li>
<li>v-for</li>
<li>v-bind</li>
<li>v-on</li>
<li>v-model</li>
<li>v-slot</li>
<li>v-pre（使用频率很低）</li>
<li>v-once（使用频率很低）</li>
<li>v-cloak（使用频率极低，不细介绍）</li>
</ul>
<h3 id="3-事件修饰符"><a href="#3-事件修饰符" class="headerlink" title="3.事件修饰符"></a>3.事件修饰符</h3><p><code>.stop </code>- 调用 <code>event.stopPropagation()</code>，禁止事件冒泡</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/24.png"></p>
<p><code>.prevent</code> - 调用<code> event.preventDefault()</code>，禁止事件的默认行为：</p>
<p><code>.passive</code> - 立即执行事件的默认行为，会导致 <code>event.preventDefault()</code> 无效：</p>
<p><code>.capture </code>- 内部元素触发的事件先在此处理，然后才交由内部元素进行处理</p>
<p><code>.self</code> - 只当事件是从侦听器绑定的元素本身（<code>event.target</code>）触发时才触发回调：</p>
<p><code>.native</code> - 监听组件根元素的原生事件</p>
<p><code>.once </code>- 只触发一次回调</p>
<h3 id="4-setup用处"><a href="#4-setup用处" class="headerlink" title="4.setup用处"></a>4.setup用处</h3><p><strong>1.基本使用</strong></p>
<p>使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a> 来声明响应式的状态，在 <code>setup()</code> 函数中返回的对象会暴露给模板和组件实例。其它的选项也可以通过组件实例来获取 <code>setup()</code> 暴露的属性</p>
<p>在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写 .value。当通过 this 访问时也会同样如此解包。</p>
<p><strong>setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</strong></p>
<p><strong>2.访问 Prop</strong></p>
<p><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</p>
<p>注意如果你解构了 <code>props</code> 对象，解构出的变量将会丢失响应性。</p>
<p>推荐通过 <code>props.xxx</code> 的形式来使用其中的 props。</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/17.png"></p>
<p>如果确实需要解构 <code>props</code> 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs">toRefs()</a> 和 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-utilities.html#toref">toRef()</a> 这两个工具函数：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/18.png"></p>
<p><strong>3.Setup的上下文</strong></p>
<p>传入 <code>setup</code> 函数的第二个参数是一个 <strong>Setup 上下文</strong>对象。上下文对象暴露了其他一些在 <code>setup</code> 中可能会用到的值：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/19.png"></p>
<p>该上下文对象是非响应式的，可以安全地解构：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/20.png"></p>
<p>attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。</p>
<p><code>expose</code> 函数用于显式地<strong>限制该组件暴露出的属性</strong>，当父组件通过<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component">模板引用</a>访问该组件的实例时，将仅能访问 <code>expose</code> 函数暴露出的内容</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/21.png"></p>
<blockquote>
<p>在父组件通过ref获取子组件的实例的属性和方法的需求中，需要注意：</p>
<p>1.如果子组件是 选项式API组件，基本不需要做任何操作</p>
<p>2.如果子组件是 组合式API组件，需要通过 context.expose 暴露给父组件需要使用的属性和方法</p>
<p>3.如果父组件使用 选项式API, 可以通过 this.$refs.refName 访问到子组件想要你看到的属性和方法</p>
<p>4.如果父组件使用 组合式API,需要在setup中先创建 refName，然后再访问子组件想要你看到的属性和方法（const refName &#x3D; ref() refName.value.X）</p>
</blockquote>
<p><strong>4.与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">渲染函数</a>一起使用</strong></p>
<p><code>setup</code> 也可以返回一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/extras/render-function.html">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/22.png"></p>
<p>返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题</p>
<p>我们可以通过调用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-setup.html#exposing-public-properties">expose()</a> 解决这个问题：</p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/23.png"></p>
<h3 id="5-vite和webpack区别"><a href="#5-vite和webpack区别" class="headerlink" title="5.vite和webpack区别"></a>5.vite和webpack区别</h3><p><strong>1、开发模式的差异</strong></p>
<p>在开发环境中，<code>Webpack</code> 是先打包再启动开发服务器，而 <code>Vite</code> 则是直接启动，然后再按需编译依赖文件。（大家可以启动项目后检查源码 <code>Sources</code> 那里看到）</p>
<p>这意味着，当使用 <code>Webpack</code> 时，所有的模块都需要在开发前进行打包，这会增加启动时间和构建时间。</p>
<p>而 <code>Vite</code> 则采用了不同的策略，它会在请求模块时再进行实时编译，这种按需动态编译的模式极大地缩短了编译时间，特别是在大型项目中，文件数量众多，<code>Vite</code> 的优势更为明显。</p>
<p><strong>Webpack启动</strong></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/25.png"></p>
<p><strong>Vite启动</strong></p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/26.png"></p>
<p><strong>2、对ES Modules的支持</strong></p>
<p>现代浏览器本身就支持 <code>ES Modules</code>，会<code>主动发起</code>请求去获取所需文件。Vite充分利用了这一点，将开发环境下的模块文件直接作为浏览器要执行的文件，而不是像 Webpack 那样<code>先打包</code>，再交给浏览器执行。这种方式减少了中间环节，提高了效率。</p>
<p>什么是ES Modules？</p>
<p>通过使用 <code>export</code> 和 <code>import</code> 语句，ES Modules 允许在浏览器端导入和导出模块。</p>
<p>当使用 ES Modules 进行开发时，开发者实际上是在构建一个<code>依赖关系图</code>，不同依赖项之间通过导入语句进行关联。</p>
<p>主流浏览器（除IE外）均支持ES Modules，并且可以通过在 script 标签中设置 <code>type=&quot;module&quot;</code>来加载模块。默认情况下，模块会延迟加载，执行时机在文档解析之后，触发DOMContentLoaded事件前。</p>
<p><strong>3、底层语言的差异</strong></p>
<p>Webpack 是基于 <code>Node.js</code> 构建的，而 Vite 则是基于 <code>esbuild</code> 进行预构建依赖。esbuild 是采用 <code>Go</code> 语言编写的，Go 语言是<code>纳秒</code>级别的，而 Node.js 是<code>毫秒</code>级别的。因此，Vite 在打包速度上相比Webpack 有 <code>10-100</code> 倍的提升。</p>
<p>什么是预构建依赖？</p>
<p>预构建依赖通常指的是在项目<code>启动或构建</code>之前，对项目中所需的依赖项进行预先的<code>处理或构建</code>。这样做的好处在于，当项目实际运行时，可以<code>直接使用</code>这些已经预构建好的依赖，而无需再进行实时的编译或构建，从而提高了应用程序的运行速度和效率。</p>
<p><strong>4、热更新的处理</strong></p>
<p>在 Webpack 中，当一个模块或其依赖的模块内容改变时，需要<code>重新编译</code>这些模块。</p>
<p>而在 Vite 中，当某个模块内容改变时，只需要让浏览器<code>重新请求</code>该模块即可，这大大减少了热更新的时间。</p>
<p><strong>总结</strong></p>
<p>总的来说，Vite 之所以比 Webpack 快，主要是因为它采用了<code>不同的开发模式</code>、<code>充分利用了现代浏览器的 ES Modules 支持</code>、<code>使用了更高效的底层语言</code>，<code>并优化了热更新的处理</code>。</p>
<h3 id="6-vite的特点和优点"><a href="#6-vite的特点和优点" class="headerlink" title="6.vite的特点和优点"></a>6.vite的特点和优点</h3><ol>
<li><strong>快速的冷启动</strong>：Vite 利用现代浏览器原生 ES 模块的特性，将开发服务器的冷启动时间降至极低，从而实现几乎无感知的开发体验。</li>
<li><strong>即时热更新</strong>：Vite 支持即时热更新，可以在你修改代码后立即看到结果，无需手动刷新浏览器。</li>
<li><strong>按需编译</strong>：Vite 会根据需要按需编译代码，而不是像传统的打包工具那样一次性编译整个项目。这样可以加快开发过程中的构建速度。</li>
<li><strong>模块预构建</strong>：Vite 会在浏览器首次请求时提前预构建模块，以便在浏览器中快速加载。这样可以避免了大部分传统打包工具在构建时需要等待的时间。</li>
<li><strong>开箱即用的 TypeScript 支持</strong>：Vite 内置了对 TypeScript 的支持，无需额外配置即可在项目中使用 TypeScript。</li>
</ol>
<h3 id="7-vue2的生命周期"><a href="#7-vue2的生命周期" class="headerlink" title="7.vue2的生命周期"></a>7.vue2的生命周期</h3><p>Vue 2 的生命周期钩子函数提供了在组件生命周期中不同阶段执行代码的机会。以下是 Vue 2 中常用的生命周期钩子函数及其作用：</p>
<ol>
<li><p><strong>beforeCreate</strong>：在实例初始化之后，数据观测 (data observation) 和事件配置 (event&#x2F;watcher setup) 之前被调用。在这个阶段，实例的属性和方法都尚未被初始化。</p>
</li>
<li><p><strong>created</strong>：在实例创建完成后被立即调用。在这个阶段，实例已经完成了数据观测 (data observation)，属性和方法的运算，但是尚未挂载到 DOM 上。</p>
</li>
<li><p><strong>beforeMount</strong>：在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
</li>
<li><p><strong>mounted</strong>：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。在这个阶段，组件已经挂载到 DOM 上，可以进行 DOM 操作。</p>
</li>
<li><p><strong>beforeUpdate</strong>：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。在这个阶段，你可以在更新之前访问现有的 DOM。</p>
</li>
<li><p><strong>updated</strong>：由于数据更改导致的虚拟 DOM 重新渲染和打补丁后会调用该钩子。在这个阶段，组件已经更新了 DOM，可以执行一些需要 DOM 的操作。</p>
</li>
<li><p><strong>beforeDestroy</strong>：实例销毁之前调用。在这个阶段，实例仍然完全可用。</p>
</li>
<li><p><strong>destroyed</strong>：实例销毁之后调用。在这个阶段，Vue 实例及其所有的指令已被销毁，但是 DOM 元素仍然存在。</p>
</li>
</ol>
<p>以上是 Vue 2 中常用的生命周期钩子函数。这些钩子函数可以帮助你在组件的不同生命周期阶段执行代码，从而实现更灵活的组件逻辑。</p>
<h3 id="8-双向绑定的理解"><a href="#8-双向绑定的理解" class="headerlink" title="8.双向绑定的理解"></a>8.双向绑定的理解</h3><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/27.png"></p>
<p>双向数据绑定通常是指我们使用的<code>v-model</code>指令的实现，是<code>Vue</code>的一个特性，也可以说是一个<code>input</code>事件和<code>value</code>的语法糖。 <code>Vue</code>通过<code>v-model</code>指令为组件添加上<code>input</code>事件处理和<code>value</code>属性的赋值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;localValue&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的组件就相当于如下代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 这里添加了input时间的监听和value的属性绑定 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> @<span class="attr">input</span>=<span class="string">&#x27;onInput&#x27;</span> <span class="attr">:value</span>=<span class="string">&#x27;localValue&#x27;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;localValue&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">localValue</span>:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onInput</span>(<span class="params">v</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//在input事件的处理函数中更新value的绑定值</span></span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">this</span>.<span class="property">localValue</span>=v.<span class="property">target</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">localValue</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此当我们修改input输入框中的值时，我们通过v-model绑定的值也会同步修改，基于上述原理，我们可以很容易的实现一个数据双向绑定的组件。</p>
<p>v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，在大部分情况下， v-model&#x3D;”foo” 等价于 :value&#x3D;”foo” 加上 @input&#x3D;”foo &#x3D; $event”；<br>​副作用<br>​副作用如下：如果 v-model 绑定的是响应式对象上某个不存在的属性，那么 vue 会悄悄地增加这个属性，并让它响应式。<br>​是单向数据流<br>​<br><strong>​什么是单向数据流？</strong><br>​子组件不能改变父组件传递给它的 prop 属性，推荐的做法是它抛出事件，通知父组件自行改变绑定的值。<br>​『单向数据流』总结起来其实也就8个字：『数据向下，事件向上』。<br>​<br>​<br><strong>​怎么让你的组件支持v-model</strong></p>
<p>在定义 <code>vue</code> 组件时，你可以提供一个 <code>model</code> 属性，用来定义该组件以何种方式支持 <code>v-model</code>。</p>
<p><code>model</code> 属性本身是有默认值的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 model 属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;input&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说，如果你不定义 <code>model</code> 属性，或者你按照当面方法定义属性，当其他人使用你的自定义组件时，<code>v-model=&quot;foo&quot;</code> 就完全等价于 <code>:value=&quot;foo&quot;</code> 加上 <code>@input=&quot;foo = $event&quot;</code>。</p>
<p>如果把 <code>model</code> 属性进行一些改装，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 model 属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;ame&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;zard&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，<code>v-model=&quot;foo&quot;</code> 就等价于 <code>:ame=&quot;foo&quot;</code> 加上 <code>@zard=&quot;foo = $event&quot;</code>。</p>
<p>没错，就是这么容易，让我们看个例子。</p>
<p>先定义一个自定义组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  我们是TI&#123;&#123; ame &#125;&#125;冠军</span><br><span class="line">  &lt;el-button @click=&quot;playDota2(1)&quot;&gt;加&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button @click=&quot;playDota2(-1)&quot;&gt;减&lt;/el-button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    ame: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  model: &#123; // 自定义v-model的格式</span><br><span class="line">    prop: &#x27;ame&#x27;, // 代表 v-model 绑定的prop名</span><br><span class="line">    event: &#x27;zard&#x27; // 代码 v-model 通知父组件更新属性的事件名</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    playDota2(step) &#123;</span><br><span class="line">      const newYear = this.ame + step</span><br><span class="line">      this.$emit(&#x27;zard&#x27;, newYear)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们在父组件中使用该组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// template中</span><br><span class="line">&lt;dota v-model=&quot;ti&quot;&gt;&lt;/dota&gt;</span><br><span class="line">// script中</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ti: 8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看效果： </p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/2.awebp"></p>
<h3 id="9-var-const-和-let的区别"><a href="#9-var-const-和-let的区别" class="headerlink" title="9.var const 和 let的区别"></a>9.var const 和 let的区别</h3><p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>
<ul>
<li>变量提升</li>
<li>暂时性死区</li>
<li>块级作用域</li>
<li>重复声明</li>
<li>修改声明的变量</li>
<li>使用</li>
</ul>
<p><strong>变量提升</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined</span><br></pre></td></tr></table></figure>

<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>暂时性死区</strong></p>
<p><code>var</code>不存在暂时性死区</p>
<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Cannot access &#x27;b&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Cannot access &#x27;c&#x27; before initialization</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p><strong>块级作用域</strong></p>
<p><code>var</code>不存在块级作用域</p>
<p><code>let</code>和<code>const</code>存在块级作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c)  <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure>



<p><strong>重复声明</strong></p>
<p><code>var</code>允许重复声明变量</p>
<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span> <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> <span class="comment">// Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">20</span> <span class="comment">// Identifier &#x27;c&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>



<p><strong>修改声明的变量</strong></p>
<p><code>var</code>和<code>let</code>可以</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//let</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span></span><br><span class="line">c = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>



<p><strong>使用</strong></p>
<p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>
<p>10.组件结构的两种组织方式</p>
<p>11.语义化结构开发的方式</p>
<h3 id="12-H5语义化标签有哪些"><a href="#12-H5语义化标签有哪些" class="headerlink" title="12.H5语义化标签有哪些"></a>12.H5语义化标签有哪些</h3><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/3.awebp"></p>
<p>header、nav、article、section、aside、footer</p>
<p>13.js数据结构开发指什么</p>
<h3 id="14-组件之间的通信方式"><a href="#14-组件之间的通信方式" class="headerlink" title="14.组件之间的通信方式"></a>14.组件之间的通信方式</h3><p><strong>vue2父子通信方式</strong></p>
<p><strong>1.props 父传子</strong></p>
<p><strong>2..sync的使用</strong><br>​可以帮我们实现父组件向子组件传递的数据 的双向绑定，所以子组件接收到数据后可以直接修改，并且会同时修改父组件的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:page.sync</span>=<span class="string">&quot;page&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">page</span>:<span class="number">1</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// Child.vue</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>:[<span class="string">&quot;page&quot;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">computed</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 当我们在子组件里修改 currentPage 时，父组件的 page 也会随之改变</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        currentPage &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">page</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.$emit(<span class="string">&quot;update:page&quot;</span>, newVal)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.v-model</strong><br>​v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，在大部分情况下， v-model&#x3D;”foo” 等价于 :value&#x3D;”foo” 加上 @input&#x3D;”foo &#x3D; $event”；<br>​副作用<br>​副作用如下：如果 v-model 绑定的是响应式对象上某个不存在的属性，那么 vue 会悄悄地增加这个属性，并让它响应式。<br>​是单向数据流<br>​<br><strong>​什么是单向数据流？</strong><br>​子组件不能改变父组件传递给它的 prop 属性，推荐的做法是它抛出事件，通知父组件自行改变绑定的值。<br>​『单向数据流』总结起来其实也就8个字：『数据向下，事件向上』。<br>​<br>​<br><strong>​怎么让你的组件支持v-model</strong></p>
<p>在定义 <code>vue</code> 组件时，你可以提供一个 <code>model</code> 属性，用来定义该组件以何种方式支持 <code>v-model</code>。</p>
<p><code>model</code> 属性本身是有默认值的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 model 属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;input&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说，如果你不定义 <code>model</code> 属性，或者你按照当面方法定义属性，当其他人使用你的自定义组件时，<code>v-model=&quot;foo&quot;</code> 就完全等价于 <code>:value=&quot;foo&quot;</code> 加上 <code>@input=&quot;foo = $event&quot;</code>。</p>
<p>如果把 <code>model</code> 属性进行一些改装，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 model 属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;ame&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;zard&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，<code>v-model=&quot;foo&quot;</code> 就等价于 <code>:ame=&quot;foo&quot;</code> 加上 <code>@zard=&quot;foo = $event&quot;</code>。</p>
<p>没错，就是这么容易，让我们看个例子。</p>
<p>先定义一个自定义组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  我们是TI&#123;&#123; ame &#125;&#125;冠军</span><br><span class="line">  &lt;el-button @click=&quot;playDota2(1)&quot;&gt;加&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button @click=&quot;playDota2(-1)&quot;&gt;减&lt;/el-button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    ame: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  model: &#123; // 自定义v-model的格式</span><br><span class="line">    prop: &#x27;ame&#x27;, // 代表 v-model 绑定的prop名</span><br><span class="line">    event: &#x27;zard&#x27; // 代码 v-model 通知父组件更新属性的事件名</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    playDota2(step) &#123;</span><br><span class="line">      const newYear = this.ame + step</span><br><span class="line">      this.$emit(&#x27;zard&#x27;, newYear)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们在父组件中使用该组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// template中</span><br><span class="line">&lt;dota v-model=&quot;ti&quot;&gt;&lt;/dota&gt;</span><br><span class="line">// script中</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ti: 8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看效果： </p>
<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/2.awebp"></p>
<p><strong>​4.模版引用ref</strong><br>​ref 如果在普通的DOM元素上，引用指向的就是该DOM元素;<br>​<br>​如果在子组件上，引用的指向就是子组件实例，然后父组件就可以通过 ref 主动获取子组件的属性或者调用子组件的方法<br><strong>​</strong><br><strong>​5. $emit &#x2F; v-on</strong><br>​子组件通过派发事件的方式给父组件数据，或者触发父组件更新等操作<br><strong>​</strong><br><strong>​6. $attrs &#x2F; $listeners</strong><br>​多层嵌套组件传递数据时，如果只是传递数据，而不做中间处理的话就可以用这个，比如父组件向孙子组件传递数据时<br>$attrs：包含父作用域里除 class 和 style 除外的非 props 属性集合。通过 this.$attrs 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 v-bind&#x3D;”$attrs”<br>$listeners：包含父作用域里 .native 除外的监听事件集合。如果还要继续传给子组件内部的其他组件，就可以通过 v-on&#x3D;”$linteners”<br>​使用方式是相同的<br>​<br><strong>​7. $children &#x2F; $parent</strong><br>$children：获取到一个包含所有子组件(不包含孙子组件)的 VueComponent 对象数组，可以直接拿到子组件中所有数据和方法等<br>$parent：获取到一个父节点的 VueComponent 对象，同样包含父节点中所有数据和方法等<br>​<br><strong>​</strong><br><strong>​8.provide &#x2F; inject</strong><br>​provide &#x2F; inject 为依赖注入，说是不推荐直接用于应用程序代码中，但是在一些插件或组件库里却是被常用，所以我觉得用也没啥，还挺好用的<br>​<br>​provide：可以让我们指定想要提供给后代组件的数据或方法<br>​<br>​inject：在任何后代组件中接收想要添加在这个组件上的数据或方法，不管组件嵌套多深都可以直接拿来用<br>​<br>​要注意的是 provide 和 inject 传递的数据不是响应式的，也就是说用 inject 接收来数据后，provide 里的数据改变了，后代组件中的数据不会改变，除非传入的就是一个可监听的对象<br>​<br>​所以建议还是传递一些常量或者方法<br>​<br><strong>​9.EventBus</strong><br>​EventBus 是中央事件总线，不管是父子组件，兄弟组件，跨层级组件等都可以使用它完成通信操作<br>​<br><strong>​10.Vuex</strong><br>​Vuex 是状态管理器，集中式存储管理所有组件的状态。<br>​<br><strong>​11. $root</strong><br>$root 可以拿到 App.vue 里的数据和方法<br>​<br><strong>​12. slot</strong><br>​就是把子组件的数据通过插槽的方式传给父组件使用，然后再插回来<br>​<br>​<br><strong>​Vue3 组件通信方式</strong></p>
<ul>
<li><p>props</p>
</li>
<li><p>$emit</p>
</li>
<li><p>expose &#x2F; ref</p>
</li>
<li><p>$attrs</p>
</li>
<li><p>v-model</p>
</li>
<li><p>provide &#x2F; inject</p>
</li>
<li><p>Vuex</p>
</li>
<li><p>mitt</p>
<ul>
<li><p>Vue3 中没有了 EventBus 跨组件通信，但是现在有了一个替代的方案 <code>mitt.js</code>，原理还是 EventBus<br>先安装<code> npm i mitt -S</code><br>然后像以前封装 bus 一样，封装一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mitt.js</span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&#x27;mitt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mitt = <span class="title function_">mitt</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mitt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="15-vuex状态管理包含哪些部分"><a href="#15-vuex状态管理包含哪些部分" class="headerlink" title="15.vuex状态管理包含哪些部分"></a>15.vuex状态管理包含哪些部分</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">state</span>: &#123; </span><br><span class="line">        <span class="comment">// state 类似 data</span></span><br><span class="line">        <span class="comment">//这里面写入数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>:&#123; </span><br><span class="line">        <span class="comment">// getters 类似 computed </span></span><br><span class="line">        <span class="comment">// 在这里面写个方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>:&#123; </span><br><span class="line">        <span class="comment">// mutations 类似 methods</span></span><br><span class="line">        <span class="comment">// 写方法对数据做出更改(同步操作)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">        <span class="comment">// actions 类似 methods</span></span><br><span class="line">        <span class="comment">// 写方法对数据做出更改(异步操作)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//modules，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理；如果所有的状态或者方法都写在一个`store`里面，将会变得非常臃肿，难以维护。</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line"> <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line"> <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line"> <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="16-vuex的语法糖有哪些"><a href="#16-vuex的语法糖有哪些" class="headerlink" title="16.vuex的语法糖有哪些"></a>16.vuex的语法糖有哪些</h3><p>Vuex 提供了一些语法糖，以简化在 Vue 应用中使用 Vuex 的过程。以下是一些常用的 Vuex 语法糖：</p>
<ol>
<li><p><strong>mapState</strong>：将 store 中的状态映射到组件的计算属性中，以便在模板中直接使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板中可以直接使用 <code>&#123;&#123; count &#125;&#125;</code> 来访问 <code>store.state.count</code> 的值。</p>
</li>
<li><p><strong>mapGetters</strong>：将 store 中的 getters 映射到组件的计算属性中，以便在模板中直接使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;doneTodosCount&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板中可以直接使用 <code>&#123;&#123; doneTodosCount &#125;&#125;</code> 来访问 <code>store.getters.doneTodosCount</code> 的值。</p>
</li>
<li><p><strong>mapMutations</strong>：将 store 中的 mutations 映射到组件的 methods 中，以便在方法中直接调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;increment&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中可以直接调用 <code>this.increment()</code> 来提交 <code>store.commit(&#39;increment&#39;)</code>。</p>
</li>
<li><p><strong>mapActions</strong>：将 store 中的 actions 映射到组件的 methods 中，以便在方法中直接调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;incrementAsync&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中可以直接调用 <code>this.incrementAsync()</code> 来分发 <code>store.dispatch(&#39;incrementAsync&#39;)</code>。</p>
</li>
</ol>
<p>这些语法糖可以使 Vuex 的使用更加简洁和方便，减少了模板和方法中的冗余代码，提高了代码的可读性和可维护性。</p>
<h3 id="17-ajax、fetch、axios的区别"><a href="#17-ajax、fetch、axios的区别" class="headerlink" title="17.ajax、fetch、axios的区别"></a>17.ajax、fetch、axios的区别</h3><p><strong>1.ajax</strong></p>
<p>英译过来是<code>Aysnchronous JavaScript And XML</code>，直译是异步<code>JS</code>和<code>XML</code>（<code>XML</code>类似<code>HTML</code>，但是设计宗旨就为了传输数据，现已被<code>JSON</code>代替），解释一下就是说<strong>以<code>XML</code>作为数据传输格式发送JS<code>异步</code>请求</strong>。但实际上<strong>ajax是一个一类技术的统称的术语</strong>，包括<code>XMLHttpRequest</code>、<code>JS</code>、<code>CSS</code>、<code>DOM</code>等，它<strong>主要实现网页拿到请求数据后不用刷新整个页面也能呈现最新的数据</strong>。</p>
<p>下面我们简单封装一个<code>ajax</code>请求【面试高频题】：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> ajaxGet = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, url)</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>);  <span class="comment">// 响应结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error, xhr.<span class="property">status</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. fetch</strong></p>
<p>它其实就<strong>是一个<code>JS</code>自带的发送请求的一个<code>api</code><strong>，拿来跟<code>ajax</code>对比是完全不合理的，它们完全不是一个概念的东西，适合拿来和<code>fetch</code>对比的其实是<code>xhr</code>，也就是上面封装<code>ajax</code>请求的代码里的<code>XMLHttpRequest</code>，这两都是<code>JS</code>自带的发请求的方法，而<code>fetch</code>是<code>ES6</code>出现的，自然功能比xhr更强，主要原因就是它是</strong>基于<code>Promise</code>的，它返回一个<code>Promise</code><strong>，因此可以</strong>使用<code>.then(res =&gt; )</code>的方式链式处理请求结果，这不仅提高了代码的可读性，还避免了回调地狱</strong>(<code>xhr</code>通过<code>xhr.onreadystatechange= () =&gt; &#123;&#125;</code>这样回调的方式监控请求状态，要是想在请求后再发送请求就要在回调函数内再发送请求，这样容易出现回调地狱)的问题。<strong>而且<code>JS</code>自带，语法也非常简洁，几行代码就能发起一个请求，用起来很方便</strong>，据说大佬都爱用。</p>
<p>它的特点是：</p>
<ul>
<li>使用 promise，不使用回调函数。</li>
<li>采用模块化设计，比如 rep、res 等对象分散开来，比较友好。</li>
<li>通过数据流对象处理数据，可以提高网站性能。</li>
</ul>
<p>下面我们简单写个fetch请求的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// get请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/get&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求错误！状态码为：&#x27;</span>, res.<span class="property">status</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">text</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/post&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;no-cors&#x27;</span>,  <span class="comment">// 设置cors表示只能发送跨域的请求，no-cors表示跨不跨域都能发</span></span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3. axios</strong></p>
<p>axios是<strong>用于网络请求的第三方库，它是一个库</strong>。axios<strong>利用xhr进行了二次封装的请求库</strong>，xhr只是axios中的其中一个请求适配器，axios<strong>在nodejs端还有个http的请求适配器</strong>；axios &#x3D; xhr + http；它返回一个<code>Promise</code>。【项目中经常需要封装的axios】</p>
<p>它的特点：</p>
<ul>
<li>在浏览器环境中创建 XMLHttpRequests；在node.js环境创建 http 请求</li>
<li>返回Promise</li>
<li>拦截请求和响应</li>
<li>自动转换 JSON 数据</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
</ul>
<p>它的基础语法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 发送 Get 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;  <span class="comment">// 查询query使用params</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送 Post 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;  <span class="comment">// 请求体body用data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下面我们在vue项目中封装一个使用axios实现的请求。</p>
<p><code>libs/config.js</code>：配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;http://127.0.0.1:8000&quot;</span>, <span class="comment">// 请求基础地址，可根据环境自定义</span></span><br><span class="line">  <span class="attr">useTokenAuthentication</span>: <span class="literal">false</span>, <span class="comment">// 是否开启token认证</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> serverConfig;</span><br></pre></td></tr></table></figure>

<p><code>libs/request.js</code>：封装请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;  <span class="comment">// 第三方库 需要安装</span></span><br><span class="line"><span class="keyword">import</span> serverConfig <span class="keyword">from</span> <span class="string">&quot;./config&quot;</span>;</span><br><span class="line"><span class="comment">// 创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> apiClient = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: serverConfig.<span class="property">baseUrl</span>, <span class="comment">// 基础请求地址</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// 跨域请求是否需要携带cookie</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求发送前的处理逻辑 比如token认证，设置各种请求头啥的</span></span><br><span class="line">    <span class="comment">// 如果开启token认证</span></span><br><span class="line">    <span class="keyword">if</span> (serverConfig.<span class="property">useTokenAuthentication</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求头携带token</span></span><br><span class="line">      config.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 请求发送失败的处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">apiClient.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应数据处理逻辑，比如判断token是否过期等等</span></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 响应数据失败的处理逻辑</span></span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; error.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (error.<span class="property">response</span>.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">302</span>:</span><br><span class="line">          message = <span class="string">&quot;接口重定向了！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">          message = <span class="string">&quot;参数不正确！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          message = <span class="string">&quot;您未登录，或者登录已经超时，请先登录！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          message = <span class="string">&quot;您没有权限操作！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          message = <span class="string">`请求地址出错: <span class="subst">$&#123;error.response.config.url&#125;</span>`</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">          message = <span class="string">&quot;请求超时！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">409</span>:</span><br><span class="line">          message = <span class="string">&quot;系统已存在相同数据！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">          message = <span class="string">&quot;服务器内部错误！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">          message = <span class="string">&quot;服务未实现！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">          message = <span class="string">&quot;网关错误！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">          message = <span class="string">&quot;服务不可用！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">          message = <span class="string">&quot;服务暂时无法访问，请稍后再试！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">          message = <span class="string">&quot;HTTP 版本不受支持！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          message = <span class="string">&quot;异常问题，请联系管理员！&quot;</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> apiClient;</span><br></pre></td></tr></table></figure>

<p><code>/api/index.js</code>：配置请求接口，这里一个get一个post</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">import</span> apiClient <span class="keyword">from</span> <span class="string">&quot;@/libs/request&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getInfo</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">apiClient</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/get&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    params,  <span class="comment">// axios的get请求query用params</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">postInfo</span> = (<span class="params">params</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">apiClient</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/post&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: params,  <span class="comment">// axios的post请求body用data</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  getInfo,</span><br><span class="line">  postInfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>：用于测试请求结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&#x27;./api/index.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">isH5</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">            api.<span class="title function_">getInfo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            api.<span class="title function_">postInfo</span>(&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/28.png"></p>
<h3 id="18-promise有几种状态"><a href="#18-promise有几种状态" class="headerlink" title="18.promise有几种状态"></a>18.promise有几种状态</h3><ol>
<li><p><strong>Pending（待定）</strong>：Promise 对象刚被创建时的初始状态，表示还没有被执行或者被拒绝。</p>
</li>
<li><p><strong>Fulfilled（已完成）</strong>：表示操作成功完成，Promise 对象的状态从 Pending 变为 Fulfilled，意味着异步操作已经成功完成，且相应的结果已经被返回。</p>
</li>
<li><p><strong>Rejected（已拒绝）</strong>：表示操作失败，Promise 对象的状态从 Pending 变为 Rejected，意味着异步操作失败或者出错，且相应的错误信息被返回。</p>
</li>
</ol>
<h3 id="19-promise状态有几个过程"><a href="#19-promise状态有几个过程" class="headerlink" title="19.promise状态有几个过程"></a>19.promise状态有几个过程</h3><p>Promise 对象会从 Pending 状态转换为 Fulfilled 或 Rejected 状态，一旦转换完成，Promise 的状态就不会再发生变化。此外，Promise 的状态一旦发生变化，就会立即执行相应的状态处理函数，即 then 方法的回调函数或 catch 方法的回调函数。</p>
<h3 id="20-组件结构包含哪几个部分"><a href="#20-组件结构包含哪几个部分" class="headerlink" title="20.组件结构包含哪几个部分"></a>20.组件结构包含哪几个部分</h3><p>在 Vue 中，一个组件通常由三个部分组成：</p>
<ol>
<li><strong>模板（Template）</strong>：模板定义了组件的结构，以及组件中所需的 HTML 结构和 Vue 模板语法。模板是组件的可视化部分，决定了组件在页面上的呈现方式。</li>
<li><strong>脚本（Script）</strong>：脚本定义了组件的行为和逻辑。在脚本中，你可以定义组件的数据、计算属性、方法、生命周期钩子等。通常，脚本是使用 JavaScript 或 TypeScript 编写的。</li>
<li><strong>样式（Style）</strong>：样式定义了组件的外观和样式。你可以使用 CSS、Sass、Less 等方式来编写组件的样式。Vue 支持在单文件组件中使用 <code>&lt;style&gt;</code> 标签来定义组件的样式，也支持 CSS 模块化和预处理器等特性。</li>
</ol>
<h3 id="21-怎么接收传递过来的方法"><a href="#21-怎么接收传递过来的方法" class="headerlink" title="21.怎么接收传递过来的方法"></a>21.怎么接收传递过来的方法</h3><ul>
<li>父组件 Parent.vue 通过 props 将一个名为 callback 的方法传递给子组件 Child.vue。</li>
<li>子组件 Child.vue 使用 props 来声明接收父组件传递过来的方法，并在需要的时候调用该方法。</li>
</ul>
<p>通过这种方式，子组件就可以与父组件进行通信，从而实现了方法的传递和调用。</p>
<h3 id="22-JS数据的基本类型有哪些？"><a href="#22-JS数据的基本类型有哪些？" class="headerlink" title="22.JS数据的基本类型有哪些？"></a>22.JS数据的基本类型有哪些？</h3><p>JavaScript 的基本数据类型包括：</p>
<ol>
<li><strong>字符串（String）</strong></li>
<li><strong>数字（Number）</strong></li>
<li><strong>布尔值（Boolean）</strong></li>
<li><strong>空值（Null）</strong></li>
<li><strong>未定义（Undefined）</strong></li>
<li><strong>符号（Symbol）</strong></li>
<li><strong>BigInt（BigInt）</strong></li>
</ol>
<h3 id="23-通过中间件实现文件上传，文件上传是怎么实现的"><a href="#23-通过中间件实现文件上传，文件上传是怎么实现的" class="headerlink" title="23.通过中间件实现文件上传，文件上传是怎么实现的"></a>23.通过中间件实现文件上传，文件上传是怎么实现的</h3><h3 id="24-用input来实现，怎么实现"><a href="#24-用input来实现，怎么实现" class="headerlink" title="24.用input来实现，怎么实现"></a>24.用input来实现，怎么实现</h3><p>使用 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素可以实现简单的文件上传功能。下面是一个基本的示例，演示了如何通过 <code>&lt;input&gt;</code> 元素来实现文件上传：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>File Upload Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;uploadForm&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;uploadForm&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      e.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">      formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/upload&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">body</span>: formData</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span></span><br><span class="line"><span class="language-javascript">        resultDiv.<span class="property">textContent</span> = data.<span class="property">message</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125; <span class="keyword">catch</span> (error) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error uploading file:&#x27;</span>, error);</span></span><br><span class="line"><span class="language-javascript">        resultDiv.<span class="property">textContent</span> = <span class="string">&#x27;Error uploading file.&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中：</p>
<ul>
<li>我们使用了 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素来创建文件上传的表单字段。</li>
<li>用户可以点击该元素来选择要上传的文件。</li>
<li>我们监听了表单的 submit 事件，阻止了默认的表单提交行为。</li>
<li>在提交事件处理程序中，我们使用 FormData 对象来构建一个包含上传文件的表单数据。</li>
<li>然后，我们使用 Fetch API 来发送 POST 请求到服务器的 ‘&#x2F;upload’ 路径，并将 FormData 对象作为请求体。</li>
<li>最后，我们将服务器返回的消息显示在页面上。</li>
</ul>
<p>需要注意的是，这只是一个前端的示例，后端的上传处理逻辑需要根据具体的后端框架来实现。</p>
<h3 id="25-什么情况会出现跨域请求"><a href="#25-什么情况会出现跨域请求" class="headerlink" title="25.什么情况会出现跨域请求"></a>25.什么情况会出现跨域请求</h3><p>跨域请求（Cross-Origin Request）是指在浏览器中，当当前页面的域名、协议、端口与请求目标不一致时，发起的 HTTP 请求就会被认为是跨域请求。跨域请求可能会导致一些安全性问题，因此浏览器会限制跨域请求的执行。</p>
<p>以下情况会导致跨域请求发生：</p>
<ol>
<li><p><strong>不同域名</strong>：最常见的情况是请求的域名不同，例如从 <code>example.com</code> 的页面向 <code>api.example.com</code> 发起请求。</p>
</li>
<li><p><strong>不同协议</strong>：如果当前页面使用了 <code>http://</code>，而请求目标是 <code>https://</code>，也会被视为跨域请求。</p>
</li>
<li><p><strong>不同端口</strong>：即使是同一个域名，但如果端口不同（例如一个在 <code>http://example.com:8080</code>，另一个在 <code>http://example.com:3000</code>），也会被认为是跨域请求。</p>
</li>
<li><p><strong>不同子域名</strong>：不同的子域名之间（如 <code>a.example.com</code> 和 <code>b.example.com</code>）也被认为是不同的域名，会触发跨域请求。</p>
</li>
</ol>
<p>跨域请求会受到同源策略（Same Origin Policy）的限制，同源策略是浏览器为了保护用户信息安全而实施的一种安全机制，它限制了一个页面中的脚本只能与其来源相同的资源进行交互。为了在跨域请求时安全可控，可以通过跨域资源共享（CORS）、JSONP、代理等方式来解决跨域请求的问题。</p>
<h3 id="26-防抖和节流的区别"><a href="#26-防抖和节流的区别" class="headerlink" title="26.防抖和节流的区别"></a>26.防抖和节流的区别</h3><p>防抖（Debounce）和节流（Throttle）是用于控制函数执行频率的两种常见技术，它们都可以用于优化性能和提升用户体验，但它们的原理和应用场景略有不同。</p>
<ol>
<li><p><strong>防抖（Debounce）</strong>：</p>
<ul>
<li>防抖是指在事件触发后等待一定时间间隔后执行函数，如果在等待时间内又触发了该事件，则重新计时，直到事件停止触发，最后一次执行函数。</li>
<li>防抖适用于需要等待用户停止操作后执行的场景，如输入框输入事件、滚动事件等。</li>
<li>举例：当用户在输入框中连续输入文字时，如果每次输入都触发搜索请求，会造成频繁的请求，影响性能。通过防抖技术，可以等待用户停止输入一段时间后再发起搜索请求，避免频繁请求服务器。</li>
</ul>
</li>
<li><p><strong>节流（Throttle）</strong>：</p>
<ul>
<li>节流是指在一定时间间隔内只执行一次函数，即使事件在间隔内被触发多次，也只会执行一次函数。</li>
<li>节流适用于需要控制函数执行频率的场景，如页面滚动事件、resize 事件等。</li>
<li>举例：当用户滚动页面时，如果滚动事件处理函数需要执行昂贵的计算或者频繁的 DOM 操作，可以通过节流技术控制滚动事件处理函数的执行频率，减少不必要的计算和操作，提高性能。</li>
</ul>
</li>
</ol>
<p>总结来说，防抖是为了防止函数在短时间内被频繁调用，而节流是为了控制函数在一定时间间隔内的执行频率。两者在实现上有所不同，但都能有效地优化函数执行的性能。选择使用哪种技术取决于具体的应用场景和需求。</p>
<h3 id="27-定时器了解吗"><a href="#27-定时器了解吗" class="headerlink" title="27.定时器了解吗"></a>27.定时器了解吗</h3><p>是的，定时器是一种常见的编程工具，用于在一定的时间间隔后执行特定的代码或者在特定的时间点执行代码。在 JavaScript 中，有两种常见的定时器：<code>setTimeout</code> 和 <code>setInterval</code>。</p>
<ol>
<li><p><strong>setTimeout</strong>：</p>
<ul>
<li><code>setTimeout</code> 函数用于在指定的延迟之后执行一次特定的代码。</li>
<li>它接受两个参数：要执行的函数和延迟的毫秒数。</li>
<li>例如，下面的代码会在 1000 毫秒（1 秒）后输出 “Hello, world!”：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>setInterval</strong>：</p>
<ul>
<li><code>setInterval</code> 函数用于在每个指定的时间间隔执行特定的代码，直到被清除。</li>
<li>它接受两个参数：要执行的函数和时间间隔的毫秒数。</li>
<li>例如，下面的代码会每隔 2000 毫秒（2 秒）输出一次 “Hello, world!”：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>需要注意的是，尽管定时器可以实现一些功能，但过度使用定时器可能会导致性能问题或者不可预料的行为，特别是在处理异步操作时。因此，在使用定时器时应谨慎考虑其影响，并确保适当地管理定时器，避免内存泄漏或其他问题。</p>
<h3 id="28-怎么移除定时器"><a href="#28-怎么移除定时器" class="headerlink" title="28.怎么移除定时器"></a>28.怎么移除定时器</h3><p>要移除定时器，可以使用 <code>clearTimeout</code> 和 <code>clearInterval</code> 函数，具体取决于你使用的是 <code>setTimeout</code> 还是 <code>setInterval</code>。</p>
<ol>
<li><p><strong>移除 setTimeout</strong>：</p>
<ul>
<li>使用 <code>clearTimeout</code> 函数来移除由 <code>setTimeout</code> 创建的定时器。</li>
<li><code>clearTimeout</code> 接受一个参数，即 <code>setTimeout</code> 返回的定时器标识符（ID）。</li>
<li>例如，下面的代码创建了一个 setTimeout 定时器，并在 1000 毫秒后移除它：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除定时器</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timerId);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除 setInterval</strong>：</p>
<ul>
<li>使用 <code>clearInterval</code> 函数来移除由 <code>setInterval</code> 创建的定时器。</li>
<li><code>clearInterval</code> 接受一个参数，即 <code>setInterval</code> 返回的定时器标识符（ID）。</li>
<li>例如，下面的代码创建了一个 setInterval 定时器，并在 2000 毫秒后移除它：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timerId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除定时器</span></span><br><span class="line"><span class="built_in">clearInterval</span>(timerId);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>需要注意的是，传递给 <code>clearTimeout</code> 或 <code>clearInterval</code> 的定时器标识符必须是由对应的 <code>setTimeout</code> 或 <code>setInterval</code> 返回的有效标识符。否则，移除操作将无效。因此，在创建定时器时，应该保存返回的定时器标识符，以便在需要时移除定时器。</p>
<h3 id="29-表单组件的自定义UI，支持渲染多种结构"><a href="#29-表单组件的自定义UI，支持渲染多种结构" class="headerlink" title="29.表单组件的自定义UI，支持渲染多种结构"></a>29.表单组件的自定义UI，支持渲染多种结构</h3><h3 id="30-element-ui表单已经写好了一套"><a href="#30-element-ui表单已经写好了一套" class="headerlink" title="30.element-ui表单已经写好了一套"></a>30.element-ui表单已经写好了一套</h3><h3 id="31-浏览器请求一个网站，会做什么操作"><a href="#31-浏览器请求一个网站，会做什么操作" class="headerlink" title="31.浏览器请求一个网站，会做什么操作"></a>31.浏览器请求一个网站，会做什么操作</h3><p>当浏览器请求一个网站时，通常会执行以下操作：</p>
<ol>
<li><p><strong>DNS 解析</strong>：浏览器首先会将网址解析成对应的 IP 地址，这个过程称为 DNS 解析。浏览器会首先查询本地缓存中是否有对应的 DNS 记录，如果没有，就会向 DNS 服务器发送请求，获取域名对应的 IP 地址。</p>
</li>
<li><p><strong>建立 TCP 连接</strong>：浏览器通过 IP 地址向目标服务器发起 TCP 连接。在 TCP 握手过程中，客户端和服务器会交换一些信息，确认双方可以通信。</p>
</li>
<li><p><strong>发送 HTTP 请求</strong>：建立 TCP 连接后，浏览器会向服务器发送 HTTP 请求，请求网站的资源。HTTP 请求包括请求行、请求头和请求体等信息，其中请求行包含请求方法（GET、POST 等）、请求的 URL 和协议版本等。</p>
</li>
<li><p><strong>服务器处理请求</strong>：服务器接收到浏览器发送的请求后，会根据请求的 URL 和其他信息，执行相应的处理逻辑。这可能涉及到动态生成内容、查询数据库、调用后端服务等操作。</p>
</li>
<li><p><strong>返回 HTTP 响应</strong>：服务器处理完请求后，会将处理结果封装成 HTTP 响应返回给浏览器。HTTP 响应包括响应行、响应头和响应体等信息，其中响应行包含状态码（例如 200、404 等）和协议版本等。</p>
</li>
<li><p><strong>接收响应并渲染页面</strong>：浏览器接收到服务器返回的 HTTP 响应后，会根据响应的内容进行相应的处理。如果请求的是 HTML 页面，浏览器会解析 HTML、CSS 和 JavaScript，并渲染页面；如果请求的是其他类型的资源（如图片、视频、样式表等），浏览器会根据相应的类型进行处理和展示。</p>
</li>
<li><p><strong>关闭 TCP 连接</strong>：页面加载完成后，浏览器会关闭与服务器的 TCP 连接，释放资源。</p>
</li>
</ol>
<p>这是一个简化的浏览器请求网站的过程，实际过程中可能还涉及到缓存、重定向、安全验证等其他操作。</p>
<h3 id="32-前端缓存有哪几种？"><a href="#32-前端缓存有哪几种？" class="headerlink" title="32.前端缓存有哪几种？"></a>32.前端缓存有哪几种？</h3><p>前端缓存主要分为以下几种：</p>
<ol>
<li><p><strong>浏览器缓存</strong>：</p>
<ul>
<li>浏览器缓存是指浏览器在本地保存已经访问过的资源副本，以便在下次访问相同资源时能够直接从本地加载，而不必重新请求服务器。</li>
<li>浏览器缓存可以分为强缓存和协商缓存两种方式。强缓存是根据资源的缓存控制头（例如 Cache-Control 和 Expires）判断是否使用本地缓存，而协商缓存则是通过与服务器协商确定是否使用缓存。</li>
</ul>
</li>
<li><p><strong>Service Worker 缓存</strong>：</p>
<ul>
<li>Service Worker 是运行在浏览器后台的 JavaScript 脚本，可以拦截和处理网络请求。</li>
<li>Service Worker 可以用来实现高级的缓存策略，如离线缓存、动态缓存、预加载等，从而提高应用的性能和可靠性。</li>
</ul>
</li>
<li><p><strong>Web Storage</strong>：</p>
<ul>
<li>Web Storage 包括 localStorage 和 sessionStorage 两种 API，用于在浏览器中保存键值对数据。</li>
<li>localStorage 数据在浏览器关闭后仍然保留，直到用户手动清除；而 sessionStorage 数据仅在当前会话中有效，关闭标签页或浏览器后即被删除。</li>
</ul>
</li>
<li><p><strong>IndexedDB</strong>：</p>
<ul>
<li>IndexedDB 是浏览器提供的一种客户端数据库，用于在浏览器中保存大量结构化数据。</li>
<li>IndexedDB 允许开发者在客户端存储和检索数据，并支持事务操作和索引查询，适用于需要离线访问大量数据的应用场景。</li>
</ul>
</li>
<li><p><strong>Cookie</strong>：</p>
<ul>
<li>Cookie 是一种在浏览器和服务器之间传递的小型文本文件，用于存储用户的身份认证信息、会话状态等。</li>
<li>Cookie 可以设置过期时间，可以在浏览器关闭后仍然保留，也可以在不同的页面之间共享数据。</li>
</ul>
</li>
</ol>
<p>这些前端缓存技术各有特点，可以根据具体的应用场景选择合适的缓存策略来提高页面性能和用户体验。</p>
<h3 id="33-Localstoreage的有效期是多久"><a href="#33-Localstoreage的有效期是多久" class="headerlink" title="33.Localstoreage的有效期是多久"></a>33.Localstoreage的有效期是多久</h3><p>LocalStorage 的数据没有固定的过期时间，它的数据会一直保存在浏览器中，直到用户手动删除或者清除浏览器缓存。因此，LocalStorage 中存储的数据是持久化的，不受会话的影响。</p>
<p>需要注意的是，LocalStorage 存储的数据是以域名为单位进行存储的，不同域名之间的数据是相互隔离的。另外，由于LocalStorage是以字符串的形式存储数据的，因此存储的数据量是受限的，一般为 5MB 到 10MB 左右，不同浏览器的限制可能会有所不同。</p>
<h3 id="34-session的有效期呢"><a href="#34-session的有效期呢" class="headerlink" title="34.session的有效期呢"></a>34.session的有效期呢</h3><p>Session 的有效期是在用户关闭浏览器或者长时间不活动后，服务器会自动清除用户的会话数据，从而使会话失效。具体的失效时间取决于服务器的配置和会话管理策略。</p>
<p>一般情况下，Session 的有效期由服务器端管理，可以通过设置会话超时时间来控制。在大多数 Web 服务器和 Web 框架中，会话超时时间可以在配置文件中进行设置，通常以分钟为单位。一旦用户在一段时间内没有与服务器进行交互，会话就会失效，并且用户需要重新进行身份验证或重新登录。</p>
<p>需要注意的是，Session 的失效时间是相对灵活的，它可以根据应用的需求和安全考虑进行调整。一般情况下，Session 的超时时间设置得太长可能会增加安全风险，而设置得太短则可能影响用户体验。因此，合理设置 Session 的有效期是很重要的。</p>
<h3 id="35-cookie知道吗"><a href="#35-cookie知道吗" class="headerlink" title="35.cookie知道吗"></a>35.cookie知道吗</h3><p>当然，我了解 Cookie。Cookie 是在客户端（浏览器）和服务器之间传递的小型文本文件，用于存储用户的身份认证信息、会话状态等。Cookie 通常由服务器发送给浏览器，并由浏览器存储在用户的计算机上。</p>
<p>以下是一些关于 Cookie 的重要信息：</p>
<ol>
<li><p><strong>存储位置</strong>：Cookie 存储在用户的计算机上，通常保存在浏览器的 Cookie 文件夹中。</p>
</li>
<li><p><strong>作用域</strong>：Cookie 是与特定的域名相关联的，不同域名之间的 Cookie 是相互隔离的，一个域名设置的 Cookie 无法被其他域名访问。</p>
</li>
<li><p><strong>过期时间</strong>：Cookie 可以设置过期时间，超过过期时间后，Cookie 将被自动删除。如果不设置过期时间，那么 Cookie 将成为会话 Cookie，会随着浏览器的关闭而被删除。</p>
</li>
<li><p><strong>安全属性</strong>：可以通过设置 Cookie 的 Secure 属性，使其只能在使用 HTTPS 协议时被发送到服务器，增加了 Cookie 的安全性。</p>
</li>
<li><p><strong>HttpOnly 属性</strong>：设置了 HttpOnly 属性的 Cookie 不能通过 JavaScript 脚本来访问，这样可以减少 XSS 攻击的风险。</p>
</li>
<li><p><strong>SameSite 属性</strong>：设置 SameSite 属性可以防止跨站点请求伪造（CSRF）攻击，它定义了 Cookie 在跨站点请求中是否可以被发送。</p>
</li>
</ol>
<p>Cookie 在 Web 开发中广泛用于实现用户身份认证、会话管理、跟踪用户行为等功能。然而，由于 Cookie 是存储在用户计算机上的敏感数据，因此在使用 Cookie 时需要注意安全性和隐私保护。</p>
<h3 id="36-css盒子模型"><a href="#36-css盒子模型" class="headerlink" title="36.css盒子模型"></a>36.css盒子模型</h3><p>CSS 盒子模型是 CSS 中用于布局的基本概念之一，它描述了在网页中的每个元素都被看作是一个矩形的盒子，并且这个盒子具有内容区域、内边距、边框和外边距四个部分组成。</p>
<p>盒子模型包含以下几个部分：</p>
<ol>
<li><p><strong>内容区域（Content）</strong>：内容区域包含了元素的实际内容，例如文本、图片等。内容区域的大小由元素的宽度（width）和高度（height）属性来确定。</p>
</li>
<li><p><strong>内边距（Padding）</strong>：内边距是内容区域与边框之间的空白区域，用于控制内容与边框之间的间距。内边距可以通过 <code>padding</code> 属性来设置，分为上、右、下、左四个方向的值，也可以使用 <code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code> 分别设置。</p>
</li>
<li><p><strong>边框（Border）</strong>：边框是围绕在内容区域和内边距外部的线条或者区域，用于装饰和分隔元素。边框的样式、宽度和颜色可以通过 <code>border</code> 属性来设置。</p>
</li>
<li><p><strong>外边距（Margin）</strong>：外边距是元素与其相邻元素之间的空白区域，用于控制元素与其他元素之间的间距。外边距可以通过 <code>margin</code> 属性来设置，分为上、右、下、左四个方向的值，也可以使用 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code>、<code>margin-left</code> 分别设置。</p>
</li>
</ol>
<p>盒子模型的宽度和高度计算方式为：内容区域的宽度&#x2F;高度 + 内边距 + 边框。外边距不会影响盒子的实际大小，而是会影响盒子与其他盒子之间的距离。</p>
<p>在 CSS 中，可以通过设置 <code>box-sizing</code> 属性来控制盒子模型的计算方式，常见的取值有 <code>content-box</code> 和 <code>border-box</code>。<code>content-box</code> 是默认值，表示盒子的宽度和高度只包括内容区域；<code>border-box</code> 表示盒子的宽度和高度包括内容区域、内边距和边框。</p>
<h3 id="37-正常的盒子模型包含什么"><a href="#37-正常的盒子模型包含什么" class="headerlink" title="37.正常的盒子模型包含什么"></a>37.正常的盒子模型包含什么</h3><p>正常的盒子模型包含以下几个部分：</p>
<ol>
<li><p><strong>内容区域（Content）</strong>：内容区域包含了元素的实际内容，例如文本、图片等。内容区域的大小由元素的宽度（width）和高度（height）属性来确定。</p>
</li>
<li><p><strong>内边距（Padding）</strong>：内边距是内容区域与边框之间的空白区域，用于控制内容与边框之间的间距。内边距可以通过 <code>padding</code> 属性来设置，分为上、右、下、左四个方向的值，也可以使用 <code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code> 分别设置。</p>
</li>
<li><p><strong>边框（Border）</strong>：边框是围绕在内容区域和内边距外部的线条或者区域，用于装饰和分隔元素。边框的样式、宽度和颜色可以通过 <code>border</code> 属性来设置。</p>
</li>
<li><p><strong>外边距（Margin）</strong>：外边距是元素与其相邻元素之间的空白区域，用于控制元素与其他元素之间的间距。外边距可以通过 <code>margin</code> 属性来设置，分为上、右、下、左四个方向的值，也可以使用 <code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code>、<code>margin-left</code> 分别设置。</p>
</li>
</ol>
<p>这些部分共同构成了一个元素的盒子模型，通过设置这些属性可以控制元素的大小、间距、边框样式等，从而实现网页布局和样式设计。</p>
<h3 id="38-垂直居中的方式"><a href="#38-垂直居中的方式" class="headerlink" title="38.垂直居中的方式"></a>38.垂直居中的方式</h3><p>实现垂直居中的方式有多种，以下是其中几种常见的方法：</p>
<ol>
<li><p><strong>使用 Flexbox</strong>：<br>使用 Flexbox 是实现垂直居中的最简单和最常用的方法之一。可以通过设置容器的 <code>display: flex;</code> 和 <code>align-items: center;</code> 来使其内部元素垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Grid Layout</strong>：<br>类似于 Flexbox，使用 CSS Grid 也可以实现垂直居中。通过设置容器的 <code>display: grid;</code> 和 <code>align-items: center;</code> 来使其内部元素垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用绝对定位和 transform</strong>：<br>可以使用绝对定位和 CSS3 的 transform 属性来实现垂直居中。首先将元素定位到父容器的中心，然后使用 <code>translateY(-50%)</code> 将其向上移动一半高度，从而实现垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用表格布局</strong>：<br>将父容器设置为表格布局，然后使用 <code>vertical-align: middle;</code> 将其内部元素垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法中，Flexbox 是最常用且最推荐的一种方式，因为它简单易用且兼容性良好。根据具体的布局需求和兼容性要求，选择适合的方法来实现垂直居中。</p>
<h3 id="39-flex布局有了解吗"><a href="#39-flex布局有了解吗" class="headerlink" title="39.flex布局有了解吗"></a>39.flex布局有了解吗</h3><p>是的，Flexbox 是 CSS3 中引入的一种用于布局的模型，也称为弹性盒子布局（Flexible Box Layout）。Flexbox 提供了一种更加灵活的方式来布局元素，特别适用于构建响应式和动态布局。</p>
<p>Flexbox 的主要特点包括：</p>
<ol>
<li><p><strong>一维布局</strong>：Flexbox 是一种一维布局模型，可以控制元素在水平或垂直方向上的排列方式。</p>
</li>
<li><p><strong>弹性容器和弹性项目</strong>：Flexbox 将布局的容器称为弹性容器（flex container），容器内的子元素称为弹性项目（flex item）。通过设置弹性容器和弹性项目的属性，可以实现灵活的布局效果。</p>
</li>
<li><p><strong>主轴和交叉轴</strong>：在 Flexbox 中，主轴（main axis）是弹性容器的主要方向，而交叉轴（cross axis）是与主轴垂直的方向。可以通过设置 <code>flex-direction</code> 属性来指定主轴的方向。</p>
</li>
<li><p><strong>弹性布局</strong>：Flexbox 提供了多种属性来控制弹性项目在主轴和交叉轴上的大小、顺序和对齐方式，包括 <code>justify-content</code>、<code>align-items</code>、<code>align-self</code> 等。</p>
</li>
<li><p><strong>自适应性</strong>：Flexbox 可以根据容器的大小自动调整弹性项目的布局，适应不同屏幕尺寸和设备方向的变化。</p>
</li>
<li><p><strong>适用范围广</strong>：Flexbox 的兼容性良好，适用于现代浏览器以及移动端应用开发。</p>
</li>
</ol>
<p>使用 Flexbox 可以简化网页布局的实现，提高布局的灵活性和响应性，是前端开发中常用的布局方式之一。</p>
<h3 id="40-这个布局要用哪个属性怎么换行"><a href="#40-这个布局要用哪个属性怎么换行" class="headerlink" title="40.这个布局要用哪个属性怎么换行"></a>40.这个布局要用哪个属性怎么换行</h3><p>在 Flexbox 布局中，要控制换行可以使用 <code>flex-wrap</code> 属性。该属性用于控制弹性项目是否换行以及换行的方式。</p>
<p>具体来说，<code>flex-wrap</code> 属性有以下几个可能的取值：</p>
<ul>
<li><code>nowrap</code>（默认值）：弹性项目不换行，所有项目都尽可能地放在一行上。</li>
<li><code>wrap</code>：弹性项目在必要的时候换行，第一行在顶部，下一行在其下方。</li>
<li><code>wrap-reverse</code>：弹性项目在必要的时候换行，第一行在底部，下一行在其上方。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap; <span class="comment">/* 控制弹性项目换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>.container</code> 是弹性容器，通过设置 <code>flex-wrap: wrap;</code> 属性，可以使弹性项目在必要的时候换行。</p>
<h3 id="41-css自适应单位"><a href="#41-css自适应单位" class="headerlink" title="41.css自适应单位"></a>41.css自适应单位</h3><p>在 CSS 中，自适应单位通常指的是相对长度单位，这些单位相对于视口或者父元素的大小进行自适应调整，可以使得页面在不同设备上有更好的适应性和可读性。常见的自适应单位包括：</p>
<ol>
<li><p><strong>相对长度单位</strong>：</p>
<ul>
<li><strong>vw（视口宽度单位）</strong>：相对于视口宽度的百分比，1vw 等于视口宽度的 1%。例如，<code>width: 50vw;</code> 表示元素的宽度为视口宽度的一半。</li>
<li><strong>vh（视口高度单位）</strong>：相对于视口高度的百分比，1vh 等于视口高度的 1%。例如，<code>height: 80vh;</code> 表示元素的高度为视口高度的 80%。</li>
<li><strong>%（百分比）</strong>：相对于父元素的百分比，例如，<code>width: 50%;</code> 表示元素的宽度为父元素宽度的一半。</li>
</ul>
</li>
<li><p><strong>rem（根元素单位）</strong>：</p>
<ul>
<li>rem（root em）单位是相对于根元素（html 元素）的字体大小的单位。例如，如果根元素的字体大小为 16px，那么 1rem 就等于 16px。</li>
<li>rem 单位的优势在于可以方便地调整整个页面的大小比例，特别适用于响应式设计。</li>
</ul>
</li>
<li><p><strong>em（相对单位）</strong>：</p>
<ul>
<li>em 单位是相对于元素自身的字体大小的单位。例如，如果元素的字体大小为 16px，那么 1em 就等于 16px。</li>
<li>em 单位可以方便地相对于元素的字体大小进行调整，但是相对于父元素字体大小的计算可能会产生累加效应。</li>
</ul>
</li>
</ol>
<p>这些自适应单位可以使得网页布局和样式设计更具有灵活性和可读性，有助于实现响应式设计和移动端适配。</p>
<h3 id="42-vh-vw有用过吗"><a href="#42-vh-vw有用过吗" class="headerlink" title="42.vh vw有用过吗"></a>42.vh vw有用过吗</h3><p>是的，<code>vw</code> 和 <code>vh</code> 是视口单位，分别表示相对于视口宽度和视口高度的百分比。它们常用于制作响应式布局或者适配移动设备。</p>
<p>举个例子，假设你希望一个元素的宽度始终是视口宽度的一半，可以这样设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样无论用户在什么尺寸的屏幕上查看页面，这个元素的宽度都会自动调整为视口宽度的一半。同样地，如果你希望一个元素的高度始终是视口高度的一半，可以使用 <code>vh</code> 单位。</p>
<p>这些视口单位非常适合在响应式设计中使用，它们使得网页元素能够根据浏览器窗口的大小进行自适应调整，从而提供更好的用户体验。</p>
<h3 id="43-媒体查询"><a href="#43-媒体查询" class="headerlink" title="43.媒体查询"></a>43.媒体查询</h3><p>媒体查询（Media Queries）是 CSS3 中的一种技术，它允许你根据设备特性和特定的媒体类型来应用不同的 CSS 样式。媒体查询通常用于实现响应式设计，使得网页能够在不同的设备上以不同的布局和样式呈现，从而适应不同的屏幕尺寸、分辨率、设备方向等。</p>
<p>媒体查询的语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span> (media feature) &#123;</span><br><span class="line">  <span class="comment">/* CSS 样式规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>mediatype</code> 可以是以下几种媒体类型之一：</p>
<ul>
<li><code>all</code>：所有设备。</li>
<li><code>print</code>：打印机和打印预览。</li>
<li><code>screen</code>：电脑屏幕、平板电脑、智能手机等。</li>
<li><code>speech</code>：屏幕阅读器。</li>
</ul>
<p><code>media feature</code> 是一个表示设备特性的表达式，常用的包括：</p>
<ul>
<li><code>width</code>：视口宽度。</li>
<li><code>height</code>：视口高度。</li>
<li><code>orientation</code>：设备方向（横向或纵向）。</li>
<li><code>aspect-ratio</code>：视口的宽高比。</li>
<li><code>resolution</code>：设备屏幕的分辨率。</li>
</ul>
<p>例如，以下是一个简单的媒体查询示例，当视口宽度小于等于 600px 时应用不同的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="comment">/* 应用于宽度小于等于 600px 的屏幕 */</span></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询使得网页能够根据不同设备和浏览器的特性来自适应布局和样式，提供更好的用户体验。</p>
<h3 id="44-css的媒体查询有了解吗"><a href="#44-css的媒体查询有了解吗" class="headerlink" title="44.css的媒体查询有了解吗"></a>44.css的媒体查询有了解吗</h3><p><img src="/../images/%E5%85%AB%E8%82%A1%E6%96%87/29.png"></p>
<p>媒体查询（Media Queries）是 CSS3 中的一种功能，它允许你根据设备的特性和特定的媒体类型来应用不同的 CSS 样式。媒体查询通常用于实现响应式设计，使得网页能够在不同的设备上以不同的布局和样式呈现，从而适应不同的屏幕尺寸、分辨率、设备方向等。</p>
<p>媒体查询的语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span> (media feature) &#123;</span><br><span class="line">  <span class="comment">/* CSS 样式规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>mediatype</code> 可以是以下几种媒体类型之一：</p>
<ul>
<li><code>all</code>：所有设备。</li>
<li><code>print</code>：打印机和打印预览。</li>
<li><code>screen</code>：电脑屏幕、平板电脑、智能手机等。</li>
<li><code>speech</code>：屏幕阅读器。</li>
</ul>
<p><code>media feature</code> 是一个表示设备特性的表达式，常用的包括：</p>
<ul>
<li><code>width</code>：视口宽度。</li>
<li><code>height</code>：视口高度。</li>
<li><code>orientation</code>：设备方向（横向或纵向）。</li>
<li><code>aspect-ratio</code>：视口的宽高比。</li>
<li><code>resolution</code>：设备屏幕的分辨率。</li>
</ul>
<p>例如，以下是一个简单的媒体查询示例，当视口宽度小于等于 600px 时应用不同的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="comment">/* 应用于宽度小于等于 600px 的屏幕 */</span></span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询使得网页能够根据不同设备和浏览器的特性来自适应布局和样式，提供更好的用户体验。</p>
<p>45.反问<br>我的表现<br>后续流程<br>实习生做什么和技术栈</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">黑板擦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/26/%E5%85%AB%E8%82%A1%E6%96%87/">http://example.com/2024/04/26/%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">我在看着你</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/./img/Snipaste_2024-04-06_01-13-21.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/27/ArK/" title="ArK"><img class="cover" src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ArK</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/15/scss/" title="scss"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">scss</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/Snipaste_2024-04-06_01-08-30.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">黑板擦</div><div class="author-info__description">别看我</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Yukino013" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1291469690@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">HTML篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-src%E5%92%8Chref%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1.src和href的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Html5%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">2.Html5新增特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">语义化标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">增强表单属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E9%9F%B3%E8%A7%86%E9%A2%91%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">新增音视频标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%BB%E5%B8%83canvas"><span class="toc-number">1.2.4.</span> <span class="toc-text">画布canvas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG%E7%BB%98%E5%9B%BE"><span class="toc-number">1.2.5.</span> <span class="toc-text">SVG绘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG%E4%B8%8ECanvas%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.2.6.</span> <span class="toc-text">SVG与Canvas的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%96%E6%8B%89%E6%8B%BDAPI"><span class="toc-number">1.2.7.</span> <span class="toc-text">拖拉拽API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebStorage"><span class="toc-number">1.2.8.</span> <span class="toc-text">WebStorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-number">1.2.9.</span> <span class="toc-text">WebSocket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DOCTYPE-%E2%BD%82%E6%A1%A3%E7%B1%BB%E5%9E%8B-%E7%9A%84%E4%BD%9C%E2%BD%A4"><span class="toc-number">1.3.</span> <span class="toc-text">3.DOCTYPE(⽂档类型) 的作⽤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-iframe-%E6%9C%89%E9%82%A3%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.iframe 有那些优点和缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-script%E6%A0%87%E7%AD%BE%E4%B8%ADdefer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5.script标签中defer和async的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E3%80%81%E8%A1%8C%E5%86%85%E5%9D%97%E5%85%83%E7%B4%A0%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">6.块级元素、行内元素、行内块元素区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">块级元素有以下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">行内元素有以下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%85%B7%E4%BD%93%E7%89%B9%E7%82%B9%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.6.3.</span> <span class="toc-text">行内块级元素具体特点如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-display"><span class="toc-number">1.6.4.</span> <span class="toc-text">元素类型转换 display</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.</span> <span class="toc-text">7.怎样添加、移除、移动、复制、创建和查找节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">CSS篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">1.设置背景透明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CSS3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">2.CSS3新增特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9ECSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E4%BC%AA%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">新增CSS选择器、伪类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">组合选择器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%95%88%EF%BC%9Atext-shadow%E3%80%81box-shadow"><span class="toc-number">2.2.2.</span> <span class="toc-text">特效：text-shadow、box-shadow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98-gradient"><span class="toc-number">2.2.3.</span> <span class="toc-text">线性渐变: gradient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E8%BF%87%E6%B8%A1%EF%BC%9Atransform%E3%80%81transtion"><span class="toc-number">2.2.4.</span> <span class="toc-text">旋转过渡：transform、transtion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB-animation"><span class="toc-number">2.2.5.</span> <span class="toc-text">动画: animation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%86%E8%A7%92-border-radius"><span class="toc-number">2.2.6.</span> <span class="toc-text">圆角: border-radius</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%AA%E5%85%83%E7%B4%A0%E5%92%8C%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.伪元素和伪类的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">4.隐藏元素的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%89%E4%BA%86%E4%BD%BF%E7%94%A8%E8%BF%87Sass%E3%80%81Less-%E5%90%97%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.有了使用过Sass、Less 吗？他们的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">6.link和@import的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%8D%95%E4%BD%8D"><span class="toc-number">2.7.</span> <span class="toc-text">7.常见的CSS单位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#px%E3%80%81em%E3%80%81rem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.</span> <span class="toc-text">px、em、rem的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80"><span class="toc-number">2.8.</span> <span class="toc-text">8.两栏布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.9.</span> <span class="toc-text">9.水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-flex%E5%B8%83%E5%B1%80%E7%90%86%E8%A7%A3"><span class="toc-number">2.10.</span> <span class="toc-text">10.flex布局理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">2.10.1.</span> <span class="toc-text">常用的属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-1%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.10.2.</span> <span class="toc-text">flex: 1表示什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BABFC"><span class="toc-number">2.11.</span> <span class="toc-text">11.对BFC的理解，如何创建BFC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABFC%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.11.1.</span> <span class="toc-text">创建BFC条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.11.2.</span> <span class="toc-text">BFC作用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFmargin%E9%87%8D%E5%8F%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">2.12.</span> <span class="toc-text">12.什么是margin重叠，如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">2.12.1.</span> <span class="toc-text">计算规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.12.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-position-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.13.</span> <span class="toc-text">13.position 常用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">2.14.</span> <span class="toc-text">14.实现一个三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%94%BB%E4%B8%80%E6%9D%A10-5px%E7%9A%84%E7%BA%BF"><span class="toc-number">2.15.</span> <span class="toc-text">15.画一条0.5px的线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E7%BA%BF%E6%9D%A1"><span class="toc-number">2.15.0.1.</span> <span class="toc-text">水平线条</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E7%BA%BF%E6%9D%A1"><span class="toc-number">2.15.0.2.</span> <span class="toc-text">垂直线条</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">2.15.0.3.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.15.0.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B31px"><span class="toc-number">2.16.</span> <span class="toc-text">16.如何解决1px</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A80-5px"><span class="toc-number">2.16.0.1.</span> <span class="toc-text">方法一：直接使用0.5px</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.16.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E5%85%88%E6%94%BE%E5%A4%A7%E5%86%8D%E7%BC%A9%E5%B0%8F"><span class="toc-number">2.16.1.1.</span> <span class="toc-text">方法二：利用伪元素，先放大再缩小</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.16.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8viewport%E7%BC%A9%E6%94%BE"><span class="toc-number">2.16.2.1.</span> <span class="toc-text">方法三：使用viewport缩放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">2.16.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">2.16.3.1.</span> <span class="toc-text">解释</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">JavaScript篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.什么是回调函数？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">回调函数的用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">现代替代方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.什么是闭包？优缺点分别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%9A"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">1.内存消耗：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.0.6.</span> <span class="toc-text">2.性能问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.3.</span> <span class="toc-text">3.js数据类型有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">4.null和undefined区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">5.instanceof 运算符的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-typeof-%E5%92%8C-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">6.typeof 和 instanceof 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88typeof%E5%88%A4%E6%96%ADnull%E4%B8%BAobject%EF%BC%9F"><span class="toc-number">3.6.0.1.</span> <span class="toc-text">为什么typeof判断null为object？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89"><span class="toc-number">3.7.</span> <span class="toc-text">7.为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">3.7.0.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.8.</span> <span class="toc-text">8.判断数组的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AF%B9%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.</span> <span class="toc-text">9.对类数组对象的理解，如何转化为数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.</span> <span class="toc-text">10.数组有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-substring%E5%92%8Csubstr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.11.</span> <span class="toc-text">11.substring和substr的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%9F%A5%E9%81%93object-assign%E5%90%97"><span class="toc-number">3.12.</span> <span class="toc-text">12.知道object.assign吗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.12.0.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.12.0.2.</span> <span class="toc-text">基本用法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.12.1.</span> <span class="toc-text">1. 对象的浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">3.12.2.</span> <span class="toc-text">2. 对象的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.12.3.</span> <span class="toc-text">3. 继承属性和不可枚举属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.12.4.</span> <span class="toc-text">4. 修改目标对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">3.12.4.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.12.4.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%9F%A5%E9%81%93%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%90%97"><span class="toc-number">3.13.</span> <span class="toc-text">13.知道扩展操作符吗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.13.0.1.</span> <span class="toc-text">对象的浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.13.0.2.</span> <span class="toc-text">数组的浅拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.14.</span> <span class="toc-text">14.new操作符的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.15.</span> <span class="toc-text">15.for…in和for…of的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AF%B9AJAX%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.16.</span> <span class="toc-text">16.对AJAX的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAJAX%E8%AF%B7%E6%B1%82"><span class="toc-number">3.17.</span> <span class="toc-text">17.实现一个AJAX请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.18.</span> <span class="toc-text">18.ajax、axios、fetch的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ajax"><span class="toc-number">3.18.0.1.</span> <span class="toc-text">1.ajax</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-fetch"><span class="toc-number">3.18.0.2.</span> <span class="toc-text">2. fetch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-axios"><span class="toc-number">3.18.0.3.</span> <span class="toc-text">3. axios</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.19.</span> <span class="toc-text">19.forEach和map方法有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">20.什么是尾调用，使用尾调用有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.21.</span> <span class="toc-text">21.用过哪些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.22.</span> <span class="toc-text">22.如何实现深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.22.0.1.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.22.0.2.</span> <span class="toc-text">浅拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-call-%E3%80%81bind%EF%BC%88%EF%BC%89%E3%80%81-apply-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">23.call() 、bind（）、 apply() 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%A4%9A%E4%B8%AA-bind%EF%BC%8C%E6%9C%80%E5%90%8Ethis%E6%8C%87%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.23.0.1.</span> <span class="toc-text">连续多个 bind，最后this指向是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.24.</span> <span class="toc-text">24.理解原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.25.</span> <span class="toc-text">25.理解原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.26.</span> <span class="toc-text">26.对作用域、作用域链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.27.</span> <span class="toc-text">27.浏览器的垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-number">3.27.0.1.</span> <span class="toc-text">新生代（副垃圾回收器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3%EF%BC%88%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-number">3.27.0.2.</span> <span class="toc-text">老生代（主垃圾回收器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.27.0.3.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.27.0.4.</span> <span class="toc-text">哪些情况会导致内存泄漏</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">手写代码篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">4.1.</span> <span class="toc-text">1.数组去重</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Set"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">使用 Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-filter"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">使用 filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-reduce"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">使用 reduce</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-js%E5%B0%86%E6%95%B0%E5%AD%97%E6%AF%8F%E5%8D%83%E5%88%86%E4%BD%8D%E7%94%A8%E9%80%97%E5%8F%B7%E9%9A%94%E5%BC%80"><span class="toc-number">4.2.</span> <span class="toc-text">2.js将数字每千分位用逗号隔开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">4.3.</span> <span class="toc-text">3.手写防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">节流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%8B%E5%86%99promise"><span class="toc-number">4.4.</span> <span class="toc-text">4.手写promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%8B%E5%86%99%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.5.</span> <span class="toc-text">5.手写深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#assign%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.5.0.1.</span> <span class="toc-text">assign实现浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.5.0.2.</span> <span class="toc-text">递归实现深拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%8B%E5%86%99ajax%E5%B0%81%E8%A3%85"><span class="toc-number">4.6.</span> <span class="toc-text">6.手写ajax封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BA%A4%E6%8D%A2a-b%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="toc-number">4.7.</span> <span class="toc-text">7.交换a,b的值，不能用临时变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">扩展运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-new%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.</span> <span class="toc-text">8.new的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">4.9.</span> <span class="toc-text">9.数组的扁平化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">4.9.0.1.</span> <span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-number">4.9.0.2.</span> <span class="toc-text">扩展运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">4.10.</span> <span class="toc-text">10.函数柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">4.11.</span> <span class="toc-text">11.实现类数组转化为数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8Array-prototype-slice-call"><span class="toc-number">4.11.1.</span> <span class="toc-text">方法一：使用Array.prototype.slice.call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Array-from-%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.2.</span> <span class="toc-text">方法二：使用Array.from()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B0%86js%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">4.12.</span> <span class="toc-text">12.将js对象转化为树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-1"><span class="toc-number">4.12.1.</span> <span class="toc-text">递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AD%97%E5%85%B8%E6%B3%95"><span class="toc-number">4.12.2.</span> <span class="toc-text">哈希字典法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%94%A8Promise%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.13.</span> <span class="toc-text">13.用Promise实现图片的异步加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BD%BF%E7%94%A8-setTimeout-%E5%AE%9E%E7%8E%B0-setInterval"><span class="toc-number">4.14.</span> <span class="toc-text">14.使用 setTimeout 实现 setInterval</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text">ES6篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">1.let、const、var的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">2.箭头函数与普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">3.Set、Map的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-map%E5%92%8CObject%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text">4.map和Object的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-map%E5%92%8CweakMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">5.map和weakMap的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.6.</span> <span class="toc-text">6.说说你对Promise的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Promise%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.</span> <span class="toc-text">7.Promise方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-promise-all-%E5%92%8C-promise-allsettled-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.</span> <span class="toc-text">8.promise.all 和 promise.allsettled 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AF%B9async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.9.</span> <span class="toc-text">9.对async&#x2F;await 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#async-await%E5%AF%B9%E6%AF%94Promise%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">5.9.0.1.</span> <span class="toc-text">async&#x2F;await对比Promise的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AF%B9ES6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.10.</span> <span class="toc-text">10.对ES6的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-ES6%E6%A8%A1%E5%9D%97%E5%92%8CCommonJS%E6%A8%A1%E5%9D%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">11.ES6模块和CommonJS模块有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">Vue篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vue%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1.vue的常用的属性和指令有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">属性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">指令：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-text"><span class="toc-number">6.1.0.3.</span> <span class="toc-text">v-text</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-html"><span class="toc-number">6.1.0.4.</span> <span class="toc-text">v-html</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-show"><span class="toc-number">6.1.0.5.</span> <span class="toc-text">v-show</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-if"><span class="toc-number">6.1.0.6.</span> <span class="toc-text">v-if</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-for"><span class="toc-number">6.1.0.7.</span> <span class="toc-text">v-for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-if-%E5%92%8Cv-for%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.1.0.8.</span> <span class="toc-text">v-if 和v-for优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-for-%E7%9A%84key"><span class="toc-number">6.1.0.9.</span> <span class="toc-text">v-for 的key</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v-on"><span class="toc-number">6.1.0.10.</span> <span class="toc-text">v-on</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-vue2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E6%AF%8F%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.vue2的生命周期有哪些及每个生命周期做了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MVVM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">3.MVVM的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-vue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%B8%E5%90%8C"><span class="toc-number">6.4.</span> <span class="toc-text">4.vue和react的区别，有什么相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Vue2%E5%92%8CVue3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.</span> <span class="toc-text">5.Vue2和Vue3有哪些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SPA%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">6.SPA和多页面有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.7.</span> <span class="toc-text">7.Vue的性能优化有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5"><span class="toc-number">6.7.0.1.</span> <span class="toc-text">编码阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96"><span class="toc-number">6.7.0.2.</span> <span class="toc-text">打包优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"><span class="toc-number">6.7.0.3.</span> <span class="toc-text">用户体验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SEO%E4%BC%98%E5%8C%96"><span class="toc-number">6.7.0.4.</span> <span class="toc-text">SEO优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Computed-%E5%92%8C-Watch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.8.</span> <span class="toc-text">8.Computed 和 Watch 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">6.9.</span> <span class="toc-text">9.Vue组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">6.10.</span> <span class="toc-text">10.常见的事件修饰符及其作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.11.</span> <span class="toc-text">11.v-if和v-show的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Vue%E4%B8%ADdata%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.12.</span> <span class="toc-text">12.Vue中data为什么是一个函数而不是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.13.</span> <span class="toc-text">13.mixin 和 mixins 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mixin%E7%9A%84%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6%EF%BC%88%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="toc-number">6.13.0.1.</span> <span class="toc-text">mixin的选项合并（核心概念）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%B7%B7%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81%E6%97%B6"><span class="toc-number">6.13.0.1.1.</span> <span class="toc-text">1.混入的数据存在冲突时</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%B7%B7%E5%85%A5%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81%E6%97%B6"><span class="toc-number">6.13.0.1.2.</span> <span class="toc-text">2.混入的生命周期存在冲突时</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%B7%B7%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81%E6%97%B6"><span class="toc-number">6.13.0.1.3.</span> <span class="toc-text">3.混入的方法存在冲突时</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mixin%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.13.0.2.</span> <span class="toc-text">mixin的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E6%9D%A5%E6%BA%90%E4%B8%8D%E6%98%8E%E7%A1%AE%EF%BC%88%E9%9A%90%E5%BC%8F%E4%BC%A0%E5%85%A5%EF%BC%89%EF%BC%8C%E4%B8%8D%E5%88%A9%E4%BA%8E%E9%98%85%E8%AF%BB%EF%BC%8C%E4%BD%BF%E4%BB%A3%E7%A0%81%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%BB%B4%E6%8A%A4%E3%80%82"><span class="toc-number">6.13.0.2.1.</span> <span class="toc-text">1.变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%A4%9A%E4%B8%AAmixins%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BC%9A%E8%9E%8D%E5%90%88%E5%88%B0%E4%B8%80%E8%B5%B7%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%BD%86%E6%98%AF%E5%90%8C%E5%90%8D%E5%B1%9E%E6%80%A7%E3%80%81%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95%E6%97%A0%E6%B3%95%E8%9E%8D%E5%90%88%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%B2%E7%AA%81%E6%88%96%E8%A6%86%E7%9B%96%E3%80%82"><span class="toc-number">6.13.0.2.2.</span> <span class="toc-text">2.多个mixins的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突或覆盖。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-mixins%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%BE%83%E9%AB%98"><span class="toc-number">6.13.0.2.3.</span> <span class="toc-text">3.mixins和组件可能出现多对多的关系，复杂度较高</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.14.</span> <span class="toc-text">14.使用 Object.defineProperty() 来进行数据劫持有什么缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%A0%E6%B3%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="toc-number">6.14.0.1.</span> <span class="toc-text">1. 无法监听数组索引的变动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E6%96%B0%E5%A2%9E%E6%88%96%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">6.14.0.2.</span> <span class="toc-text">2. 无法检测新增或删除属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%8B%E5%8A%A8%E9%80%92%E5%BD%92%E5%8A%AB%E6%8C%81"><span class="toc-number">6.14.0.3.</span> <span class="toc-text">3. 手动递归劫持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">6.14.0.4.</span> <span class="toc-text">4. 性能问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue-3-%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9AProxy"><span class="toc-number">6.14.0.5.</span> <span class="toc-text">Vue 3 中的改进：Proxy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.14.0.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Vue%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-number">6.15.</span> <span class="toc-text">15.Vue是如何收集依赖的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.16.</span> <span class="toc-text">16.slot是什么？有什么作用？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.17.</span> <span class="toc-text">17双向数据绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-nextTick-%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">6.18.</span> <span class="toc-text">18.$nextTick 原理及作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">6.18.0.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.18.0.2.</span> <span class="toc-text">使用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Vue%E4%B8%AD%E6%80%8E%E4%B9%88%E9%87%8D%E7%BD%AEdata%EF%BC%9F"><span class="toc-number">6.19.</span> <span class="toc-text">19.Vue中怎么重置data？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Vue%E4%B8%ADdata%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E5%92%8Cmethods%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8C%E5%90%8D%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.20.</span> <span class="toc-text">20.Vue中data的属性可以和methods中的方法同名吗？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.21.</span> <span class="toc-text">21.对keep-alive的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-v-for%E5%BE%AA%E7%8E%AF%E4%B8%ADkey%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">6.22.</span> <span class="toc-text">22.v-for循环中key有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.23.</span> <span class="toc-text">23.vue如何监听键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%BD%A0%E7%9F%A5%E9%81%93v-model%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">6.24.</span> <span class="toc-text">24.你知道v-model的原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-vue%E9%A6%96%E9%A1%B5%E7%99%BD%E5%B1%8F%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">6.25.</span> <span class="toc-text">25.vue首页白屏是什么问题引起的？如何解决呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-CDN%E5%8A%A0%E9%80%9F"><span class="toc-number">6.26.</span> <span class="toc-text">26.CDN加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88SSR%EF%BC%89"><span class="toc-number">6.27.</span> <span class="toc-text">27.服务端渲染（SSR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-vue-router%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">6.28.</span> <span class="toc-text">28.vue-router是用来做什么的？它有哪些组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-vue-router%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">6.29.</span> <span class="toc-text">29.vue-router钩子函数有哪些？都有哪些参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-route%E5%92%8Crouter%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.30.</span> <span class="toc-text">30.route和router有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-setup-%E5%87%BD%E6%95%B0"><span class="toc-number">6.31.</span> <span class="toc-text">31.setup()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">6.32.</span> <span class="toc-text">32.响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.33.</span> <span class="toc-text">33.router和route的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">6.34.</span> <span class="toc-text">34.如何设置动态路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.35.</span> <span class="toc-text">35.虚拟DOM的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.35.0.1.</span> <span class="toc-text">对虚拟DOM的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94%E7%9C%9F%E5%AE%9EDOM%E6%9B%B4%E5%BF%AB%E5%90%97"><span class="toc-number">6.35.0.2.</span> <span class="toc-text">虚拟DOM就一定比真实DOM更快吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">6.35.0.3.</span> <span class="toc-text">虚拟DOM的解析过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-DIFF%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">6.36.</span> <span class="toc-text">36.DIFF算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AFdiff"><span class="toc-number">6.36.0.1.</span> <span class="toc-text">双端diff</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">通用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1.从输入URL到页面加载的全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">2.浏览器解析页面的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">3.JS引擎解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">4.浏览器重绘与重排的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E7%BB%98%E6%88%96%E8%80%85%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">7.如何避免重绘或者重排？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">7.6.</span> <span class="toc-text">8.浏览器的缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">9.进程、线程和协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1%E7%9A%84hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.8.</span> <span class="toc-text">10.路由的hash和history模式的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">8.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">1.http 和 https 的区别及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-https-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">2.https 协议的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP-IP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">3.TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">4.TCP和UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTTP-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.</span> <span class="toc-text">5.HTTP 请求跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JSONP"><span class="toc-number">8.5.1.</span> <span class="toc-text">1.JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CORS"><span class="toc-number">8.5.2.</span> <span class="toc-text">2.CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">8.5.2.1.</span> <span class="toc-text">a.简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-number">8.5.2.2.</span> <span class="toc-text">b.预检请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">8.5.2.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CORS%E4%BC%A0%E9%80%92-cookie-%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.3.</span> <span class="toc-text">3.CORS传递 cookie 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-proxy%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.5.4.</span> <span class="toc-text">4.proxy代理服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-postMessage"><span class="toc-number">8.5.5.</span> <span class="toc-text">5.postMessage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Cookie%E3%80%81sessionStorage%E3%80%81localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.6.</span> <span class="toc-text">6.Cookie、sessionStorage、localStorage 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8B%86%E5%8C%85-%E7%B2%98%E5%8C%85-%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">7.拆包&#x2F;粘包 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.0.1.</span> <span class="toc-text">解决 粘包&#x2F;拆包 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E6%9C%89%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">8.7.0.2.</span> <span class="toc-text">为什么TCP有粘包？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E6%B2%A1%E6%9C%89%E7%B2%98%E5%8C%85%EF%BC%9F"><span class="toc-number">8.7.0.3.</span> <span class="toc-text">为什么UDP没有粘包？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%8F%E5%B7%9E%E5%AE%9D%E5%AE%9D%E5%B7%B4%E5%A3%AB%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">福州宝宝巴士笔试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81es6%E4%B8%AD%E6%9C%89class%E5%8F%AF%E4%BB%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91%EF%BC%8C%E8%80%8Ces5%E5%88%99%E9%9C%80%E8%A6%81%E5%9F%BA%E4%BA%8E-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">9.1.1.</span> <span class="toc-text">1、es6中有class可以面向对象开发，而es5则需要基于__来实现面向对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81es6%E5%92%8Ces5%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.1.2.</span> <span class="toc-text">2、es6和es5继承的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ChatGPT-%E8%AF%B4%EF%BC%9A"><span class="toc-number">9.1.2.0.1.</span> <span class="toc-text">ChatGPT 说：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%88%97%E4%B8%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">9.1.3.</span> <span class="toc-text">3、列举浏览器内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">9.1.4.</span> <span class="toc-text">4、多个标签页如何通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">9.1.5.</span> <span class="toc-text">5、什么是同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E7%BD%91%E7%AB%99%E5%A6%82%E4%BD%95SEO"><span class="toc-number">9.1.6.</span> <span class="toc-text">6、网站如何SEO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81display%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%81%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.7.</span> <span class="toc-text">7、display的值有哪些、区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%88%97%E4%B8%BE%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84UI%E6%A1%86%E6%9E%B6"><span class="toc-number">9.1.8.</span> <span class="toc-text">8、列举你了解的UI框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">9.1.9.</span> <span class="toc-text">9、什么是闭包，闭包的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.10.</span> <span class="toc-text">10、微信小程序的文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">9.1.11.</span> <span class="toc-text">11、什么是前端模块化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">10.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-vue%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.1.</span> <span class="toc-text">2.vue中的指令有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.2.</span> <span class="toc-text">3.事件修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-setup%E7%94%A8%E5%A4%84"><span class="toc-number">10.3.</span> <span class="toc-text">4.setup用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-vite%E5%92%8Cwebpack%E5%8C%BA%E5%88%AB"><span class="toc-number">10.4.</span> <span class="toc-text">5.vite和webpack区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-vite%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9"><span class="toc-number">10.5.</span> <span class="toc-text">6.vite的特点和优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vue2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.6.</span> <span class="toc-text">7.vue2的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">10.7.</span> <span class="toc-text">8.双向绑定的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-var-const-%E5%92%8C-let%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.8.</span> <span class="toc-text">9.var const 和 let的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-H5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.9.</span> <span class="toc-text">12.H5语义化标签有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">10.10.</span> <span class="toc-text">14.组件之间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86"><span class="toc-number">10.11.</span> <span class="toc-text">15.vuex状态管理包含哪些部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-vuex%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.12.</span> <span class="toc-text">16.vuex的语法糖有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.13.</span> <span class="toc-text">17.ajax、fetch、axios的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-promise%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">10.14.</span> <span class="toc-text">18.promise有几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-promise%E7%8A%B6%E6%80%81%E6%9C%89%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="toc-number">10.15.</span> <span class="toc-text">19.promise状态有几个过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8C%85%E5%90%AB%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">10.16.</span> <span class="toc-text">20.组件结构包含哪几个部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%80%8E%E4%B9%88%E6%8E%A5%E6%94%B6%E4%BC%A0%E9%80%92%E8%BF%87%E6%9D%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.17.</span> <span class="toc-text">21.怎么接收传递过来的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-JS%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.18.</span> <span class="toc-text">22.JS数据的基本类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E9%80%9A%E8%BF%87%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">10.19.</span> <span class="toc-text">23.通过中间件实现文件上传，文件上传是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%94%A8input%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.20.</span> <span class="toc-text">24.用input来实现，怎么实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82"><span class="toc-number">10.21.</span> <span class="toc-text">25.什么情况会出现跨域请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.22.</span> <span class="toc-text">26.防抖和节流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">10.23.</span> <span class="toc-text">27.定时器了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%80%8E%E4%B9%88%E7%A7%BB%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">10.24.</span> <span class="toc-text">28.怎么移除定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89UI%EF%BC%8C%E6%94%AF%E6%8C%81%E6%B8%B2%E6%9F%93%E5%A4%9A%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">10.25.</span> <span class="toc-text">29.表单组件的自定义UI，支持渲染多种结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-element-ui%E8%A1%A8%E5%8D%95%E5%B7%B2%E7%BB%8F%E5%86%99%E5%A5%BD%E4%BA%86%E4%B8%80%E5%A5%97"><span class="toc-number">10.26.</span> <span class="toc-text">30.element-ui表单已经写好了一套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="toc-number">10.27.</span> <span class="toc-text">31.浏览器请求一个网站，会做什么操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">10.28.</span> <span class="toc-text">32.前端缓存有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-Localstoreage%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F%E6%98%AF%E5%A4%9A%E4%B9%85"><span class="toc-number">10.29.</span> <span class="toc-text">33.Localstoreage的有效期是多久</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-session%E7%9A%84%E6%9C%89%E6%95%88%E6%9C%9F%E5%91%A2"><span class="toc-number">10.30.</span> <span class="toc-text">34.session的有效期呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-cookie%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">10.31.</span> <span class="toc-text">35.cookie知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.32.</span> <span class="toc-text">36.css盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88"><span class="toc-number">10.33.</span> <span class="toc-text">37.正常的盒子模型包含什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.34.</span> <span class="toc-text">38.垂直居中的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-flex%E5%B8%83%E5%B1%80%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">10.35.</span> <span class="toc-text">39.flex布局有了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E8%BF%99%E4%B8%AA%E5%B8%83%E5%B1%80%E8%A6%81%E7%94%A8%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%80%8E%E4%B9%88%E6%8D%A2%E8%A1%8C"><span class="toc-number">10.36.</span> <span class="toc-text">40.这个布局要用哪个属性怎么换行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-css%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E4%BD%8D"><span class="toc-number">10.37.</span> <span class="toc-text">41.css自适应单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-vh-vw%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97"><span class="toc-number">10.38.</span> <span class="toc-text">42.vh vw有用过吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.39.</span> <span class="toc-text">43.媒体查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-css%E7%9A%84%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">10.40.</span> <span class="toc-text">44.css的媒体查询有了解吗</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/04/react%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E9%97%AE%E5%8D%B7%E6%98%9F/" title="react实战项目_问卷星"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react实战项目_问卷星"/></a><div class="content"><a class="title" href="/2024/09/04/react%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE-%E9%97%AE%E5%8D%B7%E6%98%9F/" title="react实战项目_问卷星">react实战项目_问卷星</a><time datetime="2024-09-04T01:50:17.000Z" title="发表于 2024-09-04 09:50:17">2024-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/18/react%E5%AD%A6%E4%B9%A0/" title="react学习"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react学习"/></a><div class="content"><a class="title" href="/2024/07/18/react%E5%AD%A6%E4%B9%A0/" title="react学习">react学习</a><time datetime="2024-07-18T13:54:04.000Z" title="发表于 2024-07-18 21:54:04">2024-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/14/React-Electron%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" title="React + Electron跨平台桌面应用项目日志"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React + Electron跨平台桌面应用项目日志"/></a><div class="content"><a class="title" href="/2024/07/14/React-Electron%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" title="React + Electron跨平台桌面应用项目日志">React + Electron跨平台桌面应用项目日志</a><time datetime="2024-07-14T13:20:12.000Z" title="发表于 2024-07-14 21:20:12">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/30/Vue3-uniapp-wallpaper%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" title="Vue3+uniapp wallpaper项目开发日志"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3+uniapp wallpaper项目开发日志"/></a><div class="content"><a class="title" href="/2024/06/30/Vue3-uniapp-wallpaper%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" title="Vue3+uniapp wallpaper项目开发日志">Vue3+uniapp wallpaper项目开发日志</a><time datetime="2024-06-30T07:59:28.000Z" title="发表于 2024-06-30 15:59:28">2024-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/27/ArK/" title="ArK"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArK"/></a><div class="content"><a class="title" href="/2024/06/27/ArK/" title="ArK">ArK</a><time datetime="2024-06-27T15:19:22.000Z" title="发表于 2024-06-27 23:19:22">2024-06-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 黑板擦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>