<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法入门 | 我在看着你</title><meta name="author" content="黑板擦"><meta name="copyright" content="黑板擦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆了解堆结构和堆排序  知识点数组去重的几种方式1.利用 ES6 Set 去重（ES6 中最常用）123function unique (arr) &amp;#123;  return Array.from(new Set(arr))&amp;#125;  2、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）1234567891011function unique(arr)&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="算法入门">
<meta property="og:url" content="http://example.com/2024/03/24/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="我在看着你">
<meta property="og:description" content="堆了解堆结构和堆排序  知识点数组去重的几种方式1.利用 ES6 Set 去重（ES6 中最常用）123function unique (arr) &amp;#123;  return Array.from(new Set(arr))&amp;#125;  2、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）1234567891011function unique(arr)&amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-03-24T09:44:57.000Z">
<meta property="article:modified_time" content="2024-04-10T13:37:06.566Z">
<meta property="article:author" content="黑板擦">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/03/24/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-10 21:37:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/Snipaste_2024-04-06_01-08-30.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 追番</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="我在看着你"><span class="site-name">我在看着你</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 追番</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-24T09:44:57.000Z" title="发表于 2024-03-24 17:44:57">2024-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-10T13:37:06.566Z" title="更新于 2024-04-10 21:37:06">2024-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>了解堆结构和堆排序</p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/3.png"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="数组去重的几种方式"><a href="#数组去重的几种方式" class="headerlink" title="数组去重的几种方式"></a>数组去重的几种方式</h3><h4 id="1-利用-ES6-Set-去重（ES6-中最常用）"><a href="#1-利用-ES6-Set-去重（ES6-中最常用）" class="headerlink" title="1.利用 ES6 Set 去重（ES6 中最常用）"></a>1.利用 ES6 Set 去重（ES6 中最常用）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span> (arr) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、利用-for-嵌套-for，然后-splice-去重（ES5-中最常用）"><a href="#2、利用-for-嵌套-for，然后-splice-去重（ES5-中最常用）" class="headerlink" title="2、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）"></a>2、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个</span></span><br><span class="line">                    arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);		<span class="comment">//splice方法删除第二个</span></span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-利用-indexOf-去重"><a href="#3-利用-indexOf-去重" class="headerlink" title="3.利用 indexOf 去重"></a>3.利用 indexOf 去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array .<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array .<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-利用-includes"><a href="#4-利用-includes" class="headerlink" title="4.利用 includes"></a>4.利用 includes</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array =[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( !array.<span class="title function_">includes</span>( arr[i]) ) &#123;<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">                    array.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-利用-Map-数据结构去重"><a href="#5-利用-Map-数据结构去重" class="headerlink" title="5.利用 Map 数据结构去重"></a>5.利用 Map 数据结构去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayNonRepeatfy</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="title class_">Array</span>();  <span class="comment">// 数组用于返回结果</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">has</span>(arr[i])) &#123;  <span class="comment">// 如果有该key值</span></span><br><span class="line">      map.<span class="title function_">set</span>(arr[i], <span class="literal">true</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      map.<span class="title function_">set</span>(arr[i], <span class="literal">false</span>);   <span class="comment">// 如果没有该key值</span></span><br><span class="line">      array.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> array ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-…new-Set-arr"><a href="#6-…new-Set-arr" class="headerlink" title="6.[…new Set(arr)]"></a>6.[…new Set(arr)]</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)] </span><br><span class="line"><span class="comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span></span><br></pre></td></tr></table></figure>



<h3 id="二分法两种方式"><a href="#二分法两种方式" class="headerlink" title="二分法两种方式"></a>二分法两种方式</h3><h4 id="二分法第一种写法"><a href="#二分法第一种写法" class="headerlink" title="二分法第一种写法"></a>二分法第一种写法</h4><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：</p>
<img src="../images/算法/9.jpg" style="zoom:67%;">



<h4 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h4><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p>在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（<strong>注意和方法一的区别</strong>）</p>
<img src="../images/算法/10.jpg" style="zoom:67%;">





<h2 id="CodeTop-前端高频-60"><a href="#CodeTop-前端高频-60" class="headerlink" title="CodeTop 前端高频 60"></a>CodeTop 前端高频 60</h2><h3 id="0-模板"><a href="#0-模板" class="headerlink" title="0.模板"></a>0.模板</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/2.png"></p>
<h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-滑动窗口法"><a href="#1-滑动窗口法" class="headerlink" title="1.滑动窗口法"></a>1.滑动窗口法</h5><p><img src="/../images/%E7%AE%97%E6%B3%95/1.png"></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = right = length = maxlength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!set.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">          set.<span class="title function_">add</span>(s[right]);</span><br><span class="line">          length++;</span><br><span class="line">          right++;</span><br><span class="line">          <span class="keyword">if</span>(length&gt;maxlength)&#123;</span><br><span class="line">            maxlength = length;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(set.<span class="title function_">has</span>(s[right]))&#123;</span><br><span class="line">            set.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">            left++;</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">         set.<span class="title function_">add</span>(s[right]);</span><br><span class="line">         length++;</span><br><span class="line">         right++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>多思考。。。</p>
<h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/4.png"></p>
<h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-合并数组再比较"><a href="#1-合并数组再比较" class="headerlink" title="1.合并数组再比较"></a>1.合并数组再比较</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">  <span class="comment">// 123256</span></span><br><span class="line">  nums1.<span class="title function_">splice</span>(m,nums1.<span class="property">length</span>-m,...nums2)</span><br><span class="line">  nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这里需要用到 <code>splice</code></p>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>splice(start, deleteCount, item1, item2……)</p>
<ul>
<li><code>start</code>参数 开始的位置</li>
<li><code>deleteCount</code>要截取的个数</li>
<li>后面的**<code>items</code>为要添加的元素**</li>
<li>如果<code>deleteCount</code>为<code>0</code>，则表示不删除元素，<strong>从<code>start</code>位置开始添加后面的几个元素到原始的数组里面。</strong></li>
<li><strong>返回值</strong>为由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li>
<li>这个方法<strong>会改变原始数组</strong>，<strong>数组的长度会发生变化</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&quot;f1&quot;</span>, <span class="string">&quot;f2&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = arr3.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 删除第三个元素以后的三个数组元素(包含第三个元素)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4); <span class="comment">// [3, 4, 5];</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [1, 2, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr5 = arr3.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;leon&quot;</span>); </span><br><span class="line"><span class="comment">// 从第2位开始删除0个元素，插入&quot;wu&quot;,&quot;leon&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr5); <span class="comment">// [] 返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [1, 2, &quot;wu&quot;, &quot;leon&quot;, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr6 = arr3.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;xiao&quot;</span>, <span class="string">&quot;long&quot;</span>);</span><br><span class="line"><span class="comment">// 从第 2 位开始删除 3 个元素，插入&quot;xiao&quot;, &quot;long&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr6); <span class="comment">// [&quot;wu&quot;, &quot;leon&quot;, 6]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">//[ 1, 2, &quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr7 = arr3.<span class="title function_">splice</span>(<span class="number">2</span>); <span class="comment">// 从第三个元素开始删除所有的元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr7);<span class="comment">// [&quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><ul>
<li>对数组的元素进行排序，并返回数组。</li>
<li>默认排序顺序是在将元素转换为字符串，然后比较它们的<code>UTF-16</code>代码单元值序列时构建的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>





<h5 id="2-双指针从后遍历"><a href="#2-双指针从后遍历" class="headerlink" title="2.双指针从后遍历"></a>2.双指针从后遍历</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 123256</span></span><br><span class="line">    <span class="keyword">let</span> t = m - <span class="number">1</span>,k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = m + n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(t&gt;=<span class="number">0</span> || k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[j] = nums2[k];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[j] = nums1[t];</span><br><span class="line">            j--;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(nums1[t]&gt;nums2[k])&#123;</span><br><span class="line">            nums1[j] = nums1[t];</span><br><span class="line">            j--;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[j] = nums2[k];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">merge</span>(a1,<span class="number">3</span>,a2,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E7%AE%97%E6%B3%95/5.jpg"></p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/6.jpg"></p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/7.jpg"></p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/8.jpg"></p>
<h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/5.png"></p>
<h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-分割字符法"><a href="#1-分割字符法" class="headerlink" title="1.分割字符法"></a>1.分割字符法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> l1 = version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> l2 = version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> l1num = l1.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">parseInt</span>(item))</span><br><span class="line">    <span class="keyword">let</span> l2num = l2.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">parseInt</span>(item))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(l1num,l2num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt; (l1.<span class="property">length</span>&gt;l2.<span class="property">length</span>?l1.<span class="property">length</span>:l2.<span class="property">length</span>);i++ )&#123;</span><br><span class="line">        <span class="keyword">let</span> x = l1num[i];</span><br><span class="line">        <span class="keyword">let</span> y = l2num[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="literal">undefined</span>)&#123;</span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="literal">undefined</span>)&#123;</span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="spilt"><a href="#spilt" class="headerlink" title="spilt"></a>spilt</h4><p>使用指定的分隔符将一个字符串拆分为多个子字符串数组并返回，原字符串不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;A*B*C*D*E*F*G&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&#x27;*&#x27;</span>)) <span class="comment">// 输出 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></span><br></pre></td></tr></table></figure>



<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p>在头部弹出数据，原数组会变。数组的 <code>push</code>（入队） &amp; <code>shift</code>（出队） 可以模拟常见数据结构之一：队列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> shiftVal = arr.<span class="title function_">shift</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shiftVal) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟常见数据结构之一：队列</span></span><br><span class="line"><span class="keyword">const</span> queue = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">queue.<span class="title function_">push</span>(<span class="number">2</span>) <span class="comment">// 入队</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue) <span class="comment">// [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shiftValue = queue.<span class="title function_">shift</span>() <span class="comment">// 出队</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shiftValue) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>





<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/11.png"></p>
<h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划解</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">爬上 n−1阶楼梯的方法数量。因为再爬1阶就能到第n阶</span><br><span class="line">爬上 n−2阶楼梯的方法数量，因为再爬2阶就能到第n阶</span><br><span class="line">所以我们得到公式 dp[n]=dp[n−1]+dp[n−2]</span><br><span class="line">同时需要初始化 dp[0]=1 和 dp[1]=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/13.png"></p>
<h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-回溯算法"><a href="#1-回溯算法" class="headerlink" title="1.回溯算法"></a>1.回溯算法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], path = [];</span><br><span class="line">    <span class="title function_">backtracking</span>(nums, nums.<span class="property">length</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtracking</span>(<span class="params">n, k, used</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(n[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 同支</span></span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, used);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E7%AE%97%E6%B3%95/12.png"></p>
<h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/14.png"></p>
<h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-动态规划-1"><a href="#1-动态规划-1" class="headerlink" title="1.动态规划"></a>1.动态规划</h5><p>动态规划压缩时间，将dp[]数组用一个滚动量pre来表示，节约空间</p>
<p>具体思路可看：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pw411M7Du/?spm_id_from=333.337.search-card.all.click&vd_source=1d570edaa4d98b311404ac363e136ee7">算法讲解070【必备】子数组最大累加和问题与扩展-上_哔哩哔哩_bilibili</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        pre = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre+nums[i],nums[i]);</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre,max)</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/15.png"></p>
<h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针加一个临时变量"><a href="#1-双指针加一个临时变量" class="headerlink" title="1.双指针加一个临时变量"></a>1.双指针加一个临时变量</h5><p>注意：只要思考改变指向关系和节点的移动就可以了，改变两个节点的指向时为了防止丢失用临时变量存储下一个节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><h4 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/16.png"></p>
<h4 id="解法：-8"><a href="#解法：-8" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法"><a href="#1-双指针法" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GW4y127qo/?spm_id_from=333.337.search-card.all.click&vd_source=1d570edaa4d98b311404ac363e136ee7">梦破碎的地方！| LeetCode：15.三数之和_哔哩哔哩_bilibili</a></p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 将数组排序</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i + <span class="number">1</span>, r = len - <span class="number">1</span>, iNum = nums[i]</span><br><span class="line">        <span class="comment">// 数组排过序，如果第一个数大于0直接返回res</span></span><br><span class="line">        <span class="keyword">if</span> (iNum &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (iNum == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">let</span> lNum = nums[l], rNum = nums[r], threeSum = iNum + lNum + rNum</span><br><span class="line">            <span class="comment">// 三数之和小于0，则左指针向右移动</span></span><br><span class="line">            <span class="keyword">if</span> (threeSum &lt; <span class="number">0</span>) l++ </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (threeSum &gt; <span class="number">0</span>) r--</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([iNum, lNum, rNum])</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>])&#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">                l++</span><br><span class="line">                r--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键在于去重</strong></p>
<p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 去重 right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">// 去重 left</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p>
<p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p>
<p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p>
<p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p>
<p>所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="#思考题"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%80%83%E9%A2%98">#</a>思考题</h4><p>既然三数之和可以使用双指针法，我们之前讲过的<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>，可不可以使用双指针法呢？</p>
<p>两数之和 就不能使用双指针法，因为<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。</p>
<p>如果<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是数值的话，就可以使用双指针法了。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><h4 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/17.png"></p>
<h4 id="解法：-9"><a href="#解法：-9" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-1"><a href="#1-双指针法-1" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src="/../images/%E7%AE%97%E6%B3%95/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slowindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> fastindex = <span class="number">0</span>;fastindex&lt;nums.<span class="property">length</span>;fastindex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val!=nums[fastindex])&#123;</span><br><span class="line">            nums[slowindex] == nums[fastindex];</span><br><span class="line">            slowindex++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowindex</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><h4 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/35.png"></p>
<h4 id="解法：-10"><a href="#解法：-10" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-2"><a href="#1-双指针法-2" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span>  slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(fast = <span class="number">1</span>;fast&lt;nums.<span class="property">length</span>;fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow])&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="删除排序数组中的重复项-II"><a href="#删除排序数组中的重复项-II" class="headerlink" title="删除排序数组中的重复项 II"></a>删除排序数组中的重复项 II</h3><h4 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/36.png"></p>
<h4 id="解法：-11"><a href="#解法：-11" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-3"><a href="#1-双指针法-3" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p>参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11N4y1w7Sf/?spm_id_from=333.337.search-card.all.click&vd_source=1d570edaa4d98b311404ac363e136ee7">80. 删除有序数组中的重复项 II_哔哩哔哩_bilibili</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> fast = <span class="number">2</span>;fast&lt;nums.<span class="property">length</span>;fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != nums[slow-<span class="number">2</span>])&#123;</span><br><span class="line">          nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><h4 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/18.png"></p>
<h4 id="解法：-12"><a href="#解法：-12" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-4"><a href="#1-双指针法-4" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p>
<p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p>
<p>这里还是以题目中的示例来举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程：在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/3.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> k = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> minlength = <span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minlength&gt;i-j+<span class="number">1</span>)&#123;</span><br><span class="line">                minlength = i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            sum -= nums[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minlength === <span class="title class_">Infinity</span>?<span class="number">0</span>:minlength;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><h4 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/19.png"></p>
<h4 id="解法：-13"><a href="#解法：-13" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-虚拟头结点"><a href="#1-虚拟头结点" class="headerlink" title="1.虚拟头结点"></a>1.虚拟头结点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化一个虚拟头节点</span></span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="comment">//用临时指针来遍历，不能用head</span></span><br><span class="line">    <span class="keyword">let</span> cur = ret;</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === val) &#123;</span><br><span class="line">            cur.<span class="property">next</span> =  cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要返回虚拟头节点的next，因为head可能被删除了</span></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><h4 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/20.png"></p>
<h4 id="解法：-14"><a href="#解法：-14" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-5"><a href="#1-双指针法-5" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>
<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p>
<p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> k = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,j = nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]*nums[i]&lt;nums[j]*nums[j])&#123;</span><br><span class="line">            res[k] = nums[j]*nums[j];</span><br><span class="line">            k--; </span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[k] = nums[i]*nums[i];</span><br><span class="line">            k--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h3><h4 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/21.png"></p>
<h4 id="解法：-15"><a href="#解法：-15" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-替换"><a href="#1-替换" class="headerlink" title="1.替换"></a>1.替换</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    node.<span class="property">val</span> = node.<span class="property">next</span>.<span class="property">val</span>;</span><br><span class="line">    node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><h4 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/22.png"></p>
<h4 id="解法：-16"><a href="#解法：-16" class="headerlink" title="解法："></a>解法：</h4><p>这道题目正常模拟就可以了。</p>
<p>建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。</p>
<p>对虚拟头结点的操作，还不熟悉的话，可以看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？ (opens new window)</a>。</p>
<p>接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p>
<p>初始时，cur指向虚拟头结点，然后进行如下三步：</p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/23.png"></p>
<p>操作之后，链表如下：</p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/24.png"></p>
<p>看这个可能就更直观一些了：</p>
<p><img src="/../images/%E7%AE%97%E6%B3%95/25.png"></p>
<h5 id="1-虚拟头节点"><a href="#1-虚拟头节点" class="headerlink" title="1.虚拟头节点"></a>1.虚拟头节点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> cur = ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">let</span> temp2 = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换节点</span></span><br><span class="line">        cur.<span class="property">next</span> = temp2;</span><br><span class="line">        temp.<span class="property">next</span> = temp2.<span class="property">next</span>;</span><br><span class="line">        temp2.<span class="property">next</span> = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动到下一对节点</span></span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><h4 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/26.png"></p>
<h4 id="解法：-17"><a href="#解法：-17" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-双指针法-6"><a href="#1-双指针法-6" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>思路是这样的，但要注意一些细节。</p>
<p>分为如下几步：</p>
<ul>
<li>首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： <a target="_blank" rel="noopener" href="https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html">链表：听说用虚拟头节点会方便很多？(opens new window)</a></li>
<li>定义fast指针和slow指针，初始值为虚拟头结点，如图：</li>
</ul>
<p><img src="/../images/%E7%AE%97%E6%B3%95/27.png"></p>
<ul>
<li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：</li>
<li><img src="/../images/%E7%AE%97%E6%B3%95/28.png"></li>
<li>fast和slow同时移动，直到fast指向末尾，如题：</li>
<li><img src="/../images/%E7%AE%97%E6%B3%95/29.png"></li>
<li>删除slow指向的下一个节点，如图：</li>
<li><img src="/../images/%E7%AE%97%E6%B3%95/30.png"></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> fast = slow = ret;</span><br><span class="line">    <span class="comment">//快指针走n+1步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span> = slow.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><h4 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/31.png"></p>
<h4 id="解法：-18"><a href="#解法：-18" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-快慢双指针法-数学追及问题"><a href="#1-快慢双指针法-数学追及问题" class="headerlink" title="1.快慢双指针法+数学追及问题"></a>1.快慢双指针法+数学追及问题</h5><p>可以参考</p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1u341187v3?spm_id_from=333.880.my_history.page.click">https://www.bilibili.com/video/BV1u341187v3?spm_id_from=333.880.my_history.page.click</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span> (<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = headA;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur.<span class="property">next</span>) &#123;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="property">next</span> = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fast = slow = headA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line"></span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fast) &#123;</span><br><span class="line">            cur.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">            fast = headA;</span><br><span class="line">            <span class="keyword">while</span> (fast &amp;&amp; slow) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">                    cur.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> fast;</span><br><span class="line">                &#125;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><h4 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/32.png"></p>
<h4 id="解法：-19"><a href="#解法：-19" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-快慢双指针法-数学追及问题-1"><a href="#1-快慢双指针法-数学追及问题-1" class="headerlink" title="1.快慢双指针法+数学追及问题"></a>1.快慢双指针法+数学追及问题</h5><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow =head.<span class="property">next</span>, fast = head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (fast !== slow) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><h4 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/33.png"></p>
<h4 id="解法：-20"><a href="#解法：-20" class="headerlink" title="解法："></a>解法：</h4><p>参考 </p>
<p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<h5 id="1-Map的哈希结构"><a href="#1-Map的哈希结构" class="headerlink" title="1.Map的哈希结构"></a>1.Map的哈希结构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span>(s.<span class="property">length</span> != t.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> map  = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">    map.<span class="title function_">set</span>(item,(map.<span class="title function_">get</span>(item) || <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> t)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.<span class="title function_">get</span>(item))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(item,(map.<span class="title function_">get</span>(item)-<span class="number">1</span> || <span class="number">0</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><h4 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/34.png"></p>
<h4 id="解法：-21"><a href="#解法：-21" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-带有去重的Set哈希结构"><a href="#1-带有去重的Set哈希结构" class="headerlink" title="1.带有去重的Set哈希结构"></a>1.带有去重的Set哈希结构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据数组大小交换操作的数组</span></span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span> &lt; nums2.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> _ = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nums1Set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums1);</span><br><span class="line">    <span class="keyword">const</span> resSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="comment">// for(const n of nums2) &#123;</span></span><br><span class="line">    <span class="comment">//     nums1Set.has(n) &amp;&amp; resSet.add(n);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 循环要比迭代器快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums2.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nums1Set.<span class="title function_">has</span>(nums2[i]) &amp;&amp; resSet.<span class="title function_">add</span>(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转化为数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(resSet);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><h4 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/37.png"></p>
<h4 id="解法：-22"><a href="#解法：-22" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-带有去重的Set哈希结构-1"><a href="#1-带有去重的Set哈希结构-1" class="headerlink" title="1.带有去重的Set哈希结构"></a>1.带有去重的Set哈希结构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//求每个位上的数的平方和操作</span></span><br><span class="line">    <span class="keyword">let</span> getSum = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> sum  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> digit = n%<span class="number">10</span>;</span><br><span class="line">            sum += (digit*digit);</span><br><span class="line">            n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set结构排除无限循环</span></span><br><span class="line">    <span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">     n = <span class="title function_">getSum</span>(n);</span><br><span class="line">     <span class="keyword">if</span>(set1.<span class="title function_">has</span>(n))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     set1.<span class="title function_">add</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><h4 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/10.png"></p>
<h4 id="解法：-23"><a href="#解法：-23" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-我的解法-两重循环"><a href="#1-我的解法-两重循环" class="headerlink" title="1.我的解法:两重循环"></a>1.我的解法:两重循环</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j] == target &amp;&amp;i!=j)&#123;</span><br><span class="line">                <span class="keyword">return</span> [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-最优解：哈希结构Map"><a href="#2-最优解：哈希结构Map" class="headerlink" title="2.最优解：哈希结构Map"></a>2.最优解：哈希结构Map</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="title function_">has</span>(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> [i, hash.<span class="title function_">get</span>(target - nums[i])];</span><br><span class="line">        &#125;</span><br><span class="line">        hash.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h3><h4 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/38.png"></p>
<h4 id="解法：-24"><a href="#解法：-24" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-数组哈希结构"><a href="#1-数组哈希结构" class="headerlink" title="1.数组哈希结构"></a>1.数组哈希结构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span>(<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>), </span><br><span class="line">        base = <span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> magazine) &#123;  <span class="comment">// 记录各个字符出现次数</span></span><br><span class="line">        strArr[s.<span class="title function_">charCodeAt</span>() - base]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> s <span class="keyword">of</span> ransomNote) &#123; <span class="comment">// 对应的字符个数做-操作</span></span><br><span class="line">        <span class="keyword">const</span> index = s.<span class="title function_">charCodeAt</span>() - base;</span><br><span class="line">        <span class="keyword">if</span>(!strArr[index]) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果没记录过直接返回false</span></span><br><span class="line">        strArr[index]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><h4 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/39.png"></p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><h5 id="1-双指针法-7"><a href="#1-双指针法-7" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> length  = s.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>,r = length;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = s[l];</span><br><span class="line">        s[l] = s[r];</span><br><span class="line">        s[r] = temp;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="反转字符串进阶"><a href="#反转字符串进阶" class="headerlink" title="反转字符串进阶"></a>反转字符串进阶</h3><h4 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/40.png"></p>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://www.programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
<h5 id="1-普通分类处理"><a href="#1-普通分类处理" class="headerlink" title="1.普通分类处理"></a>1.普通分类处理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span> (<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> arr =  <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;n;i+= <span class="number">2</span>*k)&#123;</span><br><span class="line">        <span class="title function_">reverse</span>(arr,i,<span class="title class_">Math</span>.<span class="title function_">min</span>(i+k,n)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-我的错误解法"><a href="#2-我的错误解法" class="headerlink" title="2.我的错误解法"></a>2.我的错误解法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> l = <span class="number">0</span>, r = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">      r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(i/<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">          temp = s[l];</span><br><span class="line">          s[l] = s[r];</span><br><span class="line">          s[r] = temp;</span><br><span class="line">          l++;</span><br><span class="line">          r--;</span><br><span class="line">      &#125;</span><br><span class="line">      l = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span></span><br><span class="line">      <span class="keyword">if</span> (i + k &lt; s.<span class="property">length</span> &amp;&amp; i + <span class="number">2</span>*k &gt; s.<span class="property">length</span>) &#123;</span><br><span class="line">          l = i - <span class="number">1</span>;</span><br><span class="line">          r = i + k - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">              temp = s[l];</span><br><span class="line">              s[l] = s[r];</span><br><span class="line">              s[r] = temp;</span><br><span class="line">              l++;</span><br><span class="line">              r--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i + k &gt; s.<span class="property">length</span>) &#123;</span><br><span class="line">          l = i - <span class="number">1</span>;</span><br><span class="line">          r = s.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">          <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">              temp = s[l];</span><br><span class="line">              s[l] = s[r];</span><br><span class="line">              s[r] = temp;</span><br><span class="line">              l++;</span><br><span class="line">              r--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>



<h3 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h3><h4 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/41.png"></p>
<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p>
<h5 id="1-双指针法-8"><a href="#1-双指针法-8" class="headerlink" title="1.双指针法"></a>1.双指针法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">//字符串转数组</span></span><br><span class="line">    <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">    <span class="comment">//移除多余空格</span></span><br><span class="line">    <span class="title function_">removeSpace</span>(strArr);</span><br><span class="line">    <span class="comment">//翻转整个字符串</span></span><br><span class="line">    <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除开始位置和重复的空格</span></span><br><span class="line">        <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            fastIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除末尾空格</span></span><br><span class="line">    strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> removeSpace = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slow = fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">//移除开头空格和重复的空格</span></span><br><span class="line">        <span class="keyword">if</span> (s[fast] == <span class="string">&#x27; &#x27;</span> &amp;&amp; (fast == <span class="number">0</span> || s[fast - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[slow] = s[fast];</span><br><span class="line">            fast++;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有遇到需要处理的空格,快慢指针向前</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除末尾空格，直接截取长度，排除末尾空格，这里找bug找了半小时，因为这个判断length长度要在上面这个循环遍历结束后才进行</span></span><br><span class="line">    <span class="keyword">if</span> (s[slow - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = slow - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.<span class="property">length</span> = slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转字符串</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span> (<span class="params">s, start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = start, r = end;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = s[l];</span><br><span class="line">        s[l] = s[r];</span><br><span class="line">        s[r] = temp;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><h4 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/43.png"></p>
<h4 id="解法：-25"><a href="#解法：-25" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-入栈和出栈"><a href="#1-入栈和出栈" class="headerlink" title="1.入栈和出栈"></a>1.入栈和出栈</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用两个数组的栈方法（push, pop） 实现队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Initialize your data structure here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">stackIn</span> = [];</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">stackOut</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Push element x to the back of queue. </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> size = <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span>;</span><br><span class="line">   <span class="keyword">if</span>(size) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Get the front element.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="title function_">pop</span>();</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x);</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><h4 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/42.png"></p>
<h4 id="解法：-26"><a href="#解法：-26" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-单个队列实现"><a href="#1-单个队列实现" class="headerlink" title="1.单个队列实现"></a>1.单个队列实现</h5><p>使用数组（push, shift）模拟队列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里相当于循环队列操作，把除了队列里最后一个元素外其它元素移到队列尾</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>());</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//调用这个实现的pop方法，防止影响真的弹出，所以又进队列原先是1234 ，pop后为4123-&gt;123，再恢复1234</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="variable language_">this</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><h4 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/48.png"></p>
<h4 id="解法：-27"><a href="#解法：-27" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1.辅助栈"></a>1.辅助栈</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/solutions/242190/zui-xiao-zhan-by-leetcode-solution/?envType=study-plan-v2&envId=selected-coding-interview">https://leetcode.cn/problems/min-stack/solutions/242190/zui-xiao-zhan-by-leetcode-solution/?envType=study-plan-v2&amp;envId=selected-coding-interview</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MinStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x_stack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span> = [<span class="title class_">Infinity</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x_stack</span>.<span class="title function_">push</span>(x);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="property">min_stack</span>[<span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="property">length</span> - <span class="number">1</span>], x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x_stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x_stack</span>[<span class="variable language_">this</span>.<span class="property">x_stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MinStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMin</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">min_stack</span>[<span class="variable language_">this</span>.<span class="property">min_stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><h4 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/9.png"></p>
<h4 id="解法：-28"><a href="#解法：-28" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-栈解法"><a href="#1-栈解法" class="headerlink" title="1.栈解法"></a>1.栈解法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c!=stack.<span class="title function_">pop</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h3><h4 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/44.png"></p>
<h4 id="解法：-29"><a href="#解法：-29" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-栈解法-1"><a href="#1-栈解法-1" class="headerlink" title="1.栈解法"></a>1.栈解法</h5><p>用数组模拟栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i  == stack[stack.<span class="property">length</span>-<span class="number">1</span>])&#123;</span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="数组的pop-和push"><a href="#数组的pop-和push" class="headerlink" title="数组的pop()和push();"></a>数组的pop()和push();</h5><p>在尾部追加，类似于压栈，原数组会变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">8</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1, 2, 3, 8]</span></span><br></pre></td></tr></table></figure>

<p>在尾部弹出，类似于出栈，原数组会变。数组的 <code>push</code> &amp; <code>pop</code> 可以模拟常见数据结构之一：栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> popVal = arr.<span class="title function_">pop</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(popVal) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组模拟常见数据结构之一：栈</span></span><br><span class="line"><span class="keyword">const</span> stack = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">2</span>) <span class="comment">// 压栈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack) <span class="comment">// [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> popValue = stack.<span class="title function_">pop</span>() <span class="comment">// 出栈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(popValue) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack) <span class="comment">// [0, 1]</span></span><br></pre></td></tr></table></figure>





<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><h4 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/45.png"></p>
<h4 id="解法：-30"><a href="#解法：-30" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-栈解法-2"><a href="#1-栈解法-2" class="headerlink" title="1.栈解法"></a>1.栈解法</h5><p><img src="/../images/%E7%AE%97%E6%B3%95/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//字符串数组</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span> (<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="comment">//数组模拟栈</span></span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="comment">//遍历操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(<span class="title class_">Number</span>(i))) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//表达式操作</span></span><br><span class="line">            <span class="comment">//因为要考虑被除数和除数的情况，所以要赋值操作方便</span></span><br><span class="line">            <span class="keyword">const</span> b = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">const</span> a = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    <span class="comment">//因为是字符串数组+会出现错误，要转换为数字类型</span></span><br><span class="line">                    stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(a) + <span class="title class_">Number</span>(b));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(a - b);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(a * b);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="comment">//考虑0的情况</span></span><br><span class="line">                    stack.<span class="title function_">push</span>(a / b | <span class="number">0</span> );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]; <span class="comment">// 因没有遇到运算符而待在栈中的结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h3><h4 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/47.png"></p>
<h4 id="解法：-31"><a href="#解法：-31" class="headerlink" title="解法："></a>解法：</h4><p>这道题目主要涉及到如下三块内容：</p>
<ol>
<li>要统计元素出现频率</li>
<li>对频率排序</li>
<li>找出前K个高频元素</li>
</ol>
<p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<p>本题我们就要使用优先级队列来对部分频率进行排序。</p>
<p>为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。</p>
<p>此时要思考一下，是使用小顶堆呢，还是大顶堆？</p>
<p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p>
<p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p>
<p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<h5 id="1-小顶堆-栈解"><a href="#1-小顶堆-栈解" class="headerlink" title="1.小顶堆+栈解"></a>1.小顶堆+栈解</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 没有堆 需要自己构造</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">compareFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="comment">// 推入元素</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(item);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上浮</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span>; <span class="comment">// 记录推入元素下标</span></span><br><span class="line">        <span class="keyword">let</span> parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 记录父节点下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (parent &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(parent, index) &gt; <span class="number">0</span>) &#123; <span class="comment">// 注意compare参数顺序</span></span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[parent]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[parent], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新下标</span></span><br><span class="line">            index = parent;</span><br><span class="line">            parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆顶元素并移除</span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 堆顶元素</span></span><br><span class="line">        <span class="keyword">const</span> out = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除堆顶元素 填入最后一个元素</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下沉</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 记录下沉元素下标</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>; <span class="comment">// left 是左子节点下标 left + 1 则是右子节点下标</span></span><br><span class="line">        <span class="keyword">let</span> searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (searchChild !== <span class="literal">undefined</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(index, searchChild) &gt; <span class="number">0</span>) &#123; <span class="comment">// 注意compare参数顺序</span></span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[searchChild]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[searchChild], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新下标</span></span><br><span class="line">            index = searchChild;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用传入的 compareFn 比较两个位置的元素</span></span><br><span class="line">    <span class="title function_">compare</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理下标越界问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index1] === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index2] === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">compareFn</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[index1], <span class="variable language_">this</span>.<span class="property">queue</span>[index2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建小顶堆</span></span><br><span class="line">    <span class="keyword">const</span> heap= <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry 是一个长度为2的数组，0位置存储key，1位置存储value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">        heap.<span class="title function_">push</span>(entry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">            heap.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return heap.queue.map(e =&gt; e[0]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = heap.<span class="title function_">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res[i] = heap.<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="先序遍历、中序遍历、后序遍历-递归"><a href="#先序遍历、中序遍历、后序遍历-递归" class="headerlink" title="先序遍历、中序遍历、后序遍历(递归)"></a>先序遍历、中序遍历、后序遍历(递归)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">先序遍历</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**中序遍历</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        a.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**后序遍历</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line">        a.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历、中序遍历、后序遍历-非递归"><a href="#先序遍历、中序遍历、后序遍历-非递归" class="headerlink" title="先序遍历、中序遍历、后序遍历(非递归)"></a>先序遍历、中序遍历、后序遍历(非递归)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//保存栈</span></span><br><span class="line">    <span class="keyword">let</span> a = [root];</span><br><span class="line">    <span class="comment">//结果栈</span></span><br><span class="line">    <span class="keyword">let</span> b = []</span><br><span class="line">    <span class="comment">//空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非空树</span></span><br><span class="line">    <span class="keyword">while</span>(a.<span class="property">length</span>)&#123;</span><br><span class="line">         <span class="comment">//这个指针head很重要，不能固定，而是要随着出栈的元素变化</span></span><br><span class="line">        <span class="keyword">let</span> head = a.<span class="title function_">pop</span>();</span><br><span class="line">         <span class="comment">//保存栈出，那么结果栈就得进</span></span><br><span class="line">        b.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">         <span class="comment">//如果有右树，进保存栈</span></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">right</span>)&#123;</span><br><span class="line">            a.<span class="title function_">push</span>(head.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有左树，进保存栈</span></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">left</span>)&#123;</span><br><span class="line">            a.<span class="title function_">push</span>(head.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//保存栈</span></span><br><span class="line">    <span class="keyword">let</span> b = [];</span><br><span class="line">    <span class="comment">//结果栈</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//处理空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先让临时变量指向根节点</span></span><br><span class="line">    <span class="keyword">let</span> head = root;</span><br><span class="line">    <span class="comment">//当保存栈不为空 或 临时变量有意义时</span></span><br><span class="line">    <span class="keyword">while</span> (b.<span class="property">length</span> || head) &#123;</span><br><span class="line">        <span class="comment">//遍历左子树节点进保存栈</span></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            b.<span class="title function_">push</span>(head);</span><br><span class="line">            head = head.<span class="property">left</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遍历左结束，开始出栈左和中</span></span><br><span class="line">            head = b.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="comment">//保存栈出，那么结果栈就得进</span></span><br><span class="line">            res.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历右子树重复  遍历左子树节点进保存栈的操作</span></span><br><span class="line">            <span class="comment">//出栈右</span></span><br><span class="line">            head = head.<span class="property">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//结果栈</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//保存栈</span></span><br><span class="line">    <span class="keyword">let</span> b = [root];</span><br><span class="line">    <span class="comment">//空树的情况</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非空树</span></span><br><span class="line">    <span class="keyword">while</span>(b.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="comment">//这个指针head很重要，不能固定，而是要随着出栈的元素变化</span></span><br><span class="line">        <span class="keyword">let</span> head = b.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="comment">//保存栈出，那么结果栈就得进</span></span><br><span class="line">        res.<span class="title function_">push</span>(head.<span class="property">val</span>);</span><br><span class="line">        <span class="comment">//如果有左树，进保存栈</span></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">left</span>)&#123;</span><br><span class="line">           b.<span class="title function_">push</span>(head.<span class="property">left</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有右树，进保存栈</span></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">right</span>)&#123;</span><br><span class="line">           b.<span class="title function_">push</span>(head.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转结果栈</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历：中左右</span></span><br><span class="line"><span class="comment">// 压栈顺序：右左中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span> (root) stack.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>().<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 左</span></span><br><span class="line">        stack.<span class="title function_">push</span>(node); <span class="comment">// 中</span></span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  中序遍历：左中右</span></span><br><span class="line"><span class="comment">//  压栈顺序：右中左</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span> (root) stack.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>().<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 右</span></span><br><span class="line">        stack.<span class="title function_">push</span>(node); <span class="comment">// 中</span></span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 左</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续遍历：左右中</span></span><br><span class="line"><span class="comment">// 压栈顺序：中右左</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root, res = []</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span> (root) stack.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>().<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>(node); <span class="comment">// 中</span></span><br><span class="line">        stack.<span class="title function_">push</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 左</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/49.png"></p>
<h4 id="解法：-32"><a href="#解法：-32" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-队列模拟"><a href="#1-队列模拟" class="headerlink" title="1.队列模拟"></a>1.队列模拟</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> outqueue = []</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> tempqueue  = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;temp;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> out = queue.<span class="title function_">shift</span>();</span><br><span class="line">            tempqueue.<span class="title function_">push</span>(out.<span class="property">val</span>)</span><br><span class="line">            <span class="keyword">if</span>(out.<span class="property">left</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(out.<span class="property">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out.<span class="property">right</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(out.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outqueue.<span class="title function_">push</span>(tempqueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outqueue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><h4 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/50.png"></p>
<h4 id="解法：-33"><a href="#解法：-33" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="1.层序遍历"></a>1.层序遍历</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用层序遍历反转二叉树</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//队列保存节点</span></span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="comment">//如果不为空树，根节点进队</span></span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> out = queue.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="comment">//交换左右子节点</span></span><br><span class="line">        <span class="keyword">let</span> temp = out.<span class="property">left</span>;</span><br><span class="line">        out.<span class="property">left</span> = out.<span class="property">right</span>;</span><br><span class="line">        out.<span class="property">right</span> = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一层加入</span></span><br><span class="line">        <span class="keyword">if</span>(out.<span class="property">left</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(out.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(out.<span class="property">right</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(out.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-先序遍历"><a href="#2-先序遍历" class="headerlink" title="2.先序遍历"></a>2.先序遍历</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//先序遍历反转二叉树</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> head = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">let</span> temp = head.<span class="property">left</span>;</span><br><span class="line">        head.<span class="property">left</span> = head.<span class="property">right</span>;</span><br><span class="line">        head.<span class="property">right</span> = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">right</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(head.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">left</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(head.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-递归遍历"><a href="#3-递归遍历" class="headerlink" title="3.递归遍历"></a>3.递归遍历</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换左右节点</span></span><br><span class="line">    <span class="comment">//相当于swap的过程，只不过这两个节点还要各自在递归下去</span></span><br><span class="line">    <span class="keyword">const</span> rightNode = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">invertTree</span>(root.<span class="property">left</span>);</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">invertTree</span>(rightNode);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="N叉树的前序遍历"><a href="#N叉树的前序遍历" class="headerlink" title="N叉树的前序遍历"></a>N叉树的前序遍历</h3><h4 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/51.png"></p>
<h4 id="解法：-34"><a href="#解法：-34" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1.递归法"></a>1.递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node|null</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> head = root;</span><br><span class="line">        res.<span class="title function_">push</span>(head.<span class="property">val</span>);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">for</span> (child <span class="keyword">of</span> head.<span class="property">children</span>) &#123;<span class="comment">//324</span></span><br><span class="line">            <span class="title function_">dfs</span>(child);<span class="comment">//56</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><h4 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/52.png"></p>
<h4 id="解法：-35"><a href="#解法：-35" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-分类讨论"><a href="#1-分类讨论" class="headerlink" title="1.分类讨论"></a>1.分类讨论</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compare = <span class="keyword">function</span>(<span class="params">node1,node2</span>)&#123;</span><br><span class="line">    <span class="comment">//分类讨论</span></span><br><span class="line">    <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node1 != <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node1.<span class="property">val</span>!= node2.<span class="property">val</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//递归左右的镜像</span></span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">compare</span>(node1.<span class="property">left</span>,node2.<span class="property">right</span>) &amp;&amp; <span class="title function_">compare</span>(node1.<span class="property">right</span>,node2.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回递归结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compare</span>(root.<span class="property">left</span>,root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><h4 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/53.png"></p>
<h4 id="解法：-36"><a href="#解法：-36" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层次遍历迭代法"><a href="#1-层次遍历迭代法" class="headerlink" title="1.层次遍历迭代法"></a>1.层次遍历迭代法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//层次遍历二叉树求最大深度</span></span><br><span class="line">    <span class="keyword">let</span> maxlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root!= <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//要用临时变量存储每一层的节点数量，防止length随着shift而变化</span></span><br><span class="line">        <span class="keyword">let</span> length = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      maxlength += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-后序递归法"><a href="#2-后序递归法" class="headerlink" title="2.后序递归法"></a>2.后序递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxdepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//使用递归的方法 递归三部曲</span></span><br><span class="line">    <span class="comment">//1. 确定递归函数的参数和返回值</span></span><br><span class="line">    <span class="keyword">const</span> getdepth = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">//2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//3. 确定单层逻辑</span></span><br><span class="line">        <span class="keyword">let</span> leftdepth = <span class="title function_">getdepth</span>(node.<span class="property">left</span>); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">let</span> rightdepth = <span class="title function_">getdepth</span>(node.<span class="property">right</span>); <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">let</span> depth = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftdepth, rightdepth); <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getdepth</span>(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-前序递归法"><a href="#3-前序递归法" class="headerlink" title="3.前序递归法"></a>3.前序递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用递归的方法 递归三部曲</span></span><br><span class="line">    <span class="comment">// 1. 确定递归函数的参数和返回值</span></span><br><span class="line">    <span class="keyword">const</span> getdepth = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 确定单层逻辑</span></span><br><span class="line">        <span class="keyword">let</span> depth = <span class="number">1</span>; <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">let</span> leftdepth = <span class="title function_">getdepth</span>(node.<span class="property">left</span>);<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">let</span> rightdepth = <span class="title function_">getdepth</span>(node.<span class="property">right</span>);<span class="comment">//右</span></span><br><span class="line">        depth += <span class="title class_">Math</span>.<span class="title function_">max</span>(leftdepth, rightdepth);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getdepth</span>(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>前序遍历充分表现出求深度回溯的过程</strong></p>
<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><h4 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/54.png"></p>
<h4 id="解法：-37"><a href="#解法：-37" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层次遍历迭代法-1"><a href="#1-层次遍历迭代法-1" class="headerlink" title="1.层次遍历迭代法"></a>1.层次遍历迭代法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//层次遍历二叉树求最小深度</span></span><br><span class="line">    <span class="keyword">let</span> minlength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root!= <span class="literal">null</span>)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="comment">//直接返回最小长度</span></span><br><span class="line">        <span class="keyword">if</span>(!temp.<span class="property">left</span> &amp;&amp; !temp.<span class="property">right</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> minlength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明这一层没有叶子节点，所以要层数+1</span></span><br><span class="line">      minlength += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minlength;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><h4 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/55.png"></p>
<h4 id="解法：-38"><a href="#解法：-38" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层次遍历法"><a href="#1-层次遍历法" class="headerlink" title="1.层次遍历法"></a>1.层次遍历法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 层次遍历法</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>();</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="property">left</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="property">right</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getcount = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> leftnum = <span class="title function_">getcount</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">let</span> rightnum = <span class="title function_">getcount</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">let</span> treenum = leftnum + rightnum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> treenum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">getcount</span>(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2.递归法"></a>2.递归法</h5><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/56.png"></p>
<h4 id="解法：-39"><a href="#解法：-39" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-后序递归法"><a href="#1-后序递归法" class="headerlink" title="1.后序递归法"></a>1.后序递归法</h5><p>求高度 – 后序</p>
<p>求深度 –先序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getheight = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左子树不为平衡二叉树，就直接返回-1  ----左</span></span><br><span class="line">        <span class="keyword">let</span> leftHeight = <span class="title function_">getheight</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右子树不为平衡二叉树，就直接返回-1 -----右</span></span><br><span class="line">        <span class="keyword">let</span> rightHeight = <span class="title function_">getheight</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightHeight == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果该左右子树高度之差，也就是后序遍历左右中的中节点----中</span></span><br><span class="line">        <span class="comment">// 不为平衡二叉树，就直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(leftHeight-rightHeight)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight,rightHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !(<span class="title function_">getheight</span>(root) === -<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><h4 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/57.png"></p>
<h4 id="解法：-40"><a href="#解法：-40" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-递归-回溯法"><a href="#1-递归-回溯法" class="headerlink" title="1.递归+回溯法"></a>1.递归+回溯法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> getPath = <span class="keyword">function</span>(<span class="params">node,curPath</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> == <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            curPath += node.<span class="property">val</span>;</span><br><span class="line">            res.<span class="title function_">push</span>(curPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curPath += node.<span class="property">val</span> +<span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="title function_">getPath</span>(node.<span class="property">left</span>,curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="title function_">getPath</span>(node.<span class="property">right</span>,curPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="title function_">getPath</span>(root,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZG411G7Dh/?vd_source=1d570edaa4d98b311404ac363e136ee7">https://www.bilibili.com/video/BV1ZG411G7Dh/?vd_source=1d570edaa4d98b311404ac363e136ee7</a></p>
<p>在给定的 JavaScript 代码中，回溯(backtracking)并不是显式地呈现出来，但实际上在递归过程中确实有回溯的概念。回溯是一种在解决问题时以试错的方式探索所有可能的解空间的方法，当发现当前路径不满足问题要求时，会回退到之前的状态，尝试其他路径。</p>
<p>在这个特定的例子中，回溯体现在函数 <code>getPath</code> 中的递归调用过程中。当递归调用 <code>getPath</code> 函数时，会传递当前节点的左子树或右子树，并且在每一次递归调用之后，都会将路径 <code>curPath</code> 恢复到之前的状态，这就是回溯的体现。</p>
<p>具体来说，在递归调用之前，<code>curPath</code> 会添加当前节点的值和连接符 <code>-&gt;</code>，然后递归调用左右子树，但在递归调用结束后，<code>curPath</code> 并没有改变，而是保持在之前的状态。这样，当递归回到上一层时，<code>curPath</code> 就回到了之前的状态，相当于回退了一个步骤，这就是回溯的过程。</p>
<p>回溯虽然没有显式地写出来，但是通过递归的方式，在每一层递归中都会涉及到对路径的选择和回退，从而实现了回溯的功能。</p>
<p>在递归函数 getPath 中，当达到叶子节点时，会将当前路径 curPath 加上当前节点的值，并将该路径添加到结果数组 res 中。然后，递归函数会立即返回。在返回之后，由于 JavaScript 中函数参数是按值传递的，而不是按引用传递，所以 curPath 不会受到影响，它的值仍然是递归调用之前的值。</p>
<p>具体来说，在这段代码中，curPath 的值在递归调用时会被修改，但在递归返回时不会被修改。因此，当递归返回之后，curPath 的值应该是递归调用之前的值。</p>
<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><h4 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/58.png"></p>
<h4 id="解法：-41"><a href="#解法：-41" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层序遍历-处理父节点"><a href="#1-层序遍历-处理父节点" class="headerlink" title="1.层序遍历+处理父节点"></a>1.层序遍历+处理父节点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="comment">//通过节点的父节点来判断其左孩子是不是左叶子了</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span> &amp;&amp; !temp.<span class="property">left</span>.<span class="property">left</span> &amp;&amp; !temp.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">            sum += temp.<span class="property">left</span>.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><h4 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/60.png"></p>
<h4 id="解法：-42"><a href="#解法：-42" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-层序遍历-简单判断"><a href="#1-层序遍历-简单判断" class="headerlink" title="1.层序遍历 + 简单判断"></a>1.层序遍历 + 简单判断</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="comment">//这里result每过一层都会被覆盖，所以result的值为最后一层的最左值</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                result = temp.<span class="property">val</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="property">left</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(temp.<span class="property">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="property">right</span>)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(temp.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-递归法-1"><a href="#2-递归法-1" class="headerlink" title="2.递归法"></a>2.递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//首先考虑递归遍历 前序遍历 找到最大深度的叶子节点即可</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>, resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数的函数参数</span></span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="keyword">function</span>(<span class="params">node, curPath</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 确定递归函数终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curPath &gt; maxPath) &#123;</span><br><span class="line">            maxPath = curPath;</span><br><span class="line">            resNode = node.<span class="property">val</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">left</span> &amp;&amp; <span class="title function_">dfsTree</span>(node.<span class="property">left</span>, curPath+<span class="number">1</span>);</span><br><span class="line">        node.<span class="property">right</span> &amp;&amp; <span class="title function_">dfsTree</span>(node.<span class="property">right</span>, curPath+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfsTree</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>怎么判断当前层数是最后一层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否到达最后一层</span></span><br><span class="line">       <span class="keyword">if</span>(queue.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">           result = queue[<span class="number">0</span>].<span class="property">val</span>; <span class="comment">// 更新result为最后一层的最左边节点的值</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><h4 id="题目-45"><a href="#题目-45" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/59.png"></p>
<h4 id="解法：-43"><a href="#解法：-43" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-递归-回溯法-1"><a href="#1-递归-回溯法-1" class="headerlink" title="1.递归+回溯法"></a>1.递归+回溯法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getPath = <span class="keyword">function</span> (<span class="params">node, sum</span>) &#123;</span><br><span class="line">        <span class="comment">//防止节点为空的情况导致下面node.left和node.right访问空值</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span> == <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += node.<span class="property">val</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一般处理</span></span><br><span class="line">        sum += node.<span class="property">val</span>;</span><br><span class="line">        <span class="comment">//只需要一条路径满足目标之和就可，无需找到后再接着遍历其它路径</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="title function_">getPath</span>(node.<span class="property">left</span>, sum)) || (<span class="title function_">getPath</span>(node.<span class="property">right</span>, sum));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getPath</span>(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><strong>从中序与后序遍历序列构造二叉树</strong></h3><h4 id="题目-46"><a href="#题目-46" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/62.png"></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<img src="../images/算法/61.png" style="zoom:50%;">

<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<h4 id="解法：-44"><a href="#解法：-44" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-节点切割左右数组"><a href="#1-节点切割左右数组" class="headerlink" title="1.节点切割左右数组"></a>1.节点切割左右数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">postorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="comment">//没有节点，返回了</span></span><br><span class="line">    <span class="keyword">if</span>(!postorder.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出后序的最后一个节点，它为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootval = postorder.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录这个根节点在中序中的位置</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.<span class="title function_">indexOf</span>(rootval);</span><br><span class="line">    <span class="comment">//新建一个中间节点</span></span><br><span class="line">    <span class="keyword">const</span> rootnode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval); </span><br><span class="line">    <span class="comment">//根据中序中的位置index 作为分割左中，右中序列的标志</span></span><br><span class="line">    <span class="comment">//递归操作</span></span><br><span class="line">    rootnode.<span class="property">left</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(<span class="number">0</span>,index),postorder.<span class="title function_">slice</span>(<span class="number">0</span>,index));</span><br><span class="line">    rootnode.<span class="property">right</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(index+<span class="number">1</span>),postorder.<span class="title function_">slice</span>(index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给左或右</span></span><br><span class="line">    <span class="keyword">return</span> rootnode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><strong>从前序与中序遍历序列构造二叉树</strong></h3><h4 id="题目-47"><a href="#题目-47" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/63.png"></p>
<h4 id="解法：-45"><a href="#解法：-45" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-节点切割左右数组-1"><a href="#1-节点切割左右数组-1" class="headerlink" title="1.节点切割左右数组"></a>1.节点切割左右数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">preorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">postorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">preorder, inorder</span>)  &#123;</span><br><span class="line">    <span class="comment">//没有节点，返回了</span></span><br><span class="line">    <span class="keyword">if</span>(!preorder.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出先序的第一个节点，它为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootval = preorder.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录这个根节点在中序中的位置</span></span><br><span class="line">    <span class="keyword">let</span> index = inorder.<span class="title function_">indexOf</span>(rootval);</span><br><span class="line">    <span class="comment">//新建一个中间节点</span></span><br><span class="line">    <span class="keyword">const</span> rootnode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval); </span><br><span class="line">    <span class="comment">//根据中序中的位置index 作为分割左中，右中序列的标志</span></span><br><span class="line">    <span class="comment">//递归操作</span></span><br><span class="line">    <span class="comment">//对象引用传递，所以传入的preorder一直在改变</span></span><br><span class="line">    <span class="comment">//这里为什么要传(0,index)而不是(1,index)，因为preorder已经弹出一个根节点元素了，所以从0开始，并不会搞到根节点</span></span><br><span class="line">    rootnode.<span class="property">left</span> = <span class="title function_">buildTree</span>(preorder.<span class="title function_">slice</span>(<span class="number">0</span>,index),inorder.<span class="title function_">slice</span>(<span class="number">0</span>,index));</span><br><span class="line">    rootnode.<span class="property">right</span> = <span class="title function_">buildTree</span>(preorder.<span class="title function_">slice</span>(index),inorder.<span class="title function_">slice</span>(index+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给左或右</span></span><br><span class="line">    <span class="keyword">return</span> rootnode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p><strong>js不是值传递吗？为什么递归调用结束后preorder会被改变呢?</strong></p>
<p>在 JavaScript 中，虽然函数参数是按值传递的，但是对于对象（包括数组）来说，传递的是引用的副本。这意味着，当你将一个对象作为参数传递给函数时，实际上传递的是该对象的引用（内存地址），而不是对象本身的副本。因此，在函数内部对该对象的修改会影响到原始对象。</p>
<p>在你的代码中，虽然 <code>preorder</code> 是一个数组，但是传递给 <code>buildTree</code> 函数时，实际上是传递了数组的引用。所以在递归调用中对 <code>preorder</code> 的修改会影响到原始的 <code>preorder</code> 数组。</p>
<p>在递归调用结束后，<code>preorder</code> 数组被修改的原因是因为在每次递归调用中，使用了 <code>preorder.shift()</code> 来取出根节点，这会改变原始的 <code>preorder</code> 数组，使其每次递归调用时都减少一个节点。</p>
<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><h4 id="题目-48"><a href="#题目-48" class="headerlink" title="题目"></a>题目</h4><p><img src="/../images/%E7%AE%97%E6%B3%95/64.png"></p>
<h4 id="解法：-46"><a href="#解法：-46" class="headerlink" title="解法："></a>解法：</h4><h5 id="1-递归法-1"><a href="#1-递归法-1" class="headerlink" title="1.递归法"></a>1.递归法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归函数，用于构建最大二叉树</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">BuildTree</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 基本情况：如果左索引大于右索引，则返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化变量来追踪最大值及其索引</span></span><br><span class="line">        <span class="keyword">let</span> maxValue = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> maxIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历子数组，从左索引到右索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素大于最大值，则更新最大值及其索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = arr[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建根节点，值为最大值</span></span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="title class_">BuildTree</span>(arr, left, maxIndex - <span class="number">1</span>);</span><br><span class="line">        root.<span class="property">right</span> = <span class="title class_">BuildTree</span>(arr, maxIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数，构建整个数组对应的最大二叉树</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="title class_">BuildTree</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回最大二叉树的根节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left &gt; right)            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">什么时候会发生？</span><br></pre></td></tr></table></figure>

<p>当递归过程中传入的左索引 <code>left</code> 大于右索引 <code>right</code> 时，意味着当前子数组为空，即没有节点需要处理。</p>
<p>没有需要构建的节点，因此递归可以终止，直接返回 <code>null</code>。这样做可以避免进一步的递归调用，从而节省时间和空间。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">黑板擦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/24/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">http://example.com/2024/03/24/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">我在看着你</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/25/%E5%86%8D%E8%AF%86Vue2-%E4%B8%80/" title="再识Vue2(一)"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">再识Vue2(一)</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/13/Vue3-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/" title="Vue3_博客系统"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue3_博客系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/Snipaste_2024-04-06_01-08-30.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">黑板擦</div><div class="author-info__description">别看我</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Yukino013" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1291469690@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.</span> <span class="toc-text">堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">数组去重的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A9%E7%94%A8-ES6-Set-%E5%8E%BB%E9%87%8D%EF%BC%88ES6-%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.利用 ES6 Set 去重（ES6 中最常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%88%A9%E7%94%A8-for-%E5%B5%8C%E5%A5%97-for%EF%BC%8C%E7%84%B6%E5%90%8E-splice-%E5%8E%BB%E9%87%8D%EF%BC%88ES5-%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8-indexOf-%E5%8E%BB%E9%87%8D"><span class="toc-number">1.3.</span> <span class="toc-text">3.利用 indexOf 去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%A9%E7%94%A8-includes"><span class="toc-number">1.4.</span> <span class="toc-text">4.利用 includes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%A9%E7%94%A8-Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.5.</span> <span class="toc-text">5.利用 Map 数据结构去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E2%80%A6new-Set-arr"><span class="toc-number">1.6.</span> <span class="toc-text">6.[…new Set(arr)]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二分法两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">二分法第一种写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">二分法第二种写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CodeTop-%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91-60"><span class="toc-number"></span> <span class="toc-text">CodeTop 前端高频 60</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">0.模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">题目：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-1"><span class="toc-number">2.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.滑动窗口法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-2"><span class="toc-number">3.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%E5%86%8D%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.合并数组再比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#splice"><span class="toc-number">3.3.</span> <span class="toc-text">splice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-number">3.4.</span> <span class="toc-text">sort()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BB%8E%E5%90%8E%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">2.双指针从后遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">比较版本号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-3"><span class="toc-number">4.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.分割字符法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spilt"><span class="toc-number">4.3.</span> <span class="toc-text">spilt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shift"><span class="toc-number">4.4.</span> <span class="toc-text">shift()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">5.</span> <span class="toc-text">爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-number">5.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-4"><span class="toc-number">5.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-number">6.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-5"><span class="toc-number">6.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.回溯算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc-number">7.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-6"><span class="toc-number">7.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="toc-number">8.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-7"><span class="toc-number">8.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">1.双指针加一个临时变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="toc-number">9.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-8"><span class="toc-number">9.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">9.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">思考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">10.</span> <span class="toc-text">移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="toc-number">10.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-9"><span class="toc-number">10.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">11.</span> <span class="toc-text">删除有序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="toc-number">11.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-10"><span class="toc-number">11.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-2"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="toc-number">12.</span> <span class="toc-text">删除排序数组中的重复项 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="toc-number">12.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-11"><span class="toc-number">12.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-3"><span class="toc-number">12.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">13.</span> <span class="toc-text">长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="toc-number">13.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-12"><span class="toc-number">13.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-4"><span class="toc-number">13.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">14.</span> <span class="toc-text">移除链表元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="toc-number">14.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-13"><span class="toc-number">14.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">14.2.1.</span> <span class="toc-text">1.虚拟头结点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">15.</span> <span class="toc-text">有序数组的平方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="toc-number">15.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-14"><span class="toc-number">15.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-5"><span class="toc-number">15.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">删除链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="toc-number">16.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-15"><span class="toc-number">16.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9B%BF%E6%8D%A2"><span class="toc-number">16.2.1.</span> <span class="toc-text">1.替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="toc-number">17.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-16"><span class="toc-number">17.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">17.2.1.</span> <span class="toc-text">1.虚拟头节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">删除链表的倒数第N个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="toc-number">18.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-17"><span class="toc-number">18.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-6"><span class="toc-number">18.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">19.</span> <span class="toc-text">链表相交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="toc-number">19.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-18"><span class="toc-number">19.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E6%95%B0%E5%AD%A6%E8%BF%BD%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number">19.2.1.</span> <span class="toc-text">1.快慢双指针法+数学追及问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">20.</span> <span class="toc-text">环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-18"><span class="toc-number">20.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-19"><span class="toc-number">20.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E6%95%B0%E5%AD%A6%E8%BF%BD%E5%8F%8A%E9%97%AE%E9%A2%98-1"><span class="toc-number">20.2.1.</span> <span class="toc-text">1.快慢双指针法+数学追及问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.</span> <span class="toc-text">有效的字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-19"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-20"><span class="toc-number">1.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Map%E7%9A%84%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.Map的哈希结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-20"><span class="toc-number">2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-21"><span class="toc-number">2.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%A6%E6%9C%89%E5%8E%BB%E9%87%8D%E7%9A%84Set%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.带有去重的Set哈希结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-21"><span class="toc-number">3.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-22"><span class="toc-number">3.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%A6%E6%9C%89%E5%8E%BB%E9%87%8D%E7%9A%84Set%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.带有去重的Set哈希结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-22"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-23"><span class="toc-number">4.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%88%91%E7%9A%84%E8%A7%A3%E6%B3%95-%E4%B8%A4%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.我的解法:两重循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%9A%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84Map"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.最优解：哈希结构Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">5.</span> <span class="toc-text">赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-23"><span class="toc-number">5.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-24"><span class="toc-number">5.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.数组哈希结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">反转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-24"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-7"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">反转字符串进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-25"><span class="toc-number">2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="toc-number">2.2.</span> <span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E5%88%86%E7%B1%BB%E5%A4%84%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.普通分类处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%88%91%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.我的错误解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">3.</span> <span class="toc-text">反转字符串中的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-26"><span class="toc-number">3.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-2"><span class="toc-number">3.2.</span> <span class="toc-text">解法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-8"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.双指针法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-27"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-25"><span class="toc-number">1.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.入栈和出栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-28"><span class="toc-number">2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-26"><span class="toc-number">2.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.单个队列实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text">最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-29"><span class="toc-number">3.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-27"><span class="toc-number">3.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.辅助栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">有效的括号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-30"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-28"><span class="toc-number">4.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%88%E8%A7%A3%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.栈解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">5.</span> <span class="toc-text">删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-31"><span class="toc-number">5.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-29"><span class="toc-number">5.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%88%E8%A7%A3%E6%B3%95-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.栈解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84pop-%E5%92%8Cpush"><span class="toc-number">5.2.2.</span> <span class="toc-text">数组的pop()和push();</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-32"><span class="toc-number">6.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-30"><span class="toc-number">6.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A0%88%E8%A7%A3%E6%B3%95-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.栈解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">7.</span> <span class="toc-text">前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-33"><span class="toc-number">7.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-31"><span class="toc-number">7.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B0%8F%E9%A1%B6%E5%A0%86-%E6%A0%88%E8%A7%A3"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.小顶堆+栈解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92"><span class="toc-number">1.</span> <span class="toc-text">先序遍历、中序遍历、后序遍历(递归)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">2.</span> <span class="toc-text">先序遍历、中序遍历、后序遍历(非递归)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">二叉树的统一迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.</span> <span class="toc-text">层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-34"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-32"><span class="toc-number">4.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.队列模拟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-35"><span class="toc-number">5.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-33"><span class="toc-number">5.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.层序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.递归遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.</span> <span class="toc-text">N叉树的前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-36"><span class="toc-number">6.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-34"><span class="toc-number">6.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-37"><span class="toc-number">7.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-35"><span class="toc-number">7.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.分类讨论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.</span> <span class="toc-text">二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-38"><span class="toc-number">8.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-36"><span class="toc-number">8.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">1.层次遍历迭代法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.后序递归法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%89%8D%E5%BA%8F%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.前序递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-39"><span class="toc-number">9.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-37"><span class="toc-number">9.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%B3%95-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">1.层次遍历迭代法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-40"><span class="toc-number">10.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-38"><span class="toc-number">10.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E6%B3%95"><span class="toc-number">10.2.1.</span> <span class="toc-text">1.层次遍历法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-41"><span class="toc-number">11.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-39"><span class="toc-number">11.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.后序递归法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">12.</span> <span class="toc-text">二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-42"><span class="toc-number">12.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-40"><span class="toc-number">12.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">12.2.1.</span> <span class="toc-text">1.递归+回溯法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">13.</span> <span class="toc-text">左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-43"><span class="toc-number">13.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-41"><span class="toc-number">13.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%A4%84%E7%90%86%E7%88%B6%E8%8A%82%E7%82%B9"><span class="toc-number">13.2.1.</span> <span class="toc-text">1.层序遍历+处理父节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">14.</span> <span class="toc-text">找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-44"><span class="toc-number">14.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-42"><span class="toc-number">14.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E7%AE%80%E5%8D%95%E5%88%A4%E6%96%AD"><span class="toc-number">14.2.1.</span> <span class="toc-text">1.层序遍历 + 简单判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E6%B3%95-1"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.递归法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">14.3.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">15.</span> <span class="toc-text">路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-45"><span class="toc-number">15.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-43"><span class="toc-number">15.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%E6%B3%95-1"><span class="toc-number">15.2.1.</span> <span class="toc-text">1.递归+回溯法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">16.</span> <span class="toc-text">从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-46"><span class="toc-number">16.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">16.2.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-44"><span class="toc-number">16.3.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E5%88%87%E5%89%B2%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%BB%84"><span class="toc-number">16.3.1.</span> <span class="toc-text">1.节点切割左右数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">17.</span> <span class="toc-text">从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-47"><span class="toc-number">17.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-45"><span class="toc-number">17.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E5%88%87%E5%89%B2%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%BB%84-1"><span class="toc-number">17.2.1.</span> <span class="toc-text">1.节点切割左右数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-number">17.3.</span> <span class="toc-text">注意点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">18.</span> <span class="toc-text">最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-48"><span class="toc-number">18.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-46"><span class="toc-number">18.2.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E6%B3%95-1"><span class="toc-number">18.2.1.</span> <span class="toc-text">1.递归法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">18.3.</span> <span class="toc-text">注意点:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/scss/" title="scss"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="scss"/></a><div class="content"><a class="title" href="/2024/04/15/scss/" title="scss">scss</a><time datetime="2024-04-14T16:30:57.000Z" title="发表于 2024-04-15 00:30:57">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/12/Uniapp%E5%AD%A6%E4%B9%A0/" title="uniapp学习"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="uniapp学习"/></a><div class="content"><a class="title" href="/2024/04/12/Uniapp%E5%AD%A6%E4%B9%A0/" title="uniapp学习">uniapp学习</a><time datetime="2024-04-12T13:02:56.000Z" title="发表于 2024-04-12 21:02:56">2024-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/10/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E5%AD%A6%E4%B9%A0/" title="会话控制"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="会话控制"/></a><div class="content"><a class="title" href="/2024/04/10/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E5%AD%A6%E4%B9%A0/" title="会话控制">会话控制</a><time datetime="2024-04-10T13:40:38.000Z" title="发表于 2024-04-10 21:40:38">2024-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/10/%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/" title="接口"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="接口"/></a><div class="content"><a class="title" href="/2024/04/10/%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/" title="接口">接口</a><time datetime="2024-04-09T17:21:01.000Z" title="发表于 2024-04-10 01:21:01">2024-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/08/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0Github/" title="记录第一次项目上传github"><img src="/./img/Snipaste_2024-04-06_01-13-21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记录第一次项目上传github"/></a><div class="content"><a class="title" href="/2024/04/08/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0Github/" title="记录第一次项目上传github">记录第一次项目上传github</a><time datetime="2024-04-08T08:49:15.000Z" title="发表于 2024-04-08 16:49:15">2024-04-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 黑板擦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>